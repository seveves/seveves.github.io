{"version":3,"sources":["webpack:///main.8180ef8b31c42df2d539.bundle.js","webpack:///./components/index.ts","webpack:///./components/network/index.ts","webpack:///./components/network/vis-network.directive.ts","webpack:///./components/network/vis-network.service.ts","webpack:///./components/timeline/index.ts","webpack:///./components/timeline/vis-timeline.directive.ts","webpack:///./components/timeline/vis-timeline.service.ts","webpack:///./demo/demo.component.html","webpack:///./demo/demo.component.ts","webpack:///./demo/demo.module.ts","webpack:///./demo/home/home.component.html","webpack:///./demo/home/home.component.ts","webpack:///./demo/index.ts","webpack:///./demo/network/network-example.component.css","webpack:///./demo/network/network-example.component.html","webpack:///./demo/network/network-example.component.ts","webpack:///./demo/timeline/timeline-example.component.css","webpack:///./demo/timeline/timeline-example.component.html","webpack:///./demo/timeline/timeline-example.component.ts","webpack:///./ng2-vis.ts","webpack:///./~/@angular/router/bundles/router.umd.js","webpack:///./~/rxjs/BehaviorSubject.js","webpack:///./~/rxjs/InnerSubscriber.js","webpack:///./~/rxjs/Notification.js","webpack:///./~/rxjs/OuterSubscriber.js","webpack:///./~/rxjs/observable/ArrayLikeObservable.js","webpack:///./~/rxjs/observable/ArrayObservable.js","webpack:///./~/rxjs/observable/EmptyObservable.js","webpack:///./~/rxjs/observable/FromObservable.js","webpack:///./~/rxjs/observable/IteratorObservable.js","webpack:///./~/rxjs/observable/ScalarObservable.js","webpack:///./~/rxjs/observable/from.js","webpack:///./~/rxjs/observable/of.js","webpack:///./~/rxjs/operator/catch.js","webpack:///./~/rxjs/operator/concatAll.js","webpack:///./~/rxjs/operator/concatMap.js","webpack:///./~/rxjs/operator/every.js","webpack:///./~/rxjs/operator/filter.js","webpack:///./~/rxjs/operator/first.js","webpack:///./~/rxjs/operator/last.js","webpack:///./~/rxjs/operator/map.js","webpack:///./~/rxjs/operator/mergeAll.js","webpack:///./~/rxjs/operator/mergeMap.js","webpack:///./~/rxjs/operator/observeOn.js","webpack:///./~/rxjs/operator/reduce.js","webpack:///./~/rxjs/symbol/iterator.js","webpack:///./~/rxjs/util/EmptyError.js","webpack:///./~/rxjs/util/isPromise.js","webpack:///./~/rxjs/util/isScheduler.js","webpack:///./~/rxjs/util/subscribeToResult.js"],"names":["webpackJsonp","322","module","exports","__webpack_require__","__export","m","p","hasOwnProperty","55","Vis","VisNetwork","_super","apply","this","arguments","__extends","Network","VisNodes","data","options","call","prototype","getLength","length","add","senderId","clear","distinct","field","flush","forEach","callback","getAll","get","getById","id","getByIds","ids","getDataSet","getIds","map","max","min","on","event","off","removeItems","remove","setOptions","update","DataSet","VisEdges","323","core_1","vis_network_service_1","VisNetworkDirective","elementRef","visNetworkService","initialized","EventEmitter","_isInitialized","_visNetworkContainer","nativeElement","ngOnInit","visNetwork","visNetworkData","createNetwork","ngOnChanges","changes","propertyName","change","isFirstChange","setData","currentValue","ngOnDestroy","destroy","create","visNetworkOptions","emit","__decorate","Input","__metadata","String","Object","Output","Directive","selector","ElementRef","VisNetworkService","134","index_1","click","doubleClick","oncontext","hold","release","select","selectNode","selectEdge","deselectNode","deselectEdge","dragStart","dragging","dragEnd","hoverNode","blurNode","hoverEdge","blurEdge","zoom","showPopup","hidePopup","startStabilizing","stabilizationProgress","stabilizationIterationsDone","stabilized","resize","initRedraw","beforeDrawing","afterDrawing","animationFinished","configChange","_networks","container","Error","eventName","preventDefault","that_1","params","emitter","concat","once","_this","that_2","selectNodes","nodeIds","highlightEdges","getSelection","getSelectedNodes","getSelectedEdges","unselectAll","fit","redraw","enableEditMode","addEdgeMode","disableEditMode","deleteSelected","cluster","openCluster","nodeId","isCluster","getSeed","Injectable","43","VisTimelineItems","VisTimelineGroups","VisTimeline","Timeline","324","vis_timeline_service_1","VisTimelineDirective","visTimelineService","_visTimelineContainer","visTimeline","visTimelineItems","createTimeline","setItems","setGroups","visTimelineGroups","createWithItemsAndGroups","visTimelineOptions","createWithItems","VisTimelineService","135","currentTimeTick","contextmenu","groupDragged","changed","rangechange","rangechanged","itemover","itemout","timechange","timechanged","_timelines","items","alreadyExistsError","groups","addCustomTime","time","doesNotExistError","focusOnId","focus","focusOnIds","getCurrentTime","getCustomTime","getEventProperties","getItemRange","getVisibleItems","getWindow","moveTo","removeCustomTime","setCurrentTime","setCustomTime","setCustomTimeTitle","title","setSelectionToId","setSelection","setSelectionToIds","setWindow","start","end","undefined","138","325","DemoComponent","Component","template","326","forms_1","platform_browser_1","common_1","router_1","network_example_component_1","timeline_example_component_1","ng2_vis_1","demo_component_1","home_component_1","VisDemoModule","NgModule","declarations","HomeComponent","VisNetworkExampleComponent","VisTimelineExampleComponent","imports","BrowserModule","FormsModule","VisModule","CommonModule","RouterModule","forRoot","path","component","redirectTo","pathMatch","providers","bootstrap","139","327","0","platform_browser_dynamic_1","demo_module_1","platformBrowserDynamic","bootstrapModule","140","141","328","network_1","ExampleNetworkData","addNode","newId","nodes","toString","label","networkInitialized","subscribe","eventData","console","log","edges","from","to","styles","142","143","329","timeline_1","timelineInitialized","addItem","newLength","content","Date","now","type","330","index_2","137","global","factory","_angular_common","_angular_core","rxjs_Subject","rxjs_observable_from","rxjs_observable_of","rxjs_operator_concatMap","rxjs_operator_every","rxjs_operator_map","rxjs_operator_mergeAll","rxjs_operator_mergeMap","rxjs_operator_reduce","rxjs_Observable","rxjs_operator_catch","rxjs_operator_concatAll","rxjs_operator_first","rxjs_util_EmptyError","rxjs_observable_fromPromise","l","rxjs_BehaviorSubject","rxjs_operator_filter","shallowEqualArrays","a","b","i","shallowEqual","k1","keys","k2","key","flatten","target","j","push","last","merge","m1","m2","attr","prop","waitForMap","obj","fn","waitFor","res","k","PRIMARY_OUTLET","_","concatted$","concatAll","of","last$","andObservables","observables","merged$","mergeAll","every","result","wrapIntoObservable","value","Observable","Promise","fromPromise","createEmptyUrlTree","UrlTree","UrlSegmentGroup","containsTree","containee","exact","equalSegmentGroups","root","containsSegmentGroup","equalPath","segments","numberOfChildren","c","children","containsSegmentGroupHelper","containeePaths","current","slice","hasChildren","next","mapChildrenIntoArray","segment","child","childOutlet","serializePaths","serializePath","join","serializeSegment","primary","children_1","v","encode","s","encodeURIComponent","decode","decodeURIComponent","serializeParams","parameters","pairs","first","second","serializeQueryParams","strs","Pair","matchSegments","str","SEGMENT_RE","lastIndex","match","matchQueryParams","QUERY_PARAM_RE","matchUrlQueryParamValue","QUERY_PARAM_VALUE_RE","noMatch","segmentGroup","obs","error","NoMatch","absoluteRedirect","AbsoluteRedirect","canLoadFails","route","NavigationCancelingError","applyRedirects","injector","configLoader","urlTree","config","ApplyRedirects","runGuards","canLoad","guard","matched","consumedSegments","lastChild","positionalParamSegments","parts","split","currentIndex","isPosParam","startsWith","substring","applyRedirectCommands","posParams","r","createSegments","findPosParam","findOrCreateSegment","part","paramName","pos","idx","_i","segments_1","splice","UrlSegment","slicedSegments","containsEmptyPathRedirectsWithNamedOutlets","createChildrenForEmptySegments","mergeTrivialChildren","containsEmptyPathRedirects","addEmptySegmentsToChildrenIfNeeded","routes","routes_1","emptyPathRedirect","getOutlet$1","primarySegmentGroup","routes_2","filter","outlet","validateConfig","validateNode","Array","isArray","loadChildren","exp","findNode","expected","_a","cc","findPath","collected","cloned","createEmptyState","rootComponent","snapshot","createEmptyStateSnapshot","emptyUrl","BehaviorSubject","emptyParams","emptyData","emptyQueryParams","fragment","activated","ActivatedRoute","RouterState","TreeNode","ActivatedRouteSnapshot","RouterStateSnapshot","inheritedParamsDataResolve","pathToRoot","pathFromRoot","inhertingStartingFrom","parent_1","routeConfig","reduce","curr","resolve","_resolvedData","setRouterStateSnapshot","state","node","_routerState","serializeNode","advanceActivatedRoute","queryParams","_futureSnapshot","url","createRouterState","prevState","createNode","_root","equalRouteSnapshots","createOrReuseChildren","createActivatedRoute","_routeConfig","createUrlTree","commands","tree","normalizedCommands","normalizeCommands","validateCommands","navigateToRoot","startingPosition","findStartingPosition","processChildren","updateSegmentGroupChildren","index","updateSegmentGroup","n","isAbsolute","isMatrixParams","outlets","command","segmentPath","oldSegmentGroup","newSegmentGroup","stringify","replaceSegment","oldSegment","newSegment","outletName","normalizedChange","NormalizedNavigationCommands","numberOfDoubleDots","_loop_1","r_1","name","Position","_lastPathIndex","_urlSegment","modifier","createPositionApplyingDoubleDots","group","g","ci","dd","parent","getPath","getOutlets","_b","startIndex","prefixedWith","slicedCommands","commandIndex","pathIndex","createNewSegmentGroup","outlets_1","currentCommandIndex","currentPathIndex","compare","paths","createNewSegmentChldren","recognize","rootComponentType","Recognizer","sortActivatedRouteSnapshots","sort","localeCompare","getChildConfig","_loadedConfig","match$1","NoMatch$1","posParameters","checkOutletNameUniqueness","names","routeWithSameOutletName","getSourceSegmentGroup","_sourceSegment","getPathIndexShift","_segmentIndexShift","split$1","containsEmptyPathMatchesWithNamedOutlets","createChildrenForEmptyPaths","containsEmptyPathMatches","addEmptyPathsToChildrenIfNeeded","emptyPathMatch","getOutlet$2","primarySegment","getData","getResolve","defaultErrorHandler","parentLoadedConfig","closestLoadedConfig","nodeChildrenAsMap","getOutlet","outletMap","_outlets","componentName","toBool","provideLocationStrategy","platformLocationStrategy","baseHref","useHash","HashLocationStrategy","PathLocationStrategy","provideForRootGuard","router","provideRoutes","provide","ANALYZE_FOR_ENTRY_COMPONENTS","multi","useValue","ROUTES","setupRouter","ref","urlSerializer","location","loader","compiler","opts","Router","errorHandler","enableTracing","events","e","constructor","groupEnd","rootRoute","routerState","initialRouterNavigation","preloader","resetRootComponentType","componentTypes","setUpPreloading","initialNavigation","setUpLocationChangeListener","provideRouterInitializer","APP_BOOTSTRAP_LISTENER","useFactory","deps","ApplicationRef","RouterPreloader","ROUTER_CONFIGURATION","d","__","message","stack","OpaqueToken","LoadedRouterConfig","factoryResolver","RouterConfigLoader","load","parentInjector","loadModuleFactory","componentFactoryResolver","offlineMode_1","Compiler","mergeMap","t","compileModuleAsync","DefaultUrlSerializer","serialize","defineProperty","enumerable","configurable","UrlSerializer","parse","UrlParser","parseRootSegment","parseQueryParams","parseFragment","query","encodeURI","remaining","peekStartsWith","capture","parseChildren","parseSegments","parseParens","matrixParams","parseMatrixParams","parseQueryParam","decodeURI","parseParam","valueMatch","allowPrimary","indexOf","substr","allowRedirects","expanded$","expandSegmentGroup","urlTrees$","rootSegmentGroup","_catch","noMatchError","mapped$","rootCandidate","expandChildren","expandSegment","routes$","processedRoutes$","expandSegmentAgainstRoute","concattedProcessedRoutes$","first$","EmptyError","matchSegmentAgainstRoute","expandSegmentAgainstRouteUsingRedirect","expandWildCardWithParamsAgainstRouteUsingRedirect","expandRegularSegmentAgainstRouteUsingRedirect","newSegments","rawSegmentGroup","consumedSegments_1","rawSlicedSegments_1","childConfig$","routerConfig","childInjector","childConfig","cs","shouldLoad","Tree","firstChild","siblings","__extends$1","futureSnapshot","urlSegment","lastPathIndex","_resolve","processSegmentGroup","freeze","rootNode","routeState","inheriteParamsAndData","routeNode","processSegment","config_1","processSegmentAgainstRoute","rawSegment","snapshot_1","rawSlicedSegments","RouterOutletMap","registerOutlet","removeOutlet","NavigationStart","NavigationEnd","urlAfterRedirects","NavigationCancel","reason","NavigationError","RoutesRecognized","navigationId","navigated","resetConfig","routerEvents","Subject","currentUrlTree","currentRouterState","navigateByUrl","replaceUrl","locationSubscription","Zone","wrap","scheduleNavigation","skipLocationChange","serializeUrl","dispose","unsubscribe","relativeTo","preserveQueryParams","preserveFragment","q","f","extras","navigate","parseUrl","isActive","then","runNavigate","shouldPreventPushState","shouldReplaceUrl","go","resolvePromise","rejectPromise","navigationIsSuccessful","preActivation","appliedUrl","storedState","storedUrl","redirectsApplied$","snapshot$","u","emitRecognzied$","newRouterStateSnapshot","routerState$","routerStateSnapshot","preactivation$","newState","PreActivation","traverse","preactivation2$","checkGuards","resolveData$","shouldActivate","resolveData","isCurrentPathEqualTo","replaceState","ActivateRoutes","activate","ee","CanActivate","CanDeactivate","future","checks","parentOutletMap","futureRoot","currRoot","traverseChildRoutes","checks$","runningChecks$","runCanActivateChild","runCanActivate","s2","runCanDeactivate","mergedChecks$","concatMap","runResolve","futureNode","currNode","futurePath","prevChildren","traverseRoutes","deactiveRouteAndItsChildren","isActivated","canActivate","getToken","canActivateChildGuards","reverse","extractCanActivateChild","guards","canActivateChild","canDeactivate","canDeactivate$","resolveNode","resolvedData","resolver","token","futureState","currState","activateChildRoutes","activateRoutes","placeComponentIntoOutlet","resolved","loadedFactoryResolver","loadedInjector","ComponentFactoryResolver","ReflectiveInjector","childOutletMap","deactivate","RouterLink","locationStrategy","set","onClick","button","ctrlKey","metaKey","decorators","args","ctorParameters","LocationStrategy","propDecorators","routerLink","HostListener","RouterLinkWithHref","subscription","updateTargetUrlAndHref","href","prepareExternalUrl","routerLinkOptions","HostBinding","RouterLinkActive","element","renderer","classes","routerLinkActiveOptions","ngAfterContentInit","links","linksWithHrefs","hasActiveLink","setElementClass","isLinkActive","link","some","Renderer","ContentChildren","descendants","routerLinkActive","RouterOutlet","activateEvents","deactivateEvents","instance","_activatedRoute","activatedRoute","loadedResolver","resolveComponentFactory","inj","fromResolvedProviders","createComponent","changeDetectorRef","detectChanges","ViewContainerRef","Attribute","PreloadingStrategy","PreloadAllModules","preload","NoPreloading","moduleLoader","preloadingStrategy","navigations","processRoutes","preloadConfig","loaded","NgModuleFactoryLoader","Injector","ROUTER_DIRECTIVES","ROUTER_FORROOT_GUARD","ROUTER_PROVIDERS","Location","useClass","SystemJsNgModuleLoader","ngModule","Optional","SkipSelf","PlatformLocation","Inject","APP_BASE_HREF","useExisting","forChild","__router_private__","144","Subject_1","ObjectUnsubscribedError_1","_value","getValue","_subscribe","subscriber","closed","hasError","thrownError","ObjectUnsubscribedError","145","Subscriber_1","InnerSubscriber","outerValue","outerIndex","_next","notifyNext","_error","notifyError","_complete","notifyComplete","Subscriber","146","Observable_1","Notification","kind","exception","hasValue","observe","observer","complete","do","accept","nextOrObserver","toObservable","throw","empty","createNext","undefinedValueNotification","createError","err","createComplete","completeNotification","57","OuterSubscriber","innerValue","innerIndex","innerSub","destination","149","ScalarObservable_1","EmptyObservable_1","ArrayLikeObservable","arrayLike","scheduler","_isScalar","EmptyObservable","ScalarObservable","dispatch","schedule","86","isScheduler_1","ArrayObservable","array","isScheduler","pop","len","count","87","arg","150","isArray_1","isPromise_1","PromiseObservable_1","IteratorObservable_1","ArrayObservable_1","ArrayLikeObservable_1","iterator_1","observeOn_1","observable_1","isArrayLike","x","FromObservable","ish","$$observable","isPromise","PromiseObservable","$$iterator","IteratorObservable","TypeError","ObserveOnSubscriber","151","getIterator","StringIterator","ArrayIterator","toLength","o","isNaN","numberIsFinite","sign","Math","floor","abs","maxSafeInteger","root_1","isFinite","valueAsNumber","iterator","done","charAt","arr","pow","89","152","FromObservable_1","153","154","operator","CatchOperator","caught","lift","OuterSubscriber_1","subscribeToResult_1","source","CatchSubscriber","isStopped","subscribeToResult","155","mergeAll_1","MergeAllOperator","156","project","resultSelector","mergeMap_1","MergeMapOperator","157","predicate","thisArg","EveryOperator","EverySubscriber","everyValueMatch","158","FilterOperator","FilterSubscriber","159","defaultValue","FirstOperator","EmptyError_1","FirstSubscriber","hasCompleted","_tryPredicate","_emit","_tryResultSelector","_emitFinal","160","LastOperator","LastSubscriber","lastValue","161","MapOperator","MapSubscriber","91","concurrent","Number","POSITIVE_INFINITY","MergeAllSubscriber","buffer","active","observable","shift","92","MergeMapSubscriber","_tryNext","_innerSub","_notifyResultSelector","162","observeOn","delay","ObserveOnOperator","Notification_1","notification","scheduleMessage","ObserveOnMessage","163","accumulator","seed","ReduceOperator","ReduceSubscriber","acc","hasSeed","_tryReduce","59","Symbol","for","Set","Map","getOwnPropertyNames","62","96","167","64","outerSubscriber","InnerSubscriber_1","setTimeout","item"],"mappings":"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","file":"main.8180ef8b31c42df2d539.bundle.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 322:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t/// <reference path=\"../lib/vs/index.d.ts\" />\r\n\t__export(__webpack_require__(43));\r\n\t__export(__webpack_require__(55));\r\n\n\n/***/ },\n\n/***/ 55:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\tvar Vis = __webpack_require__(83);\r\n\tvar VisNetwork = (function (_super) {\r\n\t    __extends(VisNetwork, _super);\r\n\t    function VisNetwork() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    return VisNetwork;\r\n\t}(Vis.Network));\r\n\texports.VisNetwork = VisNetwork;\r\n\tvar VisNodes = (function (_super) {\r\n\t    __extends(VisNodes, _super);\r\n\t    function VisNodes(data, options) {\r\n\t        _super.call(this, data, options);\r\n\t    }\r\n\t    VisNodes.prototype.getLength = function () {\r\n\t        return this.length;\r\n\t    };\r\n\t    VisNodes.prototype.add = function (data, senderId) {\r\n\t        return _super.prototype.add.call(this, data, senderId);\r\n\t    };\r\n\t    VisNodes.prototype.clear = function (senderId) {\r\n\t        return _super.prototype.clear.call(this, senderId);\r\n\t    };\r\n\t    VisNodes.prototype.distinct = function (field) {\r\n\t        return _super.prototype.distinct.call(this, field);\r\n\t    };\r\n\t    VisNodes.prototype.flush = function () {\r\n\t        _super.prototype.flush.call(this);\r\n\t    };\r\n\t    VisNodes.prototype.forEach = function (callback, options) {\r\n\t        _super.prototype.forEach.call(this, callback, options);\r\n\t    };\r\n\t    VisNodes.prototype.getAll = function (options) {\r\n\t        return _super.prototype.get.call(this, options);\r\n\t    };\r\n\t    VisNodes.prototype.getById = function (id, options) {\r\n\t        return _super.prototype.get.call(this, id, options);\r\n\t    };\r\n\t    VisNodes.prototype.getByIds = function (ids, options) {\r\n\t        return _super.prototype.get.call(this, ids, options);\r\n\t    };\r\n\t    VisNodes.prototype.getDataSet = function () {\r\n\t        return _super.prototype.getDataSet.call(this);\r\n\t    };\r\n\t    VisNodes.prototype.getIds = function (options) {\r\n\t        return _super.prototype.getIds.call(this, options);\r\n\t    };\r\n\t    VisNodes.prototype.map = function (callback, options) {\r\n\t        return _super.prototype.map.call(this, callback, options);\r\n\t    };\r\n\t    VisNodes.prototype.max = function (field) {\r\n\t        return _super.prototype.max.call(this, field);\r\n\t    };\r\n\t    VisNodes.prototype.min = function (field) {\r\n\t        return _super.prototype.min.call(this, field);\r\n\t    };\r\n\t    VisNodes.prototype.on = function (event, callback) {\r\n\t        _super.prototype.on.call(this, event, callback);\r\n\t    };\r\n\t    VisNodes.prototype.off = function (event, callback) {\r\n\t        _super.prototype.off.call(this, event, callback);\r\n\t    };\r\n\t    VisNodes.prototype.removeItems = function (ids, senderId) {\r\n\t        return _super.prototype.remove.call(this, ids, senderId);\r\n\t    };\r\n\t    VisNodes.prototype.setOptions = function (options) {\r\n\t        _super.prototype.setOptions.call(this, options);\r\n\t    };\r\n\t    VisNodes.prototype.update = function (data, senderId) {\r\n\t        return _super.prototype.update.call(this, data, senderId);\r\n\t    };\r\n\t    return VisNodes;\r\n\t}(Vis.DataSet));\r\n\texports.VisNodes = VisNodes;\r\n\tvar VisEdges = (function (_super) {\r\n\t    __extends(VisEdges, _super);\r\n\t    function VisEdges(data, options) {\r\n\t        _super.call(this, data, options);\r\n\t    }\r\n\t    VisEdges.prototype.getLength = function () {\r\n\t        return this.length;\r\n\t    };\r\n\t    VisEdges.prototype.add = function (data, senderId) {\r\n\t        return _super.prototype.add.call(this, data, senderId);\r\n\t    };\r\n\t    VisEdges.prototype.clear = function (senderId) {\r\n\t        return _super.prototype.clear.call(this, senderId);\r\n\t    };\r\n\t    VisEdges.prototype.distinct = function (field) {\r\n\t        return _super.prototype.distinct.call(this, field);\r\n\t    };\r\n\t    VisEdges.prototype.flush = function () {\r\n\t        _super.prototype.flush.call(this);\r\n\t    };\r\n\t    VisEdges.prototype.forEach = function (callback, options) {\r\n\t        _super.prototype.forEach.call(this, callback, options);\r\n\t    };\r\n\t    VisEdges.prototype.getAll = function (options) {\r\n\t        return _super.prototype.get.call(this, options);\r\n\t    };\r\n\t    VisEdges.prototype.getById = function (id, options) {\r\n\t        return _super.prototype.get.call(this, id, options);\r\n\t    };\r\n\t    VisEdges.prototype.getByIds = function (ids, options) {\r\n\t        return _super.prototype.get.call(this, ids, options);\r\n\t    };\r\n\t    VisEdges.prototype.getDataSet = function () {\r\n\t        return _super.prototype.getDataSet.call(this);\r\n\t    };\r\n\t    VisEdges.prototype.getIds = function (options) {\r\n\t        return _super.prototype.getIds.call(this, options);\r\n\t    };\r\n\t    VisEdges.prototype.map = function (callback, options) {\r\n\t        return _super.prototype.map.call(this, callback, options);\r\n\t    };\r\n\t    VisEdges.prototype.max = function (field) {\r\n\t        return _super.prototype.max.call(this, field);\r\n\t    };\r\n\t    VisEdges.prototype.min = function (field) {\r\n\t        return _super.prototype.min.call(this, field);\r\n\t    };\r\n\t    VisEdges.prototype.on = function (event, callback) {\r\n\t        _super.prototype.on.call(this, event, callback);\r\n\t    };\r\n\t    VisEdges.prototype.off = function (event, callback) {\r\n\t        _super.prototype.off.call(this, event, callback);\r\n\t    };\r\n\t    VisEdges.prototype.removeItems = function (ids, senderId) {\r\n\t        return _super.prototype.remove.call(this, ids, senderId);\r\n\t    };\r\n\t    VisEdges.prototype.setOptions = function (options) {\r\n\t        _super.prototype.setOptions.call(this, options);\r\n\t    };\r\n\t    VisEdges.prototype.update = function (data, senderId) {\r\n\t        return _super.prototype.update.call(this, data, senderId);\r\n\t    };\r\n\t    return VisEdges;\r\n\t}(Vis.DataSet));\r\n\texports.VisEdges = VisEdges;\r\n\t__export(__webpack_require__(323));\r\n\t__export(__webpack_require__(134));\r\n\n\n/***/ },\n\n/***/ 323:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar vis_network_service_1 = __webpack_require__(134);\r\n\t/**\r\n\t * Use this directive with a div container to show network data.\r\n\t *\r\n\t * @export\r\n\t * @class VisNetworkDirective\r\n\t * @implements {OnInit}\r\n\t * @implements {OnDestroy}\r\n\t * @implements {OnChanges}\r\n\t */\r\n\tvar VisNetworkDirective = (function () {\r\n\t    /**\r\n\t     * Creates an instance of VisNetworkDirective.\r\n\t     *\r\n\t     * @param {ElementRef} elementRef The HTML element reference.\r\n\t     * @param {VisNetworkService} visNetworkService The VisNetworkService.\r\n\t     *\r\n\t     * @memberOf VisNetworkDirective\r\n\t     */\r\n\t    function VisNetworkDirective(elementRef, visNetworkService) {\r\n\t        this.elementRef = elementRef;\r\n\t        this.visNetworkService = visNetworkService;\r\n\t        /**\r\n\t         * This event will be raised when the network is initialized.\r\n\t         * At this point of time the network is successfully registered\r\n\t         * with the VisNetworkService and you can register to events.\r\n\t         * The event data is the name of the network as a string.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkDirective\r\n\t         */\r\n\t        this.initialized = new core_1.EventEmitter();\r\n\t        this._isInitialized = false;\r\n\t        this._visNetworkContainer = elementRef.nativeElement;\r\n\t    }\r\n\t    /**\r\n\t     * Create the network when at least visNetwork and visNetworkData\r\n\t     * are defined.\r\n\t     *\r\n\t     * @memberOf VisNetworkDirective\r\n\t     */\r\n\t    VisNetworkDirective.prototype.ngOnInit = function () {\r\n\t        if (!this._isInitialized && this.visNetwork && this.visNetworkData) {\r\n\t            this.createNetwork();\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Update the network data or options on reference changes to\r\n\t     * the visNetworkData or visNetworkOptions properties.\r\n\t     *\r\n\t     * @param {{[propName: string]: SimpleChange}} changes\r\n\t     *\r\n\t     * @memberOf VisNetworkDirective\r\n\t     */\r\n\t    VisNetworkDirective.prototype.ngOnChanges = function (changes) {\r\n\t        if (!this._isInitialized && this.visNetwork && this.visNetworkData) {\r\n\t            this.createNetwork();\r\n\t        }\r\n\t        for (var propertyName in changes) {\r\n\t            if (changes.hasOwnProperty(propertyName)) {\r\n\t                var change = changes[propertyName];\r\n\t                if (!change.isFirstChange()) {\r\n\t                    if (propertyName === 'visNetworkData') {\r\n\t                        this.visNetworkService.setData(this.visNetwork, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                    if (propertyName === 'visNetworkOptions') {\r\n\t                        this.visNetworkService.setOptions(this.visNetwork, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Calls the destroy function for this network instance.\r\n\t     *\r\n\t     *\r\n\t     * @memberOf VisNetworkDirective\r\n\t     */\r\n\t    VisNetworkDirective.prototype.ngOnDestroy = function () {\r\n\t        this._isInitialized = false;\r\n\t        this.visNetworkService.destroy(this.visNetwork);\r\n\t    };\r\n\t    VisNetworkDirective.prototype.createNetwork = function () {\r\n\t        this.visNetworkService.create(this.visNetwork, this._visNetworkContainer, this.visNetworkData, this.visNetworkOptions);\r\n\t        this._isInitialized = true;\r\n\t        this.initialized.emit(this.visNetwork);\r\n\t    };\r\n\t    __decorate([\r\n\t        core_1.Input('visNetwork'), \r\n\t        __metadata('design:type', String)\r\n\t    ], VisNetworkDirective.prototype, \"visNetwork\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', Object)\r\n\t    ], VisNetworkDirective.prototype, \"visNetworkData\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', Object)\r\n\t    ], VisNetworkDirective.prototype, \"visNetworkOptions\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Output(), \r\n\t        __metadata('design:type', core_1.EventEmitter)\r\n\t    ], VisNetworkDirective.prototype, \"initialized\", void 0);\r\n\t    VisNetworkDirective = __decorate([\r\n\t        core_1.Directive({\r\n\t            selector: '[visNetwork]'\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [core_1.ElementRef, vis_network_service_1.VisNetworkService])\r\n\t    ], VisNetworkDirective);\r\n\t    return VisNetworkDirective;\r\n\t}());\r\n\texports.VisNetworkDirective = VisNetworkDirective;\r\n\n\n/***/ },\n\n/***/ 134:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar index_1 = __webpack_require__(55);\r\n\t/**\r\n\t * A service to create, manage and control VisNetwork instances.\r\n\t *\r\n\t * @export\r\n\t * @class VisNetworkService\r\n\t */\r\n\tvar VisNetworkService = (function () {\r\n\t    function VisNetworkService() {\r\n\t        /**\r\n\t         * Fired when the user clicks the mouse or taps on a touchscreen device.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.click = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user double clicks the mouse or double taps on a touchscreen device.\r\n\t         * Since a double click is in fact 2 clicks, 2 click events are fired, followed by a double click event.\r\n\t         * If you do not want to use the click events if a double click event is fired,\r\n\t         * just check the time between click events before processing them.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.doubleClick = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user click on the canvas with the right mouse button.\r\n\t         * The right mouse button does not select by default.\r\n\t         * You can use the method getNodeAt to select the node if you want.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.oncontext = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user clicks and holds the mouse or taps and holds on a touchscreen device.\r\n\t         * A click event is also fired in this case.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.hold = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired after drawing on the canvas has been completed.\r\n\t         * Can be used to draw on top of the network.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.release = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the selection has changed by user action.\r\n\t         * This means a node or edge has been selected, added to the selection or deselected.\r\n\t         * All select events are only triggered on click and hold.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.select = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a node has been selected by the user.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.selectNode = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a edge has been selected by the user.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.selectEdge = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a node (or nodes) has (or have) been deselected by the user.\r\n\t         * The previous selection is the list of nodes and edges that were selected before the last user event.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.deselectNode = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a edge (or edges) has (or have) been deselected by the user.\r\n\t         * The previous selection is the list of nodes and edges that were selected before the last user event.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.deselectEdge = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when starting a drag.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.dragStart = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when dragging node(s) or the view.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.dragging = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the drag has finished.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.dragEnd = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over a node.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.hoverNode = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired if the option interaction:{hover:true} is enabled and\r\n\t         * the mouse moved away from a node it was hovering over before.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.blurNode = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over an edge.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.hoverEdge = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired if the option interaction:{hover:true} is enabled and\r\n\t         * the mouse moved away from an edge it was hovering over before.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.blurEdge = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user zooms in or out.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.zoom = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the popup (tooltip) is shown.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.showPopup = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the popup (tooltip) is hidden.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.hidePopup = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when stabilization starts.\r\n\t         * This is also the case when you drag a node and the physics\r\n\t         * simulation restarts to stabilize again.\r\n\t         * Stabilization does not neccesarily imply 'without showing'.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.startStabilizing = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a multiple of the updateInterval number of iterations is reached.\r\n\t         * This only occurs in the 'hidden' stabilization.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.stabilizationProgress = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the 'hidden' stabilization finishes.\r\n\t         * This does not necessarily mean the network is stabilized;\r\n\t         * it could also mean that the amount of iterations defined in the options has been reached.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.stabilizationIterationsDone = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the 'hidden' stabilization finishes.\r\n\t         * This does not necessarily mean the network is stabilized;\r\n\t         * it could also mean that the amount of iterations defined in the options has been reached.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.stabilized = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the size of the canvas has been resized,\r\n\t         * either by a redraw call when the container div has changed in size,\r\n\t         * a setSize() call with new values or a setOptions() with new width and/or height values.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.resize = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired before the redrawing begins.\r\n\t         * The simulation step has completed at this point.\r\n\t         * Can be used to move custom elements before starting drawing the new frame.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.initRedraw = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired after the canvas has been cleared, scaled and translated to\r\n\t         * the viewing position but before all edges and nodes are drawn.\r\n\t         * Can be used to draw behind the network.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.beforeDrawing = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired after drawing on the canvas has been completed.\r\n\t         * Can be used to draw on top of the network.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.afterDrawing = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when an animation is finished.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.animationFinished = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a user changes any option in the configurator.\r\n\t         * The options object can be used with the setOptions method or stringified using JSON.stringify().\r\n\t         * You do not have to manually put the options into the network: this is done automatically.\r\n\t         * You can use the event to store user options in the database.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.configChange = new core_1.EventEmitter();\r\n\t        this._networks = {};\r\n\t    }\r\n\t    /**\r\n\t     * Creates a new network instance.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {HTMLElement} container The HTML element that contains the network view.\r\n\t     * @param {VisNetworkData} data The initial network nodes and edges.\r\n\t     * @param {VisNetworkOptions} [options] The network options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when a network with the same name already exists.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.create = function (visNetwork, container, data, options) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" already exists.\");\r\n\t        }\r\n\t        this._networks[visNetwork] = new index_1.VisNetwork(container, data, options);\r\n\t    };\r\n\t    /**\r\n\t     * Remove the network from the DOM and remove all Hammer bindings and references.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.destroy = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].destroy();\r\n\t            delete this._networks[visNetwork];\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Activates an event.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {string} eventName The event name.\r\n\t     * @param {boolean} preventDefault Stops the default behavior of the event.\r\n\t     * @returns {boolean} Returns true when the event was activated.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.on = function (visNetwork, eventName, preventDefault) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            var that_1 = this;\r\n\t            this._networks[visNetwork].on(eventName, function (params) {\r\n\t                var emitter = that_1[eventName];\r\n\t                if (emitter) {\r\n\t                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\r\n\t                }\r\n\t                if (preventDefault && params.event) {\r\n\t                    params.event.preventDefault();\r\n\t                }\r\n\t            });\r\n\t            return true;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * Deactivates an event.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {string} eventName The event name.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.off = function (visNetwork, eventName) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].off(eventName);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Activates an event listener only once.\r\n\t     * After it has taken place, the event listener will be removed.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {string} eventName The event name.\r\n\t     * @returns {boolean} Returns true when the event was activated.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.once = function (visNetwork, eventName) {\r\n\t        var _this = this;\r\n\t        if (this._networks[visNetwork]) {\r\n\t            var that_2 = this;\r\n\t            this._networks[visNetwork].on(eventName, function (params) {\r\n\t                var emitter = that_2[eventName];\r\n\t                if (emitter) {\r\n\t                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\r\n\t                    _this.off(visNetwork, eventName);\r\n\t                }\r\n\t            });\r\n\t            return true;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * Override all the data in the network.\r\n\t     * If stabilization is enabled in the physics module,\r\n\t     * the network will stabilize again.\r\n\t     * This method is also performed when first initializing the network.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisNetworkData} data The network data.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.setData = function (visNetwork, data) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].setData(data);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set the options.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisNetworkOptions} options The network options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.setOptions = function (visNetwork, options) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].setOptions(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Selects the nodes corresponding to the id's in the input array.\r\n\t     * This method unselects all other objects before selecting its own objects.\r\n\t     * Does not fire events.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {string[]} nodeIds The node ids that should be selected.\r\n\t     * @param {boolean} [highlightEdges] If highlightEdges is true or undefined,\r\n\t     *                                   the neighbouring edges will also be selected.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.selectNodes = function (visNetwork, nodeIds, highlightEdges) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].selectNodes(nodeIds, highlightEdges);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns an object with selected nodes and edges ids.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @returns {{ nodes: string[], edges: string[] }}\r\n\t     * The selected node and edge ids or undefined when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getSelection = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            return this._networks[visNetwork].getSelection();\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array of selected node ids.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @returns {string[]} The selected node ids or undefined when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getSelectedNodes = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            return this._networks[visNetwork].getSelectedNodes();\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array of selected edge ids.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @returns {string[]} The selected edge ids or undefined when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getSelectedEdges = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            return this._networks[visNetwork].getSelectedEdges();\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Unselect all objects.\r\n\t     * Does not fire events.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.unselectAll = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].unselectAll();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Zooms out so all nodes fit on the canvas.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisFitOptions} [options] Options to customize.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.fit = function (visNetwork, options) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].fit(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Redraw the network.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.redraw = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].redraw();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Programatically enable the edit mode.\r\n\t     * Similar effect to pressing the edit button.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.enableEditMode = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].enableEditMode();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Go into addEdge mode.\r\n\t     * The explaination from addNodeMode applies here as well.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.addEdgeMode = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].addEdgeMode();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Programatically disable the edit mode.\r\n\t     * Similar effect to pressing the close icon\r\n\t     * (small cross in the corner of the toolbar).\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.disableEditMode = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].disableEditMode();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Delete selected.\r\n\t     * Having edit mode or manipulation enabled is not required.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.deleteSelected = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].deleteSelected();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Makes a cluster.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {*} [options] The joinCondition function is presented with all nodes.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.cluster = function (visNetwork, options) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].cluster(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Opens the cluster, releases the contained nodes and edges,\r\n\t     * removing the cluster node and cluster edges.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {string} nodeId The node id that represents the cluster.\r\n\t     * @param {*} [options] Cluster options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.openCluster = function (visNetwork, nodeId, options) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            this._networks[visNetwork].openCluster(nodeId, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if the node whose ID has been supplied is a cluster.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {string} nodeId The associated node id.\r\n\t     * @returns {boolean} True if the node whose ID has been supplied is a cluster.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.isCluster = function (visNetwork, nodeId) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            return this._networks[visNetwork].isCluster(nodeId);\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * If you like the layout of your network and would like it to start in the same way next time,\r\n\t     * ask for the seed using this method and put it in the layout.randomSeed option.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @returns {number} The seed of the current network or -1 when the network is not defined.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getSeed = function (visNetwork) {\r\n\t        if (this._networks[visNetwork]) {\r\n\t            return this._networks[visNetwork].getSeed();\r\n\t        }\r\n\t        return -1;\r\n\t    };\r\n\t    VisNetworkService = __decorate([\r\n\t        core_1.Injectable(), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], VisNetworkService);\r\n\t    return VisNetworkService;\r\n\t}());\r\n\texports.VisNetworkService = VisNetworkService;\r\n\n\n/***/ },\n\n/***/ 43:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\tvar Vis = __webpack_require__(83);\r\n\tvar VisTimelineItems = (function (_super) {\r\n\t    __extends(VisTimelineItems, _super);\r\n\t    function VisTimelineItems(data, options) {\r\n\t        _super.call(this, data, options);\r\n\t    }\r\n\t    VisTimelineItems.prototype.getLength = function () {\r\n\t        return this.length;\r\n\t    };\r\n\t    VisTimelineItems.prototype.add = function (data, senderId) {\r\n\t        return _super.prototype.add.call(this, data, senderId);\r\n\t    };\r\n\t    VisTimelineItems.prototype.clear = function (senderId) {\r\n\t        return _super.prototype.clear.call(this, senderId);\r\n\t    };\r\n\t    VisTimelineItems.prototype.distinct = function (field) {\r\n\t        return _super.prototype.distinct.call(this, field);\r\n\t    };\r\n\t    VisTimelineItems.prototype.flush = function () {\r\n\t        _super.prototype.flush.call(this);\r\n\t    };\r\n\t    VisTimelineItems.prototype.forEach = function (callback, options) {\r\n\t        _super.prototype.forEach.call(this, callback, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getAll = function (options) {\r\n\t        return _super.prototype.get.call(this, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getById = function (id, options) {\r\n\t        return _super.prototype.get.call(this, id, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getByIds = function (ids, options) {\r\n\t        return _super.prototype.get.call(this, ids, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getDataSet = function () {\r\n\t        return _super.prototype.getDataSet.call(this);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getIds = function (options) {\r\n\t        return _super.prototype.getIds.call(this, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.map = function (callback, options) {\r\n\t        return _super.prototype.map.call(this, callback, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.max = function (field) {\r\n\t        return _super.prototype.max.call(this, field);\r\n\t    };\r\n\t    VisTimelineItems.prototype.min = function (field) {\r\n\t        return _super.prototype.min.call(this, field);\r\n\t    };\r\n\t    VisTimelineItems.prototype.on = function (event, callback) {\r\n\t        _super.prototype.on.call(this, event, callback);\r\n\t    };\r\n\t    VisTimelineItems.prototype.off = function (event, callback) {\r\n\t        _super.prototype.off.call(this, event, callback);\r\n\t    };\r\n\t    VisTimelineItems.prototype.removeItems = function (ids, senderId) {\r\n\t        return _super.prototype.remove.call(this, ids, senderId);\r\n\t    };\r\n\t    VisTimelineItems.prototype.setOptions = function (options) {\r\n\t        _super.prototype.setOptions.call(this, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.update = function (data, senderId) {\r\n\t        return _super.prototype.update.call(this, data, senderId);\r\n\t    };\r\n\t    return VisTimelineItems;\r\n\t}(Vis.DataSet));\r\n\texports.VisTimelineItems = VisTimelineItems;\r\n\tvar VisTimelineGroups = (function (_super) {\r\n\t    __extends(VisTimelineGroups, _super);\r\n\t    function VisTimelineGroups(data, options) {\r\n\t        _super.call(this, data, options);\r\n\t    }\r\n\t    VisTimelineGroups.prototype.getLength = function () {\r\n\t        return this.length;\r\n\t    };\r\n\t    VisTimelineGroups.prototype.add = function (data, senderId) {\r\n\t        return _super.prototype.add.call(this, data, senderId);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.clear = function (senderId) {\r\n\t        return _super.prototype.clear.call(this, senderId);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.distinct = function (field) {\r\n\t        return _super.prototype.distinct.call(this, field);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.flush = function () {\r\n\t        _super.prototype.flush.call(this);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.forEach = function (callback, options) {\r\n\t        _super.prototype.forEach.call(this, callback, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getAll = function (options) {\r\n\t        return _super.prototype.get.call(this, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getById = function (id, options) {\r\n\t        return _super.prototype.get.call(this, id, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getByIds = function (ids, options) {\r\n\t        return _super.prototype.get.call(this, ids, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getDataSet = function () {\r\n\t        return _super.prototype.getDataSet.call(this);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getIds = function (options) {\r\n\t        return _super.prototype.getIds.call(this, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.map = function (callback, options) {\r\n\t        return _super.prototype.map.call(this, callback, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.max = function (field) {\r\n\t        return _super.prototype.max.call(this, field);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.min = function (field) {\r\n\t        return _super.prototype.min.call(this, field);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.on = function (event, callback) {\r\n\t        _super.prototype.on.call(this, event, callback);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.off = function (event, callback) {\r\n\t        _super.prototype.off.call(this, event, callback);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.removeItems = function (ids, senderId) {\r\n\t        return _super.prototype.remove.call(this, ids, senderId);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.setOptions = function (options) {\r\n\t        _super.prototype.setOptions.call(this, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.update = function (data, senderId) {\r\n\t        return _super.prototype.update.call(this, data, senderId);\r\n\t    };\r\n\t    return VisTimelineGroups;\r\n\t}(Vis.DataSet));\r\n\texports.VisTimelineGroups = VisTimelineGroups;\r\n\tvar VisTimeline = (function (_super) {\r\n\t    __extends(VisTimeline, _super);\r\n\t    function VisTimeline() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    return VisTimeline;\r\n\t}(Vis.Timeline));\r\n\texports.VisTimeline = VisTimeline;\r\n\t__export(__webpack_require__(135));\r\n\t__export(__webpack_require__(324));\r\n\n\n/***/ },\n\n/***/ 324:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar vis_timeline_service_1 = __webpack_require__(135);\r\n\tvar index_1 = __webpack_require__(43);\r\n\t/**\r\n\t * Use this directive with a div container to show timeline data.\r\n\t *\r\n\t * @export\r\n\t * @class VisTimelineDirective\r\n\t * @implements {OnInit}\r\n\t * @implements {OnDestroy}\r\n\t * @implements {OnChanges}\r\n\t */\r\n\tvar VisTimelineDirective = (function () {\r\n\t    /**\r\n\t     * Creates an instance of VisTimelineDirective.\r\n\t     *\r\n\t     * @param {ElementRef} elementRef The HTML element reference.\r\n\t     * @param {VisTimelineService} visTimelineService The VisTimelineService.\r\n\t     *\r\n\t     * @memberOf VisTimelineDirective\r\n\t     */\r\n\t    function VisTimelineDirective(elementRef, visTimelineService) {\r\n\t        this.elementRef = elementRef;\r\n\t        this.visTimelineService = visTimelineService;\r\n\t        /**\r\n\t         * This event will be raised when the timline is initialized.\r\n\t         * At this point of time the timeline is successfully registered\r\n\t         * with the VisNetworkService and you can register to events.\r\n\t         * The event data is the name of the timeline as a string.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineDirective\r\n\t         */\r\n\t        this.initialized = new core_1.EventEmitter();\r\n\t        this._isInitialized = false;\r\n\t        this._visTimelineContainer = elementRef.nativeElement;\r\n\t    }\r\n\t    /**\r\n\t     * Create the timeline when at least visNetwork and visNetworkData\r\n\t     * are defined.\r\n\t     *\r\n\t     * @memberOf VisTimelineDirective\r\n\t     */\r\n\t    VisTimelineDirective.prototype.ngOnInit = function () {\r\n\t        if (!this._isInitialized && this.visTimeline && this.visTimelineItems) {\r\n\t            this.createTimeline();\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Update the timeline data, groups or options on reference changes to\r\n\t     * the visTimelineItems, visTimelineGroups or visTimelineOptions properties.\r\n\t     *\r\n\t     * @param {{[propName: string]: SimpleChange}} changes\r\n\t     *\r\n\t     * @memberOf VisTimelineDirective\r\n\t     */\r\n\t    VisTimelineDirective.prototype.ngOnChanges = function (changes) {\r\n\t        if (!this._isInitialized && this.visTimeline && this.visTimelineItems) {\r\n\t            this.createTimeline();\r\n\t        }\r\n\t        for (var propertyName in changes) {\r\n\t            if (changes.hasOwnProperty(propertyName)) {\r\n\t                var change = changes[propertyName];\r\n\t                if (!change.isFirstChange()) {\r\n\t                    if (propertyName === 'visTimelineItems') {\r\n\t                        this.visTimelineService.setItems(this.visTimeline, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                    if (propertyName === 'visTimelineOptions') {\r\n\t                        this.visTimelineService.setOptions(this.visTimeline, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                    if (propertyName === 'visTimelineGroups') {\r\n\t                        this.visTimelineService.setGroups(this.visTimeline, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Calls the destroy function for this timeline instance.\r\n\t     *\r\n\t     *\r\n\t     * @memberOf VisTimelineDirective\r\n\t     */\r\n\t    VisTimelineDirective.prototype.ngOnDestroy = function () {\r\n\t        this._isInitialized = false;\r\n\t        this.visTimelineService.destroy(this.visTimeline);\r\n\t    };\r\n\t    VisTimelineDirective.prototype.createTimeline = function () {\r\n\t        if (this.visTimelineGroups) {\r\n\t            this.visTimelineService.createWithItemsAndGroups(this.visTimeline, this._visTimelineContainer, this.visTimelineItems, this.visTimelineGroups, this.visTimelineOptions);\r\n\t        }\r\n\t        else {\r\n\t            this.visTimelineService.createWithItems(this.visTimeline, this._visTimelineContainer, this.visTimelineItems, this.visTimelineOptions);\r\n\t        }\r\n\t        this._isInitialized = true;\r\n\t        this.initialized.emit(this.visTimeline);\r\n\t    };\r\n\t    __decorate([\r\n\t        core_1.Input('visTimeline'), \r\n\t        __metadata('design:type', String)\r\n\t    ], VisTimelineDirective.prototype, \"visTimeline\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', index_1.VisTimelineItems)\r\n\t    ], VisTimelineDirective.prototype, \"visTimelineItems\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', index_1.VisTimelineGroups)\r\n\t    ], VisTimelineDirective.prototype, \"visTimelineGroups\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', Object)\r\n\t    ], VisTimelineDirective.prototype, \"visTimelineOptions\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Output(), \r\n\t        __metadata('design:type', core_1.EventEmitter)\r\n\t    ], VisTimelineDirective.prototype, \"initialized\", void 0);\r\n\t    VisTimelineDirective = __decorate([\r\n\t        core_1.Directive({\r\n\t            selector: '[visTimeline]'\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [core_1.ElementRef, vis_timeline_service_1.VisTimelineService])\r\n\t    ], VisTimelineDirective);\r\n\t    return VisTimelineDirective;\r\n\t}());\r\n\texports.VisTimelineDirective = VisTimelineDirective;\r\n\n\n/***/ },\n\n/***/ 135:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar index_1 = __webpack_require__(43);\r\n\t/**\r\n\t * A service to create, manage and control VisTimeline instances.\r\n\t *\r\n\t * @export\r\n\t * @class VisTimelineService\r\n\t */\r\n\tvar VisTimelineService = (function () {\r\n\t    function VisTimelineService() {\r\n\t        /**\r\n\t         * Fired when the current time bar redraws.\r\n\t         * The rate depends on the zoom level.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.currentTimeTick = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when clicked inside the Timeline.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.click = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when right-clicked inside the Timeline.\r\n\t         * Note that in order to prevent the context menu from showing up,\r\n\t         * default behavior of the event must be stopped.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.contextmenu = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when double clicked inside the Timeline.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.doubleClick = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * \tFired after the dragging of a group is finished.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.groupDragged = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired once after each graph redraw.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.changed = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired repeatedly when the timeline window is being changed.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.rangechange = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired once after the timeline window has been changed.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.rangechanged = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired after the user selects or deselects items by tapping or holding them.\r\n\t         * When a use taps an already selected item, the select event is fired again.\r\n\t         * Not fired when the method setSelectionis executed.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.select = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user moves the mouse over an item.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.itemover = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user moves the mouse out of an item.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.itemout = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired repeatedly when the user is dragging the custom time bar.\r\n\t         * Only available when the custom time bar is enabled.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.timechange = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired once after the user has dragged the custom time bar.\r\n\t         * Only available when the custom time bar is enabled.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.timechanged = new core_1.EventEmitter();\r\n\t        this._timelines = {};\r\n\t    }\r\n\t    /**\r\n\t     * Creates a new timeline instance.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {HTMLElement} container The HTML element that contains the timeline view.\r\n\t     * @param {VisTimelineItems} items The initial timeline items.\r\n\t     * @param {VisTimelineOptions} [options] The timeline options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline already exists.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.createWithItems = function (visTimeline, container, items, options) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            throw new Error(this.alreadyExistsError(visTimeline));\r\n\t        }\r\n\t        this._timelines[visTimeline] = new index_1.VisTimeline(container, items, options);\r\n\t    };\r\n\t    /**\r\n\t     * Creates a new timeline instance.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {HTMLElement} container The HTML element that contains the timeline view.\r\n\t     * @param {VisTimelineItems} items The initial timeline items.\r\n\t     * @param {VisTimelineGroups} groups The initial timeline groups.\r\n\t     * @param {VisTimelineOptions} [options] The timeline options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline already exists.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.createWithItemsAndGroups = function (visTimeline, container, items, groups, options) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            throw new Error(this.alreadyExistsError(visTimeline));\r\n\t        }\r\n\t        this._timelines[visTimeline] = new index_1.VisTimeline(container, items, groups, options);\r\n\t    };\r\n\t    /**\r\n\t     * Add new vertical bar representing a custom time that can be dragged by the user.\r\n\t     * The id is added as CSS class name of the custom time bar,\r\n\t     * allowing to style multiple time bars differently.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} time Parameter time can be a Date, Number, or String, and is new Date() by default.\r\n\t     * @param {VisId} [id] Parameter id can be Number or String and is undefined by default.\r\n\t     * @returns {VisId} The method returns id of the created bar.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.addCustomTime = function (visTimeline, time, id) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            return this._timelines[visTimeline].addCustomTime(time, id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Adjust the visible window such that it fits all items.\r\n\t     * See also function focus(id).\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineFitOptions} [options] Optional options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.fit = function (visTimeline, options) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].fit(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Adjust the visible window such that the selected item is centered on screen.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId} id The id of the item.\r\n\t     * @param {VisTimelineFitOptions} [options] Options options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.focusOnId = function (visTimeline, id, options) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].focus(id, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Adjust the visible window such that the selected items are centered on screen.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId[]} ids The item ids.\r\n\t     * @param {VisTimelineFitOptions} [options] Optional options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.focusOnIds = function (visTimeline, ids, options) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].focus(ids, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get the current time.\r\n\t     * Only applicable when option showCurrentTime is true.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {Date} The current time.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getCurrentTime = function (visTimeline) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            return this._timelines[visTimeline].getCurrentTime();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Retrieve the custom time from the custom time bar with given id.\r\n\t     * Id is undefined by default.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId} [id] The time bar id.\r\n\t     * @returns {Date} The custom time.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getCustomTime = function (visTimeline, id) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            return this._timelines[visTimeline].getCustomTime(id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns an Object with relevant properties from an event.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {Event} event The event.\r\n\t     * @returns {VisTimelineEventPropertiesResult} Properties of an event\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getEventProperties = function (visTimeline, event) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            return this._timelines[visTimeline].getEventProperties(event);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get the range of all the items as an object containing min: Date and max: Date.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {{ min: Date, max: Date }} The min and max dates.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getItemRange = function (visTimeline) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            return this._timelines[visTimeline].getItemRange();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get an array with the ids of the currently selected items.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {VisId[]} The currently selected items.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getSelection = function (visTimeline) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            return this._timelines[visTimeline].getSelection();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get an array with the ids of the currently visible items.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {VisId[]} The currently visible items.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getVisibleItems = function (visTimeline) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            return this._timelines[visTimeline].getVisibleItems();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get the current visible window.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {{ start: Date, end: Date }} Returns an object with properties start: Date and end: Date.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getWindow = function (visTimeline) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            return this._timelines[visTimeline].getWindow();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * \tMove the window such that given time is centered on screen.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} time Parameter time can be a Date, Number, or String.\r\n\t     * @param {VisTimelineFitOptions} [options] Optional options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.moveTo = function (visTimeline, time, options) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].moveTo(time, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Force a redraw of the Timeline.\r\n\t     * The size of all items will be recalculated.\r\n\t     * Can be useful to manually redraw when option autoResize=false and the window has been resized,\r\n\t     * or when the items CSS has been changed.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.redraw = function (visTimeline) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].redraw();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Remove vertical bars previously added to the timeline via addCustomTime method.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId} id Parameter id is the ID of the custom vertical bar returned by addCustomTime method.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.removeCustomTime = function (visTimeline, id) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].removeCustomTime(id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set a current time.\r\n\t     * This can be used for example to ensure that a client's time is synchronized\r\n\t     * with a shared server time.\r\n\t     * Only applicable when option showCurrentTime is true.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} time time can be a Date object, numeric timestamp, or ISO date string.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setCurrentTime = function (visTimeline, time) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setCurrentTime(time);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * \tAdjust the time of a custom time bar.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} time Parameter time can be a Date object, numeric timestamp, or ISO date string.\r\n\t     * @param {VisId} [id] Parameter id is the id of the custom time bar, and is undefined by default.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setCustomTime = function (visTimeline, time, id) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setCustomTime(time, id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Adjust the title attribute of a custom time bar.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {string} title Parameter title is the string to be set as title. Use empty string to hide the title completely.\r\n\t     * @param {VisId} [id] Parameter id is the id of the custom time bar, and is undefined by default.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setCustomTimeTitle = function (visTimeline, title, id) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setCustomTimeTitle(title, id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set both groups and items at once.\r\n\t     * Both properties are optional.\r\n\t     * This is a convenience method for individually calling both setItems(items) and setGroups(groups).\r\n\t     * Both items and groups can be an Array with Objects, a DataSet (offering 2 way data binding),\r\n\t     * or a DataView (offering 1 way data binding).\r\n\t     * For each of the groups, the items of the timeline are filtered on the property group,\r\n\t     * which must correspond with the id of the group.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {{ groups?: VisTimelineGroups; items?: VisTimelineItems }} data The new timline data.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setData = function (visTimeline, data) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setData(data);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set a data set with groups for the Timeline.\r\n\t     * For each of the groups, the items of the timeline are filtered on the property group,\r\n\t     * which must correspond with the id of the group.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineGroups} groups a DataSet (offering 2 way data binding)\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setGroups = function (visTimeline, groups) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setGroups(groups);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set a data set with items for the Timeline.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineItems} items can be an Array with Objects, a DataSet (offering 2 way data binding)\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setItems = function (visTimeline, items) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setItems(items);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set or update options.\r\n\t     * It is possible to change any option of the timeline at any time.\r\n\t     * You can for example switch orientation on the fly.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineOptions} options The new options of the timeline.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setOptions = function (visTimeline, options) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setOptions(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Select one item by its id.#\r\n\t     * The currently selected items will be unselected.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId} id The id of the item that should be selected.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setSelectionToId = function (visTimeline, id) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setSelection(id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Select multiple items by their id.\r\n\t     * The currently selected items will be unselected.\r\n\t     * To unselect all selected items, call `setSelection([])`.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId[]} ids The ids of the irems that should be selected.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setSelectionToIds = function (visTimeline, ids) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setSelection(ids);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set the current visible window.\r\n\t     *\r\n\t     * If the parameter value of start or end is null, the parameter will be left unchanged.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} start The parameters start can be a Date, Number, or String.\r\n\t     * @param {VisDate} end The parameters end can be a Date, Number, or String.\r\n\t     * @param {VisTimelineFitOptions} [options] Optional options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setWindow = function (visTimeline, start, end, options) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].setWindow(start, end, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Destroy the Timeline.\r\n\t     * The timeline is removed from memory.\r\n\t     * All DOM elements and event listeners are cleaned up.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.destroy = function (visTimeline) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].destroy();\r\n\t            delete this._timelines[visTimeline];\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Activates an event.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineEvents} eventName The event name.\r\n\t     * @param {boolean} preventDefault Stops the default behavior of the event.\r\n\t     * @returns {boolean} Returns true when the event was activated.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.on = function (visTimeline, eventName, preventDefault) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            var that_1 = this;\r\n\t            this._timelines[visTimeline].on(eventName, function (params) {\r\n\t                var emitter = that_1[eventName];\r\n\t                if (emitter) {\r\n\t                    emitter.emit(params ? [visTimeline].concat(params) : visTimeline);\r\n\t                }\r\n\t                if (preventDefault && params.event) {\r\n\t                    params.event.preventDefault();\r\n\t                }\r\n\t            });\r\n\t            return true;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * Deactivates an event.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineEvents} eventName The event name.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.off = function (visTimeline, eventName) {\r\n\t        if (this._timelines[visTimeline]) {\r\n\t            this._timelines[visTimeline].off(eventName, undefined);\r\n\t        }\r\n\t    };\r\n\t    VisTimelineService.prototype.doesNotExistError = function (visTimeline) {\r\n\t        return \"Timeline with id \" + visTimeline + \" does not exist.\";\r\n\t    };\r\n\t    VisTimelineService.prototype.alreadyExistsError = function (visTimeline) {\r\n\t        return \"Timeline with id \" + visTimeline + \" already exists.\";\r\n\t    };\r\n\t    VisTimelineService = __decorate([\r\n\t        core_1.Injectable(), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], VisTimelineService);\r\n\t    return VisTimelineService;\r\n\t}());\r\n\texports.VisTimelineService = VisTimelineService;\r\n\n\n/***/ },\n\n/***/ 138:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"container\\\">\\r\\n  <div class=\\\"header clearfix\\\">\\r\\n    <nav>\\r\\n      <ul class=\\\"nav nav-pills pull-right\\\">\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/home\\\">Home</a></li>\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/network\\\">Network</a></li>\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/timeline\\\">Timeline</a></li>\\r\\n      </ul>\\r\\n    </nav>\\r\\n    <h3 class=\\\"text-muted\\\">ng2-vis - an angular2 vis.js wrapper</h3>\\r\\n  </div>\\r\\n  <router-outlet></router-outlet>\\r\\n</div>\\r\\n\"\n\n/***/ },\n\n/***/ 325:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar DemoComponent = (function () {\r\n\t    function DemoComponent() {\r\n\t    }\r\n\t    DemoComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'example-app',\r\n\t            template: __webpack_require__(138),\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], DemoComponent);\r\n\t    return DemoComponent;\r\n\t}());\r\n\texports.DemoComponent = DemoComponent;\r\n\n\n/***/ },\n\n/***/ 326:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar forms_1 = __webpack_require__(84);\r\n\tvar platform_browser_1 = __webpack_require__(56);\r\n\tvar common_1 = __webpack_require__(44);\r\n\tvar router_1 = __webpack_require__(137);\r\n\tvar network_example_component_1 = __webpack_require__(328);\r\n\tvar timeline_example_component_1 = __webpack_require__(329);\r\n\tvar ng2_vis_1 = __webpack_require__(330);\r\n\tvar demo_component_1 = __webpack_require__(325);\r\n\tvar home_component_1 = __webpack_require__(327);\r\n\tvar VisDemoModule = (function () {\r\n\t    function VisDemoModule() {\r\n\t    }\r\n\t    VisDemoModule = __decorate([\r\n\t        core_1.NgModule({\r\n\t            declarations: [\r\n\t                demo_component_1.DemoComponent,\r\n\t                home_component_1.HomeComponent,\r\n\t                network_example_component_1.VisNetworkExampleComponent,\r\n\t                timeline_example_component_1.VisTimelineExampleComponent\r\n\t            ],\r\n\t            imports: [\r\n\t                platform_browser_1.BrowserModule,\r\n\t                forms_1.FormsModule,\r\n\t                ng2_vis_1.VisModule,\r\n\t                common_1.CommonModule,\r\n\t                router_1.RouterModule.forRoot([\r\n\t                    { path: 'timeline', component: timeline_example_component_1.VisTimelineExampleComponent },\r\n\t                    { path: '', redirectTo: '/home', pathMatch: 'full' },\r\n\t                    { path: 'home', component: home_component_1.HomeComponent },\r\n\t                    { path: 'network', component: network_example_component_1.VisNetworkExampleComponent },\r\n\t                    { path: '**', component: home_component_1.HomeComponent }\r\n\t                ])\r\n\t            ],\r\n\t            providers: [],\r\n\t            bootstrap: [demo_component_1.DemoComponent]\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], VisDemoModule);\r\n\t    return VisDemoModule;\r\n\t}());\r\n\texports.VisDemoModule = VisDemoModule;\r\n\n\n/***/ },\n\n/***/ 139:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"jumbotron\\\">\\r\\n  <h1>ng2-vis</h1>\\r\\n  <p class=\\\"lead\\\"><strong>Note:</strong> these examples mimic the ones for <code>vis</code>, but using <code>ng2-vis</code>.</p>\\r\\n  <p>\\r\\n    <a class=\\\"btn btn-lg btn-success\\\" href=\\\"https://github.com/seveves/ng2-vis\\\" role=\\\"button\\\">Get it on GitHub</a>\\r\\n    <a class=\\\"btn btn-lg btn-success\\\" href=\\\"http://visjs.org\\\" role=\\\"button\\\">Check out visjs.org</a>\\r\\n  </p>\\r\\n</div>\\r\\n<h2>Examples</h2>\\r\\n<div class=\\\"row\\\">\\r\\n  <div class=\\\"col-sm-6 col-md-4\\\">\\r\\n    <div class=\\\"thumbnail\\\">\\r\\n      <img src=\\\"http://visjs.org/images/network.png\\\" alt=\\\"Network Examples\\\">\\r\\n      <div class=\\\"caption\\\">\\r\\n        <h3>Network</h3>\\r\\n        <p>Display dynamic, automatically organised, customizable network views.</p>\\r\\n        <p><a routerLink=\\\"/network\\\" class=\\\"btn btn-primary\\\" role=\\\"button\\\">Examples</a></p>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n  <div class=\\\"col-sm-6 col-md-4\\\">\\r\\n    <div class=\\\"thumbnail\\\">\\r\\n      <img src=\\\"http://visjs.org/images/timeline.png\\\" alt=\\\"Timeline Examples\\\">\\r\\n      <div class=\\\"caption\\\">\\r\\n        <h3>Timeline</h3>\\r\\n        <p>Create a fully customizable, interactive timeline with items and ranges.</p>\\r\\n        <p><a routerLink=\\\"/timeline\\\" class=\\\"btn btn-primary\\\" role=\\\"button\\\">Examples</a></p>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n</div>\"\n\n/***/ },\n\n/***/ 327:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar HomeComponent = (function () {\r\n\t    function HomeComponent() {\r\n\t    }\r\n\t    HomeComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'home-example',\r\n\t            template: __webpack_require__(139),\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], HomeComponent);\r\n\t    return HomeComponent;\r\n\t}());\r\n\texports.HomeComponent = HomeComponent;\r\n\n\n/***/ },\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar platform_browser_dynamic_1 = __webpack_require__(85);\r\n\tvar demo_module_1 = __webpack_require__(326);\r\n\tplatform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(demo_module_1.VisDemoModule);\r\n\n\n/***/ },\n\n/***/ 140:\n/***/ function(module, exports) {\n\n\tmodule.exports = \".network-canvas {\\r\\n    width: 100%;\\r\\n    height: 400px;\\r\\n    border: 1px solid lightgray;\\r\\n}\"\n\n/***/ },\n\n/***/ 141:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<h2>Network</h2>\\r\\n<h3>Basic usage</h3>\\r\\n<div class=\\\"network-canvas\\\" [visNetwork]=\\\"visNetwork\\\" [visNetworkData]=\\\"visNetworkData\\\" [visNetworkOptions]=\\\"visNetworkOptions\\\" (initialized)=\\\"networkInitialized()\\\"></div>\\r\\n<button type=\\\"button\\\" class=\\\"btn btn-default\\\" (click)=\\\"addNode()\\\">Add node</button>\\r\\n<p><strong>Note:</strong> Open your dev tools to see the console output when the network receives click events.</p>\\r\\n\"\n\n/***/ },\n\n/***/ 328:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar network_1 = __webpack_require__(55);\r\n\tvar ExampleNetworkData = (function () {\r\n\t    function ExampleNetworkData() {\r\n\t    }\r\n\t    return ExampleNetworkData;\r\n\t}());\r\n\tvar VisNetworkExampleComponent = (function () {\r\n\t    function VisNetworkExampleComponent(visNetworkService) {\r\n\t        this.visNetworkService = visNetworkService;\r\n\t        this.visNetwork = 'networkId1';\r\n\t    }\r\n\t    VisNetworkExampleComponent.prototype.addNode = function () {\r\n\t        var newId = this.visNetworkData.nodes.getLength() + 1;\r\n\t        this.visNetworkData.nodes.add({ id: newId.toString(), label: 'Node ' + newId });\r\n\t        this.visNetworkService.fit(this.visNetwork);\r\n\t    };\r\n\t    VisNetworkExampleComponent.prototype.networkInitialized = function () {\r\n\t        var _this = this;\r\n\t        // now we can use the service to register on events\r\n\t        this.visNetworkService.on(this.visNetwork, 'click');\r\n\t        // open your console/dev tools to see the click params\r\n\t        this.visNetworkService.click\r\n\t            .subscribe(function (eventData) {\r\n\t            if (eventData[0] === _this.visNetwork) {\r\n\t                console.log(eventData[1]);\r\n\t            }\r\n\t        });\r\n\t    };\r\n\t    VisNetworkExampleComponent.prototype.ngOnInit = function () {\r\n\t        var nodes = new network_1.VisNodes([\r\n\t            { id: '1', label: 'Node 1' },\r\n\t            { id: '2', label: 'Node 2' },\r\n\t            { id: '3', label: 'Node 3' },\r\n\t            { id: '4', label: 'Node 4' },\r\n\t            { id: '5', label: 'Node 5', title: 'Title of Node 5' }]);\r\n\t        var edges = new network_1.VisEdges([\r\n\t            { from: '1', to: '3' },\r\n\t            { from: '1', to: '2' },\r\n\t            { from: '2', to: '4' },\r\n\t            { from: '2', to: '5' }]);\r\n\t        this.visNetworkData = {\r\n\t            nodes: nodes,\r\n\t            edges: edges\r\n\t        };\r\n\t        this.visNetworkOptions = {};\r\n\t    };\r\n\t    VisNetworkExampleComponent.prototype.ngOnDestroy = function () {\r\n\t        this.visNetworkService.off(this.visNetwork, 'click');\r\n\t    };\r\n\t    VisNetworkExampleComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'network-example',\r\n\t            template: __webpack_require__(141),\r\n\t            styles: [\r\n\t                __webpack_require__(140)\r\n\t            ]\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [network_1.VisNetworkService])\r\n\t    ], VisNetworkExampleComponent);\r\n\t    return VisNetworkExampleComponent;\r\n\t}());\r\n\texports.VisNetworkExampleComponent = VisNetworkExampleComponent;\r\n\n\n/***/ },\n\n/***/ 142:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"\"\n\n/***/ },\n\n/***/ 143:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<h2>Timeline</h2>\\r\\n<h3>Basic usage</h3>\\r\\n<div [visTimeline]=\\\"visTimeline\\\" [visTimelineItems]=\\\"visTimelineItems\\\" (initialized)=\\\"timelineInitialized()\\\"></div>\\r\\n<button type=\\\"button\\\" class=\\\"btn btn-default\\\" (click)=\\\"addItem()\\\">Add and focus</button>\\r\\n<p><strong>Note:</strong> Open your dev tools to see the console output when the timeline receives click events.</p>\"\n\n/***/ },\n\n/***/ 329:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar timeline_1 = __webpack_require__(43);\r\n\tvar VisTimelineExampleComponent = (function () {\r\n\t    function VisTimelineExampleComponent(visTimelineService) {\r\n\t        this.visTimelineService = visTimelineService;\r\n\t        this.visTimeline = 'timelineId1';\r\n\t    }\r\n\t    VisTimelineExampleComponent.prototype.timelineInitialized = function () {\r\n\t        var _this = this;\r\n\t        console.log('timeline initialized');\r\n\t        // now we can use the service to register on events\r\n\t        this.visTimelineService.on(this.visTimeline, 'click');\r\n\t        // open your console/dev tools to see the click params\r\n\t        this.visTimelineService.click\r\n\t            .subscribe(function (eventData) {\r\n\t            if (eventData[0] === _this.visTimeline) {\r\n\t                console.log(eventData[1]);\r\n\t            }\r\n\t        });\r\n\t    };\r\n\t    VisTimelineExampleComponent.prototype.addItem = function () {\r\n\t        var newLength = this.visTimelineItems.getLength() + 1;\r\n\t        this.visTimelineItems.add({ id: newLength, content: 'item ' + newLength, start: Date.now() });\r\n\t        this.visTimelineService.focusOnIds(this.visTimeline, [1, newLength]);\r\n\t    };\r\n\t    VisTimelineExampleComponent.prototype.ngOnInit = function () {\r\n\t        this.visTimelineItems = new timeline_1.VisTimelineItems([\r\n\t            { id: 1, content: 'item 1', start: '2016-04-20' },\r\n\t            { id: 2, content: 'item 2', start: '2016-04-14' },\r\n\t            { id: 3, content: 'item 3', start: '2016-04-18' },\r\n\t            { id: 4, content: 'item 4', start: '2016-04-16', end: '2016-04-19' },\r\n\t            { id: 5, content: 'item 5', start: '2016-04-25' },\r\n\t            { id: 6, content: 'item 6', start: '2016-04-27', type: 'point' }\r\n\t        ]);\r\n\t    };\r\n\t    VisTimelineExampleComponent.prototype.ngOnDestroy = function () {\r\n\t        this.visTimelineService.off(this.visTimeline, 'click');\r\n\t    };\r\n\t    VisTimelineExampleComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'timeline-example',\r\n\t            template: __webpack_require__(143),\r\n\t            styles: [\r\n\t                __webpack_require__(142)\r\n\t            ]\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [timeline_1.VisTimelineService])\r\n\t    ], VisTimelineExampleComponent);\r\n\t    return VisTimelineExampleComponent;\r\n\t}());\r\n\texports.VisTimelineExampleComponent = VisTimelineExampleComponent;\r\n\n\n/***/ },\n\n/***/ 330:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar index_1 = __webpack_require__(55);\r\n\tvar index_2 = __webpack_require__(43);\r\n\t__export(__webpack_require__(322));\r\n\tvar VisModule = (function () {\r\n\t    function VisModule() {\r\n\t    }\r\n\t    VisModule = __decorate([\r\n\t        core_1.NgModule({\r\n\t            exports: [index_1.VisNetworkDirective, index_2.VisTimelineDirective],\r\n\t            declarations: [index_1.VisNetworkDirective, index_2.VisTimelineDirective],\r\n\t            providers: [index_1.VisNetworkService, index_2.VisTimelineService]\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], VisModule);\r\n\t    return VisModule;\r\n\t}());\r\n\texports.VisModule = VisModule;\r\n\n\n/***/ },\n\n/***/ 137:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @license Angular v3.1.2\n\t * (c) 2010-2016 Google, Inc. https://angular.io/\n\t * License: MIT\n\t */\n\t(function (global, factory) {\n\t     true ? factory(exports, __webpack_require__(44), __webpack_require__(8), __webpack_require__(45), __webpack_require__(152), __webpack_require__(153), __webpack_require__(156), __webpack_require__(157), __webpack_require__(161), __webpack_require__(91), __webpack_require__(92), __webpack_require__(163), __webpack_require__(11), __webpack_require__(154), __webpack_require__(155), __webpack_require__(159), __webpack_require__(62), __webpack_require__(90), __webpack_require__(160), __webpack_require__(144), __webpack_require__(158)) :\n\t    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', 'rxjs/Subject', 'rxjs/observable/from', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/every', 'rxjs/operator/map', 'rxjs/operator/mergeAll', 'rxjs/operator/mergeMap', 'rxjs/operator/reduce', 'rxjs/Observable', 'rxjs/operator/catch', 'rxjs/operator/concatAll', 'rxjs/operator/first', 'rxjs/util/EmptyError', 'rxjs/observable/fromPromise', 'rxjs/operator/last', 'rxjs/BehaviorSubject', 'rxjs/operator/filter'], factory) :\n\t    (factory((global.ng = global.ng || {}, global.ng.router = global.ng.router || {}),global.ng.common,global.ng.core,global.Rx,global.Rx.Observable,global.Rx.Observable,global.rxjs_operator_concatMap,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype));\n\t}(this, function (exports,_angular_common,_angular_core,rxjs_Subject,rxjs_observable_from,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_every,rxjs_operator_map,rxjs_operator_mergeAll,rxjs_operator_mergeMap,rxjs_operator_reduce,rxjs_Observable,rxjs_operator_catch,rxjs_operator_concatAll,rxjs_operator_first,rxjs_util_EmptyError,rxjs_observable_fromPromise,l,rxjs_BehaviorSubject,rxjs_operator_filter) { 'use strict';\n\t\n\t    /**\n\t     * @license\n\t     * Copyright Google Inc. All Rights Reserved.\n\t     *\n\t     * Use of this source code is governed by an MIT-style license that can be\n\t     * found in the LICENSE file at https://angular.io/license\n\t     */\n\t    var __extends = (this && this.__extends) || function (d, b) {\n\t        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t    /**\n\t     * @whatItDoes Name of the primary outlet.\n\t     *\n\t     * @stable\n\t     */\n\t    var PRIMARY_OUTLET = 'primary';\n\t    var NavigationCancelingError = (function (_super) {\n\t        __extends(NavigationCancelingError, _super);\n\t        function NavigationCancelingError(message) {\n\t            _super.call(this, message);\n\t            this.message = message;\n\t            this.stack = (new Error(message)).stack;\n\t        }\n\t        NavigationCancelingError.prototype.toString = function () { return this.message; };\n\t        return NavigationCancelingError;\n\t    }(Error));\n\t\n\t    function shallowEqualArrays(a, b) {\n\t        if (a.length !== b.length)\n\t            return false;\n\t        for (var i = 0; i < a.length; ++i) {\n\t            if (!shallowEqual(a[i], b[i]))\n\t                return false;\n\t        }\n\t        return true;\n\t    }\n\t    function shallowEqual(a, b) {\n\t        var k1 = Object.keys(a);\n\t        var k2 = Object.keys(b);\n\t        if (k1.length != k2.length) {\n\t            return false;\n\t        }\n\t        var key;\n\t        for (var i = 0; i < k1.length; i++) {\n\t            key = k1[i];\n\t            if (a[key] !== b[key]) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    function flatten(a) {\n\t        var target = [];\n\t        for (var i = 0; i < a.length; ++i) {\n\t            for (var j = 0; j < a[i].length; ++j) {\n\t                target.push(a[i][j]);\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    function last(a) {\n\t        return a.length > 0 ? a[a.length - 1] : null;\n\t    }\n\t    function merge(m1, m2) {\n\t        var m = {};\n\t        for (var attr in m1) {\n\t            if (m1.hasOwnProperty(attr)) {\n\t                m[attr] = m1[attr];\n\t            }\n\t        }\n\t        for (var attr in m2) {\n\t            if (m2.hasOwnProperty(attr)) {\n\t                m[attr] = m2[attr];\n\t            }\n\t        }\n\t        return m;\n\t    }\n\t    function forEach(map, callback) {\n\t        for (var prop in map) {\n\t            if (map.hasOwnProperty(prop)) {\n\t                callback(map[prop], prop);\n\t            }\n\t        }\n\t    }\n\t    function waitForMap(obj, fn) {\n\t        var waitFor = [];\n\t        var res = {};\n\t        forEach(obj, function (a, k) {\n\t            if (k === PRIMARY_OUTLET) {\n\t                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n\t                    res[k] = _;\n\t                    return _;\n\t                }));\n\t            }\n\t        });\n\t        forEach(obj, function (a, k) {\n\t            if (k !== PRIMARY_OUTLET) {\n\t                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n\t                    res[k] = _;\n\t                    return _;\n\t                }));\n\t            }\n\t        });\n\t        if (waitFor.length > 0) {\n\t            var concatted$ = rxjs_operator_concatAll.concatAll.call(rxjs_observable_of.of.apply(void 0, waitFor));\n\t            var last$ = l.last.call(concatted$);\n\t            return rxjs_operator_map.map.call(last$, function () { return res; });\n\t        }\n\t        else {\n\t            return rxjs_observable_of.of(res);\n\t        }\n\t    }\n\t    function andObservables(observables) {\n\t        var merged$ = rxjs_operator_mergeAll.mergeAll.call(observables);\n\t        return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });\n\t    }\n\t    function wrapIntoObservable(value) {\n\t        if (value instanceof rxjs_Observable.Observable) {\n\t            return value;\n\t        }\n\t        else if (value instanceof Promise) {\n\t            return rxjs_observable_fromPromise.fromPromise(value);\n\t        }\n\t        else {\n\t            return rxjs_observable_of.of(value);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @experimental\n\t     */\n\t    var ROUTES = new _angular_core.OpaqueToken('ROUTES');\n\t    var LoadedRouterConfig = (function () {\n\t        function LoadedRouterConfig(routes, injector, factoryResolver) {\n\t            this.routes = routes;\n\t            this.injector = injector;\n\t            this.factoryResolver = factoryResolver;\n\t        }\n\t        return LoadedRouterConfig;\n\t    }());\n\t    var RouterConfigLoader = (function () {\n\t        function RouterConfigLoader(loader, compiler) {\n\t            this.loader = loader;\n\t            this.compiler = compiler;\n\t        }\n\t        RouterConfigLoader.prototype.load = function (parentInjector, loadChildren) {\n\t            return rxjs_operator_map.map.call(this.loadModuleFactory(loadChildren), function (r) {\n\t                var ref = r.create(parentInjector);\n\t                return new LoadedRouterConfig(flatten(ref.injector.get(ROUTES)), ref.injector, ref.componentFactoryResolver);\n\t            });\n\t        };\n\t        RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {\n\t            var _this = this;\n\t            if (typeof loadChildren === 'string') {\n\t                return rxjs_observable_fromPromise.fromPromise(this.loader.load(loadChildren));\n\t            }\n\t            else {\n\t                var offlineMode_1 = this.compiler instanceof _angular_core.Compiler;\n\t                return rxjs_operator_mergeMap.mergeMap.call(wrapIntoObservable(loadChildren()), function (t) { return offlineMode_1 ? rxjs_observable_of.of(t) : rxjs_observable_fromPromise.fromPromise(_this.compiler.compileModuleAsync(t)); });\n\t            }\n\t        };\n\t        return RouterConfigLoader;\n\t    }());\n\t\n\t    function createEmptyUrlTree() {\n\t        return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n\t    }\n\t    function containsTree(container, containee, exact) {\n\t        if (exact) {\n\t            return equalSegmentGroups(container.root, containee.root);\n\t        }\n\t        else {\n\t            return containsSegmentGroup(container.root, containee.root);\n\t        }\n\t    }\n\t    function equalSegmentGroups(container, containee) {\n\t        if (!equalPath(container.segments, containee.segments))\n\t            return false;\n\t        if (container.numberOfChildren !== containee.numberOfChildren)\n\t            return false;\n\t        for (var c in containee.children) {\n\t            if (!container.children[c])\n\t                return false;\n\t            if (!equalSegmentGroups(container.children[c], containee.children[c]))\n\t                return false;\n\t        }\n\t        return true;\n\t    }\n\t    function containsSegmentGroup(container, containee) {\n\t        return containsSegmentGroupHelper(container, containee, containee.segments);\n\t    }\n\t    function containsSegmentGroupHelper(container, containee, containeePaths) {\n\t        if (container.segments.length > containeePaths.length) {\n\t            var current = container.segments.slice(0, containeePaths.length);\n\t            if (!equalPath(current, containeePaths))\n\t                return false;\n\t            if (containee.hasChildren())\n\t                return false;\n\t            return true;\n\t        }\n\t        else if (container.segments.length === containeePaths.length) {\n\t            if (!equalPath(container.segments, containeePaths))\n\t                return false;\n\t            for (var c in containee.children) {\n\t                if (!container.children[c])\n\t                    return false;\n\t                if (!containsSegmentGroup(container.children[c], containee.children[c]))\n\t                    return false;\n\t            }\n\t            return true;\n\t        }\n\t        else {\n\t            var current = containeePaths.slice(0, container.segments.length);\n\t            var next = containeePaths.slice(container.segments.length);\n\t            if (!equalPath(container.segments, current))\n\t                return false;\n\t            if (!container.children[PRIMARY_OUTLET])\n\t                return false;\n\t            return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n\t        }\n\t    }\n\t    /**\n\t     * @whatItDoes Represents the parsed URL.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'template.html'})\n\t     * class MyComponent {\n\t     *   constructor(router: Router) {\n\t     *     const tree: UrlTree =\n\t     * router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n\t     *     const f = tree.fragment; // return 'fragment'\n\t     *     const q = tree.queryParams; // returns {debug: 'true'}\n\t     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n\t     *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n\t     *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n\t     *     g.children['support'].segments; // return 1 segment 'help'\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n\t     * serialized tree.\n\t     * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n\t     *\n\t     * @stable\n\t     */\n\t    var UrlTree = (function () {\n\t        /**\n\t         * @internal\n\t         */\n\t        function UrlTree(\n\t            /**\n\t            * The root segment group of the URL tree.\n\t             */\n\t            root,\n\t            /**\n\t             * The query params of the URL.\n\t             */\n\t            queryParams,\n\t            /**\n\t             * The fragment of the URL.\n\t             */\n\t            fragment) {\n\t            this.root = root;\n\t            this.queryParams = queryParams;\n\t            this.fragment = fragment;\n\t        }\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        UrlTree.prototype.toString = function () { return new DefaultUrlSerializer().serialize(this); };\n\t        return UrlTree;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents the parsed URL segment.\n\t     *\n\t     * See {@link UrlTree} for more information.\n\t     *\n\t     * @stable\n\t     */\n\t    var UrlSegmentGroup = (function () {\n\t        function UrlSegmentGroup(\n\t            /**\n\t             * The URL segments of this group. See {@link UrlSegment} for more information.\n\t             */\n\t            segments,\n\t            /**\n\t             * The list of children of this group.\n\t             */\n\t            children) {\n\t            var _this = this;\n\t            this.segments = segments;\n\t            this.children = children;\n\t            /**\n\t             * The parent node in the url tree.\n\t             */\n\t            this.parent = null;\n\t            forEach(children, function (v, k) { return v.parent = _this; });\n\t        }\n\t        /**\n\t         * Return true if the segment has child segments\n\t         */\n\t        UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };\n\t        Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\n\t            /**\n\t             * Returns the number of child sements.\n\t             */\n\t            get: function () { return Object.keys(this.children).length; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };\n\t        return UrlSegmentGroup;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents a single URL segment.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'template.html'})\n\t     * class MyComponent {\n\t     *   constructor(router: Router) {\n\t     *     const tree: UrlTree = router.parseUrl('/team;id=33');\n\t     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n\t     *     const s: UrlSegment[] = g.segments;\n\t     *     s[0].path; // returns 'team'\n\t     *     s[0].parameters; // returns {id: 33}\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * A UrlSegment is a part of a URL between the two slashes. It contains a path and\n\t     * the matrix parameters associated with the segment.\n\t     *\n\t     * @stable\n\t     */\n\t    var UrlSegment = (function () {\n\t        function UrlSegment(\n\t            /**\n\t             * The part part of a URL segment.\n\t             */\n\t            path,\n\t            /**\n\t             * The matrix parameters associated with a segment.\n\t             */\n\t            parameters) {\n\t            this.path = path;\n\t            this.parameters = parameters;\n\t        }\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        UrlSegment.prototype.toString = function () { return serializePath(this); };\n\t        return UrlSegment;\n\t    }());\n\t    function equalPath(a, b) {\n\t        if (a.length !== b.length)\n\t            return false;\n\t        for (var i = 0; i < a.length; ++i) {\n\t            if (a[i].path !== b[i].path)\n\t                return false;\n\t        }\n\t        return true;\n\t    }\n\t    function mapChildrenIntoArray(segment, fn) {\n\t        var res = [];\n\t        forEach(segment.children, function (child, childOutlet) {\n\t            if (childOutlet === PRIMARY_OUTLET) {\n\t                res = res.concat(fn(child, childOutlet));\n\t            }\n\t        });\n\t        forEach(segment.children, function (child, childOutlet) {\n\t            if (childOutlet !== PRIMARY_OUTLET) {\n\t                res = res.concat(fn(child, childOutlet));\n\t            }\n\t        });\n\t        return res;\n\t    }\n\t    /**\n\t     * @whatItDoes Serializes and deserializes a URL string into a URL tree.\n\t     *\n\t     * @description The url serialization strategy is customizable. You can\n\t     * make all URLs case insensitive by providing a custom UrlSerializer.\n\t     *\n\t     * See {@link DefaultUrlSerializer} for an example of a URL serializer.\n\t     *\n\t     * @stable\n\t     */\n\t    var UrlSerializer = (function () {\n\t        function UrlSerializer() {\n\t        }\n\t        return UrlSerializer;\n\t    }());\n\t    /**\n\t     * @whatItDoes A default implementation of the {@link UrlSerializer}.\n\t     *\n\t     * @description\n\t     *\n\t     * Example URLs:\n\t     *\n\t     * ```\n\t     * /inbox/33(popup:compose)\n\t     * /inbox/33;open=true/messages/44\n\t     * ```\n\t     *\n\t     * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n\t     * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n\t     * specify route specific parameters.\n\t     *\n\t     * @stable\n\t     */\n\t    var DefaultUrlSerializer = (function () {\n\t        function DefaultUrlSerializer() {\n\t        }\n\t        /**\n\t         * Parse a url into a {@link UrlTree}.\n\t         */\n\t        DefaultUrlSerializer.prototype.parse = function (url) {\n\t            var p = new UrlParser(url);\n\t            return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n\t        };\n\t        /**\n\t         * Converts a {@link UrlTree} into a url.\n\t         */\n\t        DefaultUrlSerializer.prototype.serialize = function (tree) {\n\t            var segment = \"/\" + serializeSegment(tree.root, true);\n\t            var query = serializeQueryParams(tree.queryParams);\n\t            var fragment = tree.fragment !== null && tree.fragment !== undefined ? \"#\" + encodeURI(tree.fragment) : '';\n\t            return \"\" + segment + query + fragment;\n\t        };\n\t        return DefaultUrlSerializer;\n\t    }());\n\t    function serializePaths(segment) {\n\t        return segment.segments.map(function (p) { return serializePath(p); }).join('/');\n\t    }\n\t    function serializeSegment(segment, root) {\n\t        if (segment.hasChildren() && root) {\n\t            var primary = segment.children[PRIMARY_OUTLET] ?\n\t                serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n\t                '';\n\t            var children_1 = [];\n\t            forEach(segment.children, function (v, k) {\n\t                if (k !== PRIMARY_OUTLET) {\n\t                    children_1.push(k + \":\" + serializeSegment(v, false));\n\t                }\n\t            });\n\t            if (children_1.length > 0) {\n\t                return primary + \"(\" + children_1.join('//') + \")\";\n\t            }\n\t            else {\n\t                return \"\" + primary;\n\t            }\n\t        }\n\t        else if (segment.hasChildren() && !root) {\n\t            var children = mapChildrenIntoArray(segment, function (v, k) {\n\t                if (k === PRIMARY_OUTLET) {\n\t                    return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n\t                }\n\t                else {\n\t                    return [(k + \":\" + serializeSegment(v, false))];\n\t                }\n\t            });\n\t            return serializePaths(segment) + \"/(\" + children.join('//') + \")\";\n\t        }\n\t        else {\n\t            return serializePaths(segment);\n\t        }\n\t    }\n\t    function encode(s) {\n\t        return encodeURIComponent(s);\n\t    }\n\t    function decode(s) {\n\t        return decodeURIComponent(s);\n\t    }\n\t    function serializePath(path) {\n\t        return \"\" + encode(path.path) + serializeParams(path.parameters);\n\t    }\n\t    function serializeParams(params) {\n\t        return pairs(params).map(function (p) { return (\";\" + encode(p.first) + \"=\" + encode(p.second)); }).join('');\n\t    }\n\t    function serializeQueryParams(params) {\n\t        var strs = pairs(params).map(function (p) { return (encode(p.first) + \"=\" + encode(p.second)); });\n\t        return strs.length > 0 ? \"?\" + strs.join(\"&\") : '';\n\t    }\n\t    var Pair = (function () {\n\t        function Pair(first, second) {\n\t            this.first = first;\n\t            this.second = second;\n\t        }\n\t        return Pair;\n\t    }());\n\t    function pairs(obj) {\n\t        var res = [];\n\t        for (var prop in obj) {\n\t            if (obj.hasOwnProperty(prop)) {\n\t                res.push(new Pair(prop, obj[prop]));\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    var SEGMENT_RE = /^[^\\/\\(\\)\\?;=&#]+/;\n\t    function matchSegments(str) {\n\t        SEGMENT_RE.lastIndex = 0;\n\t        var match = str.match(SEGMENT_RE);\n\t        return match ? match[0] : '';\n\t    }\n\t    var QUERY_PARAM_RE = /^[^=\\?&#]+/;\n\t    function matchQueryParams(str) {\n\t        QUERY_PARAM_RE.lastIndex = 0;\n\t        var match = str.match(SEGMENT_RE);\n\t        return match ? match[0] : '';\n\t    }\n\t    var QUERY_PARAM_VALUE_RE = /^[^\\?&#]+/;\n\t    function matchUrlQueryParamValue(str) {\n\t        QUERY_PARAM_VALUE_RE.lastIndex = 0;\n\t        var match = str.match(QUERY_PARAM_VALUE_RE);\n\t        return match ? match[0] : '';\n\t    }\n\t    var UrlParser = (function () {\n\t        function UrlParser(url) {\n\t            this.url = url;\n\t            this.remaining = url;\n\t        }\n\t        UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };\n\t        UrlParser.prototype.capture = function (str) {\n\t            if (!this.remaining.startsWith(str)) {\n\t                throw new Error(\"Expected \\\"\" + str + \"\\\".\");\n\t            }\n\t            this.remaining = this.remaining.substring(str.length);\n\t        };\n\t        UrlParser.prototype.parseRootSegment = function () {\n\t            if (this.remaining.startsWith('/')) {\n\t                this.capture('/');\n\t            }\n\t            if (this.remaining === '' || this.remaining.startsWith('?') || this.remaining.startsWith('#')) {\n\t                return new UrlSegmentGroup([], {});\n\t            }\n\t            else {\n\t                return new UrlSegmentGroup([], this.parseChildren());\n\t            }\n\t        };\n\t        UrlParser.prototype.parseChildren = function () {\n\t            if (this.remaining.length == 0) {\n\t                return {};\n\t            }\n\t            if (this.peekStartsWith('/')) {\n\t                this.capture('/');\n\t            }\n\t            var paths = [];\n\t            if (!this.peekStartsWith('(')) {\n\t                paths.push(this.parseSegments());\n\t            }\n\t            while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n\t                this.capture('/');\n\t                paths.push(this.parseSegments());\n\t            }\n\t            var children = {};\n\t            if (this.peekStartsWith('/(')) {\n\t                this.capture('/');\n\t                children = this.parseParens(true);\n\t            }\n\t            var res = {};\n\t            if (this.peekStartsWith('(')) {\n\t                res = this.parseParens(false);\n\t            }\n\t            if (paths.length > 0 || Object.keys(children).length > 0) {\n\t                res[PRIMARY_OUTLET] = new UrlSegmentGroup(paths, children);\n\t            }\n\t            return res;\n\t        };\n\t        UrlParser.prototype.parseSegments = function () {\n\t            var path = matchSegments(this.remaining);\n\t            if (path === '' && this.peekStartsWith(';')) {\n\t                throw new Error(\"Empty path url segment cannot have parameters: '\" + this.remaining + \"'.\");\n\t            }\n\t            this.capture(path);\n\t            var matrixParams = {};\n\t            if (this.peekStartsWith(';')) {\n\t                matrixParams = this.parseMatrixParams();\n\t            }\n\t            return new UrlSegment(decode(path), matrixParams);\n\t        };\n\t        UrlParser.prototype.parseQueryParams = function () {\n\t            var params = {};\n\t            if (this.peekStartsWith('?')) {\n\t                this.capture('?');\n\t                this.parseQueryParam(params);\n\t                while (this.remaining.length > 0 && this.peekStartsWith('&')) {\n\t                    this.capture('&');\n\t                    this.parseQueryParam(params);\n\t                }\n\t            }\n\t            return params;\n\t        };\n\t        UrlParser.prototype.parseFragment = function () {\n\t            if (this.peekStartsWith('#')) {\n\t                return decodeURI(this.remaining.substring(1));\n\t            }\n\t            else {\n\t                return null;\n\t            }\n\t        };\n\t        UrlParser.prototype.parseMatrixParams = function () {\n\t            var params = {};\n\t            while (this.remaining.length > 0 && this.peekStartsWith(';')) {\n\t                this.capture(';');\n\t                this.parseParam(params);\n\t            }\n\t            return params;\n\t        };\n\t        UrlParser.prototype.parseParam = function (params) {\n\t            var key = matchSegments(this.remaining);\n\t            if (!key) {\n\t                return;\n\t            }\n\t            this.capture(key);\n\t            var value = '';\n\t            if (this.peekStartsWith('=')) {\n\t                this.capture('=');\n\t                var valueMatch = matchSegments(this.remaining);\n\t                if (valueMatch) {\n\t                    value = valueMatch;\n\t                    this.capture(value);\n\t                }\n\t            }\n\t            params[decode(key)] = decode(value);\n\t        };\n\t        UrlParser.prototype.parseQueryParam = function (params) {\n\t            var key = matchQueryParams(this.remaining);\n\t            if (!key) {\n\t                return;\n\t            }\n\t            this.capture(key);\n\t            var value = '';\n\t            if (this.peekStartsWith('=')) {\n\t                this.capture('=');\n\t                var valueMatch = matchUrlQueryParamValue(this.remaining);\n\t                if (valueMatch) {\n\t                    value = valueMatch;\n\t                    this.capture(value);\n\t                }\n\t            }\n\t            params[decode(key)] = decode(value);\n\t        };\n\t        UrlParser.prototype.parseParens = function (allowPrimary) {\n\t            var segments = {};\n\t            this.capture('(');\n\t            while (!this.peekStartsWith(')') && this.remaining.length > 0) {\n\t                var path = matchSegments(this.remaining);\n\t                var next = this.remaining[path.length];\n\t                // if is is not one of these characters, then the segment was unescaped\n\t                // or the group was not closed\n\t                if (next !== '/' && next !== ')' && next !== ';') {\n\t                    throw new Error(\"Cannot parse url '\" + this.url + \"'\");\n\t                }\n\t                var outletName = void 0;\n\t                if (path.indexOf(':') > -1) {\n\t                    outletName = path.substr(0, path.indexOf(':'));\n\t                    this.capture(outletName);\n\t                    this.capture(':');\n\t                }\n\t                else if (allowPrimary) {\n\t                    outletName = PRIMARY_OUTLET;\n\t                }\n\t                var children = this.parseChildren();\n\t                segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n\t                    new UrlSegmentGroup([], children);\n\t                if (this.peekStartsWith('//')) {\n\t                    this.capture('//');\n\t                }\n\t            }\n\t            this.capture(')');\n\t            return segments;\n\t        };\n\t        return UrlParser;\n\t    }());\n\t\n\t    var NoMatch = (function () {\n\t        function NoMatch(segmentGroup) {\n\t            if (segmentGroup === void 0) { segmentGroup = null; }\n\t            this.segmentGroup = segmentGroup;\n\t        }\n\t        return NoMatch;\n\t    }());\n\t    var AbsoluteRedirect = (function () {\n\t        function AbsoluteRedirect(segments) {\n\t            this.segments = segments;\n\t        }\n\t        return AbsoluteRedirect;\n\t    }());\n\t    function noMatch(segmentGroup) {\n\t        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });\n\t    }\n\t    function absoluteRedirect(segments) {\n\t        return new rxjs_Observable.Observable(function (obs) { return obs.error(new AbsoluteRedirect(segments)); });\n\t    }\n\t    function canLoadFails(route) {\n\t        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NavigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\" + route.path + \"'\\\" returned false\")); });\n\t    }\n\t    function applyRedirects(injector, configLoader, urlTree, config) {\n\t        return new ApplyRedirects(injector, configLoader, urlTree, config).apply();\n\t    }\n\t    var ApplyRedirects = (function () {\n\t        function ApplyRedirects(injector, configLoader, urlTree, config) {\n\t            this.injector = injector;\n\t            this.configLoader = configLoader;\n\t            this.urlTree = urlTree;\n\t            this.config = config;\n\t            this.allowRedirects = true;\n\t        }\n\t        ApplyRedirects.prototype.apply = function () {\n\t            var _this = this;\n\t            var expanded$ = this.expandSegmentGroup(this.injector, this.config, this.urlTree.root, PRIMARY_OUTLET);\n\t            var urlTrees$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup); });\n\t            return rxjs_operator_catch._catch.call(urlTrees$, function (e) {\n\t                if (e instanceof AbsoluteRedirect) {\n\t                    // after an absolute redirect we do not apply any more redirects!\n\t                    _this.allowRedirects = false;\n\t                    var group = new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = new UrlSegmentGroup(e.segments, {}), _a));\n\t                    // we need to run matching, so we can fetch all lazy-loaded modules\n\t                    return _this.match(group);\n\t                }\n\t                else if (e instanceof NoMatch) {\n\t                    throw _this.noMatchError(e);\n\t                }\n\t                else {\n\t                    throw e;\n\t                }\n\t                var _a;\n\t            });\n\t        };\n\t        ApplyRedirects.prototype.match = function (segmentGroup) {\n\t            var _this = this;\n\t            var expanded$ = this.expandSegmentGroup(this.injector, this.config, segmentGroup, PRIMARY_OUTLET);\n\t            var mapped$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup); });\n\t            return rxjs_operator_catch._catch.call(mapped$, function (e) {\n\t                if (e instanceof NoMatch) {\n\t                    throw _this.noMatchError(e);\n\t                }\n\t                else {\n\t                    throw e;\n\t                }\n\t            });\n\t        };\n\t        ApplyRedirects.prototype.noMatchError = function (e) {\n\t            return new Error(\"Cannot match any routes. URL Segment: '\" + e.segmentGroup + \"'\");\n\t        };\n\t        ApplyRedirects.prototype.createUrlTree = function (rootCandidate) {\n\t            var root = rootCandidate.segments.length > 0 ?\n\t                new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\n\t                rootCandidate;\n\t            return new UrlTree(root, this.urlTree.queryParams, this.urlTree.fragment);\n\t            var _a;\n\t        };\n\t        ApplyRedirects.prototype.expandSegmentGroup = function (injector, routes, segmentGroup, outlet) {\n\t            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n\t                return rxjs_operator_map.map.call(this.expandChildren(injector, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });\n\t            }\n\t            else {\n\t                return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.expandChildren = function (injector, routes, segmentGroup) {\n\t            var _this = this;\n\t            return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(injector, routes, child, childOutlet); });\n\t        };\n\t        ApplyRedirects.prototype.expandSegment = function (injector, segmentGroup, routes, segments, outlet, allowRedirects) {\n\t            var _this = this;\n\t            var routes$ = rxjs_observable_of.of.apply(void 0, routes);\n\t            var processedRoutes$ = rxjs_operator_map.map.call(routes$, function (r) {\n\t                var expanded$ = _this.expandSegmentAgainstRoute(injector, segmentGroup, routes, r, segments, outlet, allowRedirects);\n\t                return rxjs_operator_catch._catch.call(expanded$, function (e) {\n\t                    if (e instanceof NoMatch)\n\t                        return rxjs_observable_of.of(null);\n\t                    else\n\t                        throw e;\n\t                });\n\t            });\n\t            var concattedProcessedRoutes$ = rxjs_operator_concatAll.concatAll.call(processedRoutes$);\n\t            var first$ = rxjs_operator_first.first.call(concattedProcessedRoutes$, function (s) { return !!s; });\n\t            return rxjs_operator_catch._catch.call(first$, function (e, _) {\n\t                if (e instanceof rxjs_util_EmptyError.EmptyError) {\n\t                    throw new NoMatch(segmentGroup);\n\t                }\n\t                else {\n\t                    throw e;\n\t                }\n\t            });\n\t        };\n\t        ApplyRedirects.prototype.expandSegmentAgainstRoute = function (injector, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n\t            if (getOutlet$1(route) !== outlet)\n\t                return noMatch(segmentGroup);\n\t            if (route.redirectTo !== undefined && !(allowRedirects && this.allowRedirects))\n\t                return noMatch(segmentGroup);\n\t            if (route.redirectTo === undefined) {\n\t                return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths);\n\t            }\n\t            else {\n\t                return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, paths, outlet);\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n\t            if (route.path === '**') {\n\t                return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet);\n\t            }\n\t            else {\n\t                return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet);\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (injector, routes, route, outlet) {\n\t            var newSegments = applyRedirectCommands([], route.redirectTo, {});\n\t            if (route.redirectTo.startsWith('/')) {\n\t                return absoluteRedirect(newSegments);\n\t            }\n\t            else {\n\t                var group = new UrlSegmentGroup(newSegments, {});\n\t                return this.expandSegment(injector, group, routes, newSegments, outlet, false);\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n\t            var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\n\t            if (!matched)\n\t                return noMatch(segmentGroup);\n\t            var newSegments = applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);\n\t            if (route.redirectTo.startsWith('/')) {\n\t                return absoluteRedirect(newSegments);\n\t            }\n\t            else {\n\t                return this.expandSegment(injector, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.matchSegmentAgainstRoute = function (injector, rawSegmentGroup, route, segments) {\n\t            var _this = this;\n\t            if (route.path === '**') {\n\t                if (route.loadChildren) {\n\t                    return rxjs_operator_map.map.call(this.configLoader.load(injector, route.loadChildren), function (r) {\n\t                        route._loadedConfig = r;\n\t                        return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n\t                    });\n\t                }\n\t                else {\n\t                    return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n\t                }\n\t            }\n\t            else {\n\t                var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments_1 = _a.consumedSegments, lastChild = _a.lastChild;\n\t                if (!matched)\n\t                    return noMatch(rawSegmentGroup);\n\t                var rawSlicedSegments_1 = segments.slice(lastChild);\n\t                var childConfig$ = this.getChildConfig(injector, route);\n\t                return rxjs_operator_mergeMap.mergeMap.call(childConfig$, function (routerConfig) {\n\t                    var childInjector = routerConfig.injector;\n\t                    var childConfig = routerConfig.routes;\n\t                    var _a = split(rawSegmentGroup, consumedSegments_1, rawSlicedSegments_1, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n\t                    if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n\t                        var expanded$ = _this.expandChildren(childInjector, childConfig, segmentGroup);\n\t                        return rxjs_operator_map.map.call(expanded$, function (children) { return new UrlSegmentGroup(consumedSegments_1, children); });\n\t                    }\n\t                    else if (childConfig.length === 0 && slicedSegments.length === 0) {\n\t                        return rxjs_observable_of.of(new UrlSegmentGroup(consumedSegments_1, {}));\n\t                    }\n\t                    else {\n\t                        var expanded$ = _this.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n\t                        return rxjs_operator_map.map.call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments_1.concat(cs.segments), cs.children); });\n\t                    }\n\t                });\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.getChildConfig = function (injector, route) {\n\t            var _this = this;\n\t            if (route.children) {\n\t                return rxjs_observable_of.of(new LoadedRouterConfig(route.children, injector, null));\n\t            }\n\t            else if (route.loadChildren) {\n\t                return rxjs_operator_mergeMap.mergeMap.call(runGuards(injector, route), function (shouldLoad) {\n\t                    if (shouldLoad) {\n\t                        if (route._loadedConfig) {\n\t                            return rxjs_observable_of.of(route._loadedConfig);\n\t                        }\n\t                        else {\n\t                            return rxjs_operator_map.map.call(_this.configLoader.load(injector, route.loadChildren), function (r) {\n\t                                route._loadedConfig = r;\n\t                                return r;\n\t                            });\n\t                        }\n\t                    }\n\t                    else {\n\t                        return canLoadFails(route);\n\t                    }\n\t                });\n\t            }\n\t            else {\n\t                return rxjs_observable_of.of(new LoadedRouterConfig([], injector, null));\n\t            }\n\t        };\n\t        return ApplyRedirects;\n\t    }());\n\t    function runGuards(injector, route) {\n\t        var canLoad = route.canLoad;\n\t        if (!canLoad || canLoad.length === 0)\n\t            return rxjs_observable_of.of(true);\n\t        var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canLoad), function (c) {\n\t            var guard = injector.get(c);\n\t            if (guard.canLoad) {\n\t                return wrapIntoObservable(guard.canLoad(route));\n\t            }\n\t            else {\n\t                return wrapIntoObservable(guard(route));\n\t            }\n\t        });\n\t        return andObservables(obs);\n\t    }\n\t    function match(segmentGroup, route, segments) {\n\t        var noMatch = { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n\t        if (route.path === '') {\n\t            if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n\t                return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n\t            }\n\t            else {\n\t                return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n\t            }\n\t        }\n\t        var path = route.path;\n\t        var parts = path.split('/');\n\t        var positionalParamSegments = {};\n\t        var consumedSegments = [];\n\t        var currentIndex = 0;\n\t        for (var i = 0; i < parts.length; ++i) {\n\t            if (currentIndex >= segments.length)\n\t                return noMatch;\n\t            var current = segments[currentIndex];\n\t            var p = parts[i];\n\t            var isPosParam = p.startsWith(':');\n\t            if (!isPosParam && p !== current.path)\n\t                return noMatch;\n\t            if (isPosParam) {\n\t                positionalParamSegments[p.substring(1)] = current;\n\t            }\n\t            consumedSegments.push(current);\n\t            currentIndex++;\n\t        }\n\t        if (route.pathMatch === 'full' &&\n\t            (segmentGroup.hasChildren() || currentIndex < segments.length)) {\n\t            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n\t        }\n\t        return { matched: true, consumedSegments: consumedSegments, lastChild: currentIndex, positionalParamSegments: positionalParamSegments };\n\t    }\n\t    function applyRedirectCommands(segments, redirectTo, posParams) {\n\t        var r = redirectTo.startsWith('/') ? redirectTo.substring(1) : redirectTo;\n\t        if (r === '') {\n\t            return [];\n\t        }\n\t        else {\n\t            return createSegments(redirectTo, r.split('/'), segments, posParams);\n\t        }\n\t    }\n\t    function createSegments(redirectTo, parts, segments, posParams) {\n\t        return parts.map(function (p) { return p.startsWith(':') ? findPosParam(p, posParams, redirectTo) :\n\t            findOrCreateSegment(p, segments); });\n\t    }\n\t    function findPosParam(part, posParams, redirectTo) {\n\t        var paramName = part.substring(1);\n\t        var pos = posParams[paramName];\n\t        if (!pos)\n\t            throw new Error(\"Cannot redirect to '\" + redirectTo + \"'. Cannot find '\" + part + \"'.\");\n\t        return pos;\n\t    }\n\t    function findOrCreateSegment(part, segments) {\n\t        var idx = 0;\n\t        for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n\t            var s = segments_1[_i];\n\t            if (s.path === part) {\n\t                segments.splice(idx);\n\t                return s;\n\t            }\n\t            idx++;\n\t        }\n\t        return new UrlSegment(part, {});\n\t    }\n\t    function split(segmentGroup, consumedSegments, slicedSegments, config) {\n\t        if (slicedSegments.length > 0 &&\n\t            containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n\t            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\t            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\n\t        }\n\t        else if (slicedSegments.length === 0 &&\n\t            containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n\t            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\t            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\n\t        }\n\t        else {\n\t            return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\n\t        }\n\t    }\n\t    function mergeTrivialChildren(s) {\n\t        if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n\t            var c = s.children[PRIMARY_OUTLET];\n\t            return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n\t        }\n\t        else {\n\t            return s;\n\t        }\n\t    }\n\t    function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n\t        var res = {};\n\t        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n\t            var r = routes_1[_i];\n\t            if (emptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n\t                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n\t            }\n\t        }\n\t        return merge(children, res);\n\t    }\n\t    function createChildrenForEmptySegments(routes, primarySegmentGroup) {\n\t        var res = {};\n\t        res[PRIMARY_OUTLET] = primarySegmentGroup;\n\t        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n\t            var r = routes_2[_i];\n\t            if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n\t                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n\t        return routes\n\t            .filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r) &&\n\t            getOutlet$1(r) !== PRIMARY_OUTLET; })\n\t            .length > 0;\n\t    }\n\t    function containsEmptyPathRedirects(segmentGroup, slicedSegments, routes) {\n\t        return routes.filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r); }).length > 0;\n\t    }\n\t    function emptyPathRedirect(segmentGroup, slicedSegments, r) {\n\t        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n\t            return false;\n\t        return r.path === '' && r.redirectTo !== undefined;\n\t    }\n\t    function getOutlet$1(route) {\n\t        return route.outlet ? route.outlet : PRIMARY_OUTLET;\n\t    }\n\t\n\t    function validateConfig(config) {\n\t        config.forEach(validateNode);\n\t    }\n\t    function validateNode(route) {\n\t        if (Array.isArray(route)) {\n\t            throw new Error(\"Invalid route configuration: Array cannot be specified\");\n\t        }\n\t        if (route.component === undefined && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n\t            throw new Error(\"Invalid route configuration of route '\" + route.path + \"': a componentless route cannot have a named outlet set\");\n\t        }\n\t        if (!!route.redirectTo && !!route.children) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and children cannot be used together\");\n\t        }\n\t        if (!!route.redirectTo && !!route.loadChildren) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and loadChildren cannot be used together\");\n\t        }\n\t        if (!!route.children && !!route.loadChildren) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': children and loadChildren cannot be used together\");\n\t        }\n\t        if (!!route.redirectTo && !!route.component) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and component cannot be used together\");\n\t        }\n\t        if (route.redirectTo === undefined && !route.component && !route.children &&\n\t            !route.loadChildren) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': one of the following must be provided (component or redirectTo or children or loadChildren)\");\n\t        }\n\t        if (route.path === undefined) {\n\t            throw new Error(\"Invalid route configuration: routes must have path specified\");\n\t        }\n\t        if (route.path.startsWith('/')) {\n\t            throw new Error(\"Invalid route configuration of route '\" + route.path + \"': path cannot start with a slash\");\n\t        }\n\t        if (route.path === '' && route.redirectTo !== undefined && route.pathMatch === undefined) {\n\t            var exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n\t            throw new Error(\"Invalid route configuration of route '{path: \\\"\" + route.path + \"\\\", redirectTo: \\\"\" + route.redirectTo + \"\\\"}': please provide 'pathMatch'. \" + exp);\n\t        }\n\t        if (route.pathMatch !== undefined && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': pathMatch can only be set to 'prefix' or 'full'\");\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @license\n\t     * Copyright Google Inc. All Rights Reserved.\n\t     *\n\t     * Use of this source code is governed by an MIT-style license that can be\n\t     * found in the LICENSE file at https://angular.io/license\n\t     */\n\t    var Tree = (function () {\n\t        function Tree(root) {\n\t            this._root = root;\n\t        }\n\t        Object.defineProperty(Tree.prototype, \"root\", {\n\t            get: function () { return this._root.value; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.parent = function (t) {\n\t            var p = this.pathFromRoot(t);\n\t            return p.length > 1 ? p[p.length - 2] : null;\n\t        };\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.children = function (t) {\n\t            var n = findNode(t, this._root);\n\t            return n ? n.children.map(function (t) { return t.value; }) : [];\n\t        };\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.firstChild = function (t) {\n\t            var n = findNode(t, this._root);\n\t            return n && n.children.length > 0 ? n.children[0].value : null;\n\t        };\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.siblings = function (t) {\n\t            var p = findPath(t, this._root, []);\n\t            if (p.length < 2)\n\t                return [];\n\t            var c = p[p.length - 2].children.map(function (c) { return c.value; });\n\t            return c.filter(function (cc) { return cc !== t; });\n\t        };\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root, []).map(function (s) { return s.value; }); };\n\t        return Tree;\n\t    }());\n\t    function findNode(expected, c) {\n\t        if (expected === c.value)\n\t            return c;\n\t        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n\t            var cc = _a[_i];\n\t            var r = findNode(expected, cc);\n\t            if (r)\n\t                return r;\n\t        }\n\t        return null;\n\t    }\n\t    function findPath(expected, c, collected) {\n\t        collected.push(c);\n\t        if (expected === c.value)\n\t            return collected;\n\t        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n\t            var cc = _a[_i];\n\t            var cloned = collected.slice(0);\n\t            var r = findPath(expected, cc, cloned);\n\t            if (r.length > 0)\n\t                return r;\n\t        }\n\t        return [];\n\t    }\n\t    var TreeNode = (function () {\n\t        function TreeNode(value, children) {\n\t            this.value = value;\n\t            this.children = children;\n\t        }\n\t        TreeNode.prototype.toString = function () { return \"TreeNode(\" + this.value + \")\"; };\n\t        return TreeNode;\n\t    }());\n\t\n\t    /**\n\t     * @license\n\t     * Copyright Google Inc. All Rights Reserved.\n\t     *\n\t     * Use of this source code is governed by an MIT-style license that can be\n\t     * found in the LICENSE file at https://angular.io/license\n\t     */\n\t    var __extends$1 = (this && this.__extends) || function (d, b) {\n\t        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t    /**\n\t     * @whatItDoes Represents the state of the router.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'template.html'})\n\t     * class MyComponent {\n\t     *   constructor(router: Router) {\n\t     *     const state: RouterState = router.routerState;\n\t     *     const root: ActivatedRoute = state.root;\n\t     *     const child = root.firstChild;\n\t     *     const id: Observable<string> = child.params.map(p => p.id);\n\t     *     //...\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @description\n\t     * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n\t     * segments,\n\t     * the extracted parameters, and the resolved data.\n\t     *\n\t     * See {@link ActivatedRoute} for more information.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterState = (function (_super) {\n\t        __extends$1(RouterState, _super);\n\t        /**\n\t         * @internal\n\t         */\n\t        function RouterState(root,\n\t            /**\n\t             * The current snapshot of the router state.\n\t             */\n\t            snapshot) {\n\t            _super.call(this, root);\n\t            this.snapshot = snapshot;\n\t            setRouterStateSnapshot(this, root);\n\t        }\n\t        RouterState.prototype.toString = function () { return this.snapshot.toString(); };\n\t        return RouterState;\n\t    }(Tree));\n\t    function createEmptyState(urlTree, rootComponent) {\n\t        var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n\t        var emptyUrl = new rxjs_BehaviorSubject.BehaviorSubject([new UrlSegment('', {})]);\n\t        var emptyParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n\t        var emptyData = new rxjs_BehaviorSubject.BehaviorSubject({});\n\t        var emptyQueryParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n\t        var fragment = new rxjs_BehaviorSubject.BehaviorSubject('');\n\t        var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n\t        activated.snapshot = snapshot.root;\n\t        return new RouterState(new TreeNode(activated, []), snapshot);\n\t    }\n\t    function createEmptyStateSnapshot(urlTree, rootComponent) {\n\t        var emptyParams = {};\n\t        var emptyData = {};\n\t        var emptyQueryParams = {};\n\t        var fragment = '';\n\t        var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n\t        return new RouterStateSnapshot('', new TreeNode(activated, []));\n\t    }\n\t    /**\n\t     * @whatItDoes Contains the information about a route associated with a component loaded in an\n\t     * outlet.\n\t     * ActivatedRoute can also be used to traverse the router state tree.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'./my-component.html'})\n\t     * class MyComponent {\n\t     *   constructor(route: ActivatedRoute) {\n\t     *     const id: Observable<string> = route.params.map(p => p.id);\n\t     *     const url: Observable<string> = route.url.map(s => s.join(''));\n\t     *     const user = route.data.map(d => d.user); //includes `data` and `resolve`\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @stable\n\t     */\n\t    var ActivatedRoute = (function () {\n\t        /**\n\t         * @internal\n\t         */\n\t        function ActivatedRoute(\n\t            /**\n\t             *  The URL segments matched by this route. The observable will emit a new value when\n\t             *  the array of segments changes.\n\t             */\n\t            url,\n\t            /**\n\t             * The matrix parameters scoped to this route. The observable will emit a new value when\n\t             * the set of the parameters changes.\n\t             */\n\t            params,\n\t            /**\n\t             * The query parameters shared by all the routes. The observable will emit a new value when\n\t             * the set of the parameters changes.\n\t             */\n\t            queryParams,\n\t            /**\n\t             * The URL fragment shared by all the routes. The observable will emit a new value when\n\t             * the URL fragment changes.\n\t             */\n\t            fragment,\n\t            /**\n\t             * The static and resolved data of this route. The observable will emit a new value when\n\t             * any of the resolvers returns a new object.\n\t             */\n\t            data,\n\t            /**\n\t             * The outlet name of the route. It's a constant.\n\t             */\n\t            outlet,\n\t            /**\n\t             * The component of the route. It's a constant.\n\t             */\n\t            component, // TODO: vsavkin: remove |string\n\t            futureSnapshot) {\n\t            this.url = url;\n\t            this.params = params;\n\t            this.queryParams = queryParams;\n\t            this.fragment = fragment;\n\t            this.data = data;\n\t            this.outlet = outlet;\n\t            this.component = component;\n\t            this._futureSnapshot = futureSnapshot;\n\t        }\n\t        Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\n\t            /**\n\t             * The configuration used to match this route.\n\t             */\n\t            get: function () { return this._futureSnapshot.routeConfig; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"root\", {\n\t            /**\n\t             * The root of the router state.\n\t             */\n\t            get: function () { return this._routerState.root; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\n\t            /**\n\t             * The parent of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.parent(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\n\t            /**\n\t             * The first child of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.firstChild(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"children\", {\n\t            /**\n\t             * The children of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.children(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\n\t            /**\n\t             * The path from the root of the router state tree to this route.\n\t             */\n\t            get: function () { return this._routerState.pathFromRoot(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        ActivatedRoute.prototype.toString = function () {\n\t            return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\n\t        };\n\t        return ActivatedRoute;\n\t    }());\n\t    /**\n\t     * @internal\n\t     */\n\t    function inheritedParamsDataResolve(route) {\n\t        var pathToRoot = route.pathFromRoot;\n\t        var inhertingStartingFrom = pathToRoot.length - 1;\n\t        while (inhertingStartingFrom >= 1) {\n\t            var current = pathToRoot[inhertingStartingFrom];\n\t            var parent_1 = pathToRoot[inhertingStartingFrom - 1];\n\t            // current route is an empty path => inherits its parent's params and data\n\t            if (current.routeConfig && current.routeConfig.path === '') {\n\t                inhertingStartingFrom--;\n\t            }\n\t            else if (!parent_1.component) {\n\t                inhertingStartingFrom--;\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {\n\t            var params = merge(res.params, curr.params);\n\t            var data = merge(res.data, curr.data);\n\t            var resolve = merge(res.resolve, curr._resolvedData);\n\t            return { params: params, data: data, resolve: resolve };\n\t        }, { params: {}, data: {}, resolve: {} });\n\t    }\n\t    /**\n\t     * @whatItDoes Contains the information about a route associated with a component loaded in an\n\t     * outlet\n\t     * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router\n\t     * state tree.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'./my-component.html'})\n\t     * class MyComponent {\n\t     *   constructor(route: ActivatedRoute) {\n\t     *     const id: string = route.snapshot.params.id;\n\t     *     const url: string = route.snapshot.url.join('');\n\t     *     const user = route.snapshot.data.user;\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @stable\n\t     */\n\t    var ActivatedRouteSnapshot = (function () {\n\t        /**\n\t         * @internal\n\t         */\n\t        function ActivatedRouteSnapshot(\n\t            /**\n\t             *  The URL segments matched by this route.\n\t             */\n\t            url,\n\t            /**\n\t             * The matrix parameters scoped to this route.\n\t             */\n\t            params,\n\t            /**\n\t             * The query parameters shared by all the routes.\n\t             */\n\t            queryParams,\n\t            /**\n\t             * The URL fragment shared by all the routes.\n\t             */\n\t            fragment,\n\t            /**\n\t             * The static and resolved data of this route.\n\t             */\n\t            data,\n\t            /**\n\t             * The outlet name of the route.\n\t             */\n\t            outlet,\n\t            /**\n\t             * The component of the route.\n\t             */\n\t            component, routeConfig, urlSegment, lastPathIndex, resolve) {\n\t            this.url = url;\n\t            this.params = params;\n\t            this.queryParams = queryParams;\n\t            this.fragment = fragment;\n\t            this.data = data;\n\t            this.outlet = outlet;\n\t            this.component = component;\n\t            this._routeConfig = routeConfig;\n\t            this._urlSegment = urlSegment;\n\t            this._lastPathIndex = lastPathIndex;\n\t            this._resolve = resolve;\n\t        }\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"routeConfig\", {\n\t            /**\n\t             * The configuration used to match this route.\n\t             */\n\t            get: function () { return this._routeConfig; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\n\t            /**\n\t             * The root of the router state.\n\t             */\n\t            get: function () { return this._routerState.root; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\n\t            /**\n\t             * The parent of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.parent(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\n\t            /**\n\t             * The first child of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.firstChild(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\n\t            /**\n\t             * The children of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.children(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\n\t            /**\n\t             * The path from the root of the router state tree to this route.\n\t             */\n\t            get: function () { return this._routerState.pathFromRoot(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        ActivatedRouteSnapshot.prototype.toString = function () {\n\t            var url = this.url.map(function (s) { return s.toString(); }).join('/');\n\t            var matched = this._routeConfig ? this._routeConfig.path : '';\n\t            return \"Route(url:'\" + url + \"', path:'\" + matched + \"')\";\n\t        };\n\t        return ActivatedRouteSnapshot;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents the state of the router at a moment in time.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'template.html'})\n\t     * class MyComponent {\n\t     *   constructor(router: Router) {\n\t     *     const state: RouterState = router.routerState;\n\t     *     const snapshot: RouterStateSnapshot = state.snapshot;\n\t     *     const root: ActivatedRouteSnapshot = snapshot.root;\n\t     *     const child = root.firstChild;\n\t     *     const id: Observable<string> = child.params.map(p => p.id);\n\t     *     //...\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @description\n\t     * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about\n\t     * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterStateSnapshot = (function (_super) {\n\t        __extends$1(RouterStateSnapshot, _super);\n\t        /**\n\t         * @internal\n\t         */\n\t        function RouterStateSnapshot(\n\t            /** The url from which this snapshot was created */\n\t            url, root) {\n\t            _super.call(this, root);\n\t            this.url = url;\n\t            setRouterStateSnapshot(this, root);\n\t        }\n\t        RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };\n\t        return RouterStateSnapshot;\n\t    }(Tree));\n\t    function setRouterStateSnapshot(state, node) {\n\t        node.value._routerState = state;\n\t        node.children.forEach(function (c) { return setRouterStateSnapshot(state, c); });\n\t    }\n\t    function serializeNode(node) {\n\t        var c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(\", \") + \" } \" : '';\n\t        return \"\" + node.value + c;\n\t    }\n\t    /**\n\t     * The expectation is that the activate route is created with the right set of parameters.\n\t     * So we push new values into the observables only when they are not the initial values.\n\t     * And we detect that by checking if the snapshot field is set.\n\t     */\n\t    function advanceActivatedRoute(route) {\n\t        if (route.snapshot) {\n\t            if (!shallowEqual(route.snapshot.queryParams, route._futureSnapshot.queryParams)) {\n\t                route.queryParams.next(route._futureSnapshot.queryParams);\n\t            }\n\t            if (route.snapshot.fragment !== route._futureSnapshot.fragment) {\n\t                route.fragment.next(route._futureSnapshot.fragment);\n\t            }\n\t            if (!shallowEqual(route.snapshot.params, route._futureSnapshot.params)) {\n\t                route.params.next(route._futureSnapshot.params);\n\t                route.data.next(route._futureSnapshot.data);\n\t            }\n\t            if (!shallowEqualArrays(route.snapshot.url, route._futureSnapshot.url)) {\n\t                route.url.next(route._futureSnapshot.url);\n\t            }\n\t            route.snapshot = route._futureSnapshot;\n\t        }\n\t        else {\n\t            route.snapshot = route._futureSnapshot;\n\t            // this is for resolved data\n\t            route.data.next(route._futureSnapshot.data);\n\t        }\n\t    }\n\t\n\t    function createRouterState(curr, prevState) {\n\t        var root = createNode(curr._root, prevState ? prevState._root : undefined);\n\t        return new RouterState(root, curr);\n\t    }\n\t    function createNode(curr, prevState) {\n\t        if (prevState && equalRouteSnapshots(prevState.value.snapshot, curr.value)) {\n\t            var value = prevState.value;\n\t            value._futureSnapshot = curr.value;\n\t            var children = createOrReuseChildren(curr, prevState);\n\t            return new TreeNode(value, children);\n\t        }\n\t        else {\n\t            var value = createActivatedRoute(curr.value);\n\t            var children = curr.children.map(function (c) { return createNode(c); });\n\t            return new TreeNode(value, children);\n\t        }\n\t    }\n\t    function createOrReuseChildren(curr, prevState) {\n\t        return curr.children.map(function (child) {\n\t            for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {\n\t                var p = _a[_i];\n\t                if (equalRouteSnapshots(p.value.snapshot, child.value)) {\n\t                    return createNode(child, p);\n\t                }\n\t            }\n\t            return createNode(child);\n\t        });\n\t    }\n\t    function createActivatedRoute(c) {\n\t        return new ActivatedRoute(new rxjs_BehaviorSubject.BehaviorSubject(c.url), new rxjs_BehaviorSubject.BehaviorSubject(c.params), new rxjs_BehaviorSubject.BehaviorSubject(c.queryParams), new rxjs_BehaviorSubject.BehaviorSubject(c.fragment), new rxjs_BehaviorSubject.BehaviorSubject(c.data), c.outlet, c.component, c);\n\t    }\n\t    function equalRouteSnapshots(a, b) {\n\t        return a._routeConfig === b._routeConfig;\n\t    }\n\t\n\t    function createUrlTree(route, urlTree, commands, queryParams, fragment) {\n\t        if (commands.length === 0) {\n\t            return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n\t        }\n\t        var normalizedCommands = normalizeCommands(commands);\n\t        validateCommands(normalizedCommands);\n\t        if (navigateToRoot(normalizedCommands)) {\n\t            return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n\t        }\n\t        var startingPosition = findStartingPosition(normalizedCommands, urlTree, route);\n\t        var segmentGroup = startingPosition.processChildren ?\n\t            updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, normalizedCommands.commands) :\n\t            updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, normalizedCommands.commands);\n\t        return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n\t    }\n\t    function validateCommands(n) {\n\t        if (n.isAbsolute && n.commands.length > 0 && isMatrixParams(n.commands[0])) {\n\t            throw new Error('Root segment cannot have matrix parameters');\n\t        }\n\t        var c = n.commands.filter(function (c) { return typeof c === 'object' && c.outlets !== undefined; });\n\t        if (c.length > 0 && c[0] !== n.commands[n.commands.length - 1]) {\n\t            throw new Error('{outlets:{}} has to be the last command');\n\t        }\n\t    }\n\t    function isMatrixParams(command) {\n\t        return typeof command === 'object' && command.outlets === undefined &&\n\t            command.segmentPath === undefined;\n\t    }\n\t    function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n\t        if (urlTree.root === oldSegmentGroup) {\n\t            return new UrlTree(newSegmentGroup, stringify(queryParams), fragment);\n\t        }\n\t        else {\n\t            return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), stringify(queryParams), fragment);\n\t        }\n\t    }\n\t    function replaceSegment(current, oldSegment, newSegment) {\n\t        var children = {};\n\t        forEach(current.children, function (c, outletName) {\n\t            if (c === oldSegment) {\n\t                children[outletName] = newSegment;\n\t            }\n\t            else {\n\t                children[outletName] = replaceSegment(c, oldSegment, newSegment);\n\t            }\n\t        });\n\t        return new UrlSegmentGroup(current.segments, children);\n\t    }\n\t    function navigateToRoot(normalizedChange) {\n\t        return normalizedChange.isAbsolute && normalizedChange.commands.length === 1 &&\n\t            normalizedChange.commands[0] == '/';\n\t    }\n\t    var NormalizedNavigationCommands = (function () {\n\t        function NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, commands) {\n\t            this.isAbsolute = isAbsolute;\n\t            this.numberOfDoubleDots = numberOfDoubleDots;\n\t            this.commands = commands;\n\t        }\n\t        return NormalizedNavigationCommands;\n\t    }());\n\t    function normalizeCommands(commands) {\n\t        if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] == '/') {\n\t            return new NormalizedNavigationCommands(true, 0, commands);\n\t        }\n\t        var numberOfDoubleDots = 0;\n\t        var isAbsolute = false;\n\t        var res = [];\n\t        var _loop_1 = function(i) {\n\t            var c = commands[i];\n\t            if (typeof c === 'object' && c.outlets !== undefined) {\n\t                var r_1 = {};\n\t                forEach(c.outlets, function (commands, name) {\n\t                    if (typeof commands === 'string') {\n\t                        r_1[name] = commands.split('/');\n\t                    }\n\t                    else {\n\t                        r_1[name] = commands;\n\t                    }\n\t                });\n\t                res.push({ outlets: r_1 });\n\t                return \"continue\";\n\t            }\n\t            if (typeof c === 'object' && c.segmentPath !== undefined) {\n\t                res.push(c.segmentPath);\n\t                return \"continue\";\n\t            }\n\t            if (!(typeof c === 'string')) {\n\t                res.push(c);\n\t                return \"continue\";\n\t            }\n\t            if (i === 0) {\n\t                var parts = c.split('/');\n\t                for (var j = 0; j < parts.length; ++j) {\n\t                    var cc = parts[j];\n\t                    if (j == 0 && cc == '.') {\n\t                    }\n\t                    else if (j == 0 && cc == '') {\n\t                        isAbsolute = true;\n\t                    }\n\t                    else if (cc == '..') {\n\t                        numberOfDoubleDots++;\n\t                    }\n\t                    else if (cc != '') {\n\t                        res.push(cc);\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                res.push(c);\n\t            }\n\t        };\n\t        for (var i = 0; i < commands.length; ++i) {\n\t            _loop_1(i);\n\t        }\n\t        return new NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, res);\n\t    }\n\t    var Position = (function () {\n\t        function Position(segmentGroup, processChildren, index) {\n\t            this.segmentGroup = segmentGroup;\n\t            this.processChildren = processChildren;\n\t            this.index = index;\n\t        }\n\t        return Position;\n\t    }());\n\t    function findStartingPosition(normalizedChange, urlTree, route) {\n\t        if (normalizedChange.isAbsolute) {\n\t            return new Position(urlTree.root, true, 0);\n\t        }\n\t        else if (route.snapshot._lastPathIndex === -1) {\n\t            return new Position(route.snapshot._urlSegment, true, 0);\n\t        }\n\t        else {\n\t            var modifier = isMatrixParams(normalizedChange.commands[0]) ? 0 : 1;\n\t            var index = route.snapshot._lastPathIndex + modifier;\n\t            return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, normalizedChange.numberOfDoubleDots);\n\t        }\n\t    }\n\t    function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n\t        var g = group;\n\t        var ci = index;\n\t        var dd = numberOfDoubleDots;\n\t        while (dd > ci) {\n\t            dd -= ci;\n\t            g = g.parent;\n\t            if (!g) {\n\t                throw new Error('Invalid number of \\'../\\'');\n\t            }\n\t            ci = g.segments.length;\n\t        }\n\t        return new Position(g, false, ci - dd);\n\t    }\n\t    function getPath(command) {\n\t        if (typeof command === 'object' && command.outlets)\n\t            return command.outlets[PRIMARY_OUTLET];\n\t        return \"\" + command;\n\t    }\n\t    function getOutlets(commands) {\n\t        if (!(typeof commands[0] === 'object'))\n\t            return (_a = {}, _a[PRIMARY_OUTLET] = commands, _a);\n\t        if (commands[0].outlets === undefined)\n\t            return (_b = {}, _b[PRIMARY_OUTLET] = commands, _b);\n\t        return commands[0].outlets;\n\t        var _a, _b;\n\t    }\n\t    function updateSegmentGroup(segmentGroup, startIndex, commands) {\n\t        if (!segmentGroup) {\n\t            segmentGroup = new UrlSegmentGroup([], {});\n\t        }\n\t        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n\t            return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n\t        }\n\t        var m = prefixedWith(segmentGroup, startIndex, commands);\n\t        var slicedCommands = commands.slice(m.commandIndex);\n\t        if (m.match && m.pathIndex < segmentGroup.segments.length) {\n\t            var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n\t            g.children[PRIMARY_OUTLET] =\n\t                new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n\t            return updateSegmentGroupChildren(g, 0, slicedCommands);\n\t        }\n\t        else if (m.match && slicedCommands.length === 0) {\n\t            return new UrlSegmentGroup(segmentGroup.segments, {});\n\t        }\n\t        else if (m.match && !segmentGroup.hasChildren()) {\n\t            return createNewSegmentGroup(segmentGroup, startIndex, commands);\n\t        }\n\t        else if (m.match) {\n\t            return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n\t        }\n\t        else {\n\t            return createNewSegmentGroup(segmentGroup, startIndex, commands);\n\t        }\n\t    }\n\t    function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n\t        if (commands.length === 0) {\n\t            return new UrlSegmentGroup(segmentGroup.segments, {});\n\t        }\n\t        else {\n\t            var outlets_1 = getOutlets(commands);\n\t            var children_1 = {};\n\t            forEach(outlets_1, function (commands, outlet) {\n\t                if (commands !== null) {\n\t                    children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n\t                }\n\t            });\n\t            forEach(segmentGroup.children, function (child, childOutlet) {\n\t                if (outlets_1[childOutlet] === undefined) {\n\t                    children_1[childOutlet] = child;\n\t                }\n\t            });\n\t            return new UrlSegmentGroup(segmentGroup.segments, children_1);\n\t        }\n\t    }\n\t    function prefixedWith(segmentGroup, startIndex, commands) {\n\t        var currentCommandIndex = 0;\n\t        var currentPathIndex = startIndex;\n\t        var noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n\t        while (currentPathIndex < segmentGroup.segments.length) {\n\t            if (currentCommandIndex >= commands.length)\n\t                return noMatch;\n\t            var path = segmentGroup.segments[currentPathIndex];\n\t            var curr = getPath(commands[currentCommandIndex]);\n\t            var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\t            if (currentPathIndex > 0 && curr === undefined)\n\t                break;\n\t            if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n\t                if (!compare(curr, next, path))\n\t                    return noMatch;\n\t                currentCommandIndex += 2;\n\t            }\n\t            else {\n\t                if (!compare(curr, {}, path))\n\t                    return noMatch;\n\t                currentCommandIndex++;\n\t            }\n\t            currentPathIndex++;\n\t        }\n\t        return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n\t    }\n\t    function createNewSegmentGroup(segmentGroup, startIndex, commands) {\n\t        var paths = segmentGroup.segments.slice(0, startIndex);\n\t        var i = 0;\n\t        while (i < commands.length) {\n\t            if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n\t                var children = createNewSegmentChldren(commands[i].outlets);\n\t                return new UrlSegmentGroup(paths, children);\n\t            }\n\t            // if we start with an object literal, we need to reuse the path part from the segment\n\t            if (i === 0 && isMatrixParams(commands[0])) {\n\t                var p = segmentGroup.segments[startIndex];\n\t                paths.push(new UrlSegment(p.path, commands[0]));\n\t                i++;\n\t                continue;\n\t            }\n\t            var curr = getPath(commands[i]);\n\t            var next = (i < commands.length - 1) ? commands[i + 1] : null;\n\t            if (curr && next && isMatrixParams(next)) {\n\t                paths.push(new UrlSegment(curr, stringify(next)));\n\t                i += 2;\n\t            }\n\t            else {\n\t                paths.push(new UrlSegment(curr, {}));\n\t                i++;\n\t            }\n\t        }\n\t        return new UrlSegmentGroup(paths, {});\n\t    }\n\t    function createNewSegmentChldren(outlets) {\n\t        var children = {};\n\t        forEach(outlets, function (commands, outlet) {\n\t            if (commands !== null) {\n\t                children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n\t            }\n\t        });\n\t        return children;\n\t    }\n\t    function stringify(params) {\n\t        var res = {};\n\t        forEach(params, function (v, k) { return res[k] = \"\" + v; });\n\t        return res;\n\t    }\n\t    function compare(path, params, segment) {\n\t        return path == segment.path && shallowEqual(params, segment.parameters);\n\t    }\n\t\n\t    var NoMatch$1 = (function () {\n\t        function NoMatch() {\n\t        }\n\t        return NoMatch;\n\t    }());\n\t    function recognize(rootComponentType, config, urlTree, url) {\n\t        return new Recognizer(rootComponentType, config, urlTree, url).recognize();\n\t    }\n\t    var Recognizer = (function () {\n\t        function Recognizer(rootComponentType, config, urlTree, url) {\n\t            this.rootComponentType = rootComponentType;\n\t            this.config = config;\n\t            this.urlTree = urlTree;\n\t            this.url = url;\n\t        }\n\t        Recognizer.prototype.recognize = function () {\n\t            try {\n\t                var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;\n\t                var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n\t                var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n\t                var rootNode = new TreeNode(root, children);\n\t                var routeState = new RouterStateSnapshot(this.url, rootNode);\n\t                this.inheriteParamsAndData(routeState._root);\n\t                return rxjs_observable_of.of(routeState);\n\t            }\n\t            catch (e) {\n\t                return new rxjs_Observable.Observable(function (obs) { return obs.error(e); });\n\t            }\n\t        };\n\t        Recognizer.prototype.inheriteParamsAndData = function (routeNode) {\n\t            var _this = this;\n\t            var route = routeNode.value;\n\t            var i = inheritedParamsDataResolve(route);\n\t            route.params = Object.freeze(i.params);\n\t            route.data = Object.freeze(i.data);\n\t            routeNode.children.forEach(function (n) { return _this.inheriteParamsAndData(n); });\n\t        };\n\t        Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {\n\t            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n\t                return this.processChildren(config, segmentGroup);\n\t            }\n\t            else {\n\t                return this.processSegment(config, segmentGroup, 0, segmentGroup.segments, outlet);\n\t            }\n\t        };\n\t        Recognizer.prototype.processChildren = function (config, segmentGroup) {\n\t            var _this = this;\n\t            var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\n\t            checkOutletNameUniqueness(children);\n\t            sortActivatedRouteSnapshots(children);\n\t            return children;\n\t        };\n\t        Recognizer.prototype.processSegment = function (config, segmentGroup, pathIndex, segments, outlet) {\n\t            for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {\n\t                var r = config_1[_i];\n\t                try {\n\t                    return this.processSegmentAgainstRoute(r, segmentGroup, pathIndex, segments, outlet);\n\t                }\n\t                catch (e) {\n\t                    if (!(e instanceof NoMatch$1))\n\t                        throw e;\n\t                }\n\t            }\n\t            throw new NoMatch$1();\n\t        };\n\t        Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, pathIndex, segments, outlet) {\n\t            if (route.redirectTo)\n\t                throw new NoMatch$1();\n\t            if ((route.outlet ? route.outlet : PRIMARY_OUTLET) !== outlet)\n\t                throw new NoMatch$1();\n\t            if (route.path === '**') {\n\t                var params = segments.length > 0 ? last(segments).parameters : {};\n\t                var snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n\t                return [new TreeNode(snapshot_1, [])];\n\t            }\n\t            var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;\n\t            var rawSlicedSegments = segments.slice(lastChild);\n\t            var childConfig = getChildConfig(route);\n\t            var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;\n\t            var snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n\t            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n\t                var children = this.processChildren(childConfig, segmentGroup);\n\t                return [new TreeNode(snapshot, children)];\n\t            }\n\t            else if (childConfig.length === 0 && slicedSegments.length === 0) {\n\t                return [new TreeNode(snapshot, [])];\n\t            }\n\t            else {\n\t                var children = this.processSegment(childConfig, segmentGroup, pathIndex + lastChild, slicedSegments, PRIMARY_OUTLET);\n\t                return [new TreeNode(snapshot, children)];\n\t            }\n\t        };\n\t        return Recognizer;\n\t    }());\n\t    function sortActivatedRouteSnapshots(nodes) {\n\t        nodes.sort(function (a, b) {\n\t            if (a.value.outlet === PRIMARY_OUTLET)\n\t                return -1;\n\t            if (b.value.outlet === PRIMARY_OUTLET)\n\t                return 1;\n\t            return a.value.outlet.localeCompare(b.value.outlet);\n\t        });\n\t    }\n\t    function getChildConfig(route) {\n\t        if (route.children) {\n\t            return route.children;\n\t        }\n\t        else if (route.loadChildren) {\n\t            return route._loadedConfig.routes;\n\t        }\n\t        else {\n\t            return [];\n\t        }\n\t    }\n\t    function match$1(segmentGroup, route, segments) {\n\t        if (route.path === '') {\n\t            if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n\t                throw new NoMatch$1();\n\t            }\n\t            else {\n\t                return { consumedSegments: [], lastChild: 0, parameters: {} };\n\t            }\n\t        }\n\t        var path = route.path;\n\t        var parts = path.split('/');\n\t        var posParameters = {};\n\t        var consumedSegments = [];\n\t        var currentIndex = 0;\n\t        for (var i = 0; i < parts.length; ++i) {\n\t            if (currentIndex >= segments.length)\n\t                throw new NoMatch$1();\n\t            var current = segments[currentIndex];\n\t            var p = parts[i];\n\t            var isPosParam = p.startsWith(':');\n\t            if (!isPosParam && p !== current.path)\n\t                throw new NoMatch$1();\n\t            if (isPosParam) {\n\t                posParameters[p.substring(1)] = current.path;\n\t            }\n\t            consumedSegments.push(current);\n\t            currentIndex++;\n\t        }\n\t        if (route.pathMatch === 'full' &&\n\t            (segmentGroup.hasChildren() || currentIndex < segments.length)) {\n\t            throw new NoMatch$1();\n\t        }\n\t        var parameters = merge(posParameters, consumedSegments[consumedSegments.length - 1].parameters);\n\t        return { consumedSegments: consumedSegments, lastChild: currentIndex, parameters: parameters };\n\t    }\n\t    function checkOutletNameUniqueness(nodes) {\n\t        var names = {};\n\t        nodes.forEach(function (n) {\n\t            var routeWithSameOutletName = names[n.value.outlet];\n\t            if (routeWithSameOutletName) {\n\t                var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');\n\t                var c = n.value.url.map(function (s) { return s.toString(); }).join('/');\n\t                throw new Error(\"Two segments cannot have the same outlet name: '\" + p + \"' and '\" + c + \"'.\");\n\t            }\n\t            names[n.value.outlet] = n.value;\n\t        });\n\t    }\n\t    function getSourceSegmentGroup(segmentGroup) {\n\t        var s = segmentGroup;\n\t        while (s._sourceSegment) {\n\t            s = s._sourceSegment;\n\t        }\n\t        return s;\n\t    }\n\t    function getPathIndexShift(segmentGroup) {\n\t        var s = segmentGroup;\n\t        var res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n\t        while (s._sourceSegment) {\n\t            s = s._sourceSegment;\n\t            res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n\t        }\n\t        return res - 1;\n\t    }\n\t    function split$1(segmentGroup, consumedSegments, slicedSegments, config) {\n\t        if (slicedSegments.length > 0 &&\n\t            containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n\t            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\t            s._sourceSegment = segmentGroup;\n\t            s._segmentIndexShift = consumedSegments.length;\n\t            return { segmentGroup: s, slicedSegments: [] };\n\t        }\n\t        else if (slicedSegments.length === 0 &&\n\t            containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n\t            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\t            s._sourceSegment = segmentGroup;\n\t            s._segmentIndexShift = consumedSegments.length;\n\t            return { segmentGroup: s, slicedSegments: slicedSegments };\n\t        }\n\t        else {\n\t            var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n\t            s._sourceSegment = segmentGroup;\n\t            s._segmentIndexShift = consumedSegments.length;\n\t            return { segmentGroup: s, slicedSegments: slicedSegments };\n\t        }\n\t    }\n\t    function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n\t        var res = {};\n\t        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n\t            var r = routes_1[_i];\n\t            if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$2(r)]) {\n\t                var s = new UrlSegmentGroup([], {});\n\t                s._sourceSegment = segmentGroup;\n\t                s._segmentIndexShift = segmentGroup.segments.length;\n\t                res[getOutlet$2(r)] = s;\n\t            }\n\t        }\n\t        return merge(children, res);\n\t    }\n\t    function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n\t        var res = {};\n\t        res[PRIMARY_OUTLET] = primarySegment;\n\t        primarySegment._sourceSegment = segmentGroup;\n\t        primarySegment._segmentIndexShift = consumedSegments.length;\n\t        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n\t            var r = routes_2[_i];\n\t            if (r.path === '' && getOutlet$2(r) !== PRIMARY_OUTLET) {\n\t                var s = new UrlSegmentGroup([], {});\n\t                s._sourceSegment = segmentGroup;\n\t                s._segmentIndexShift = consumedSegments.length;\n\t                res[getOutlet$2(r)] = s;\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n\t        return routes\n\t            .filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) &&\n\t            getOutlet$2(r) !== PRIMARY_OUTLET; })\n\t            .length > 0;\n\t    }\n\t    function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n\t        return routes.filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); }).length > 0;\n\t    }\n\t    function emptyPathMatch(segmentGroup, slicedSegments, r) {\n\t        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n\t            return false;\n\t        return r.path === '' && r.redirectTo === undefined;\n\t    }\n\t    function getOutlet$2(route) {\n\t        return route.outlet ? route.outlet : PRIMARY_OUTLET;\n\t    }\n\t    function getData(route) {\n\t        return route.data ? route.data : {};\n\t    }\n\t    function getResolve(route) {\n\t        return route.resolve ? route.resolve : {};\n\t    }\n\t\n\t    /**\n\t     * @license\n\t     * Copyright Google Inc. All Rights Reserved.\n\t     *\n\t     * Use of this source code is governed by an MIT-style license that can be\n\t     * found in the LICENSE file at https://angular.io/license\n\t     */\n\t    /**\n\t     * @whatItDoes Contains all the router outlets created in a component.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterOutletMap = (function () {\n\t        function RouterOutletMap() {\n\t            /** @internal */\n\t            this._outlets = {};\n\t        }\n\t        /**\n\t         * Adds an outlet to this map.\n\t         */\n\t        RouterOutletMap.prototype.registerOutlet = function (name, outlet) { this._outlets[name] = outlet; };\n\t        /**\n\t         * Removes an outlet from this map.\n\t         */\n\t        RouterOutletMap.prototype.removeOutlet = function (name) { this._outlets[name] = undefined; };\n\t        return RouterOutletMap;\n\t    }());\n\t\n\t    /**\n\t     * @whatItDoes Represents an event triggered when a navigation starts.\n\t     *\n\t     * @stable\n\t     */\n\t    var NavigationStart = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function NavigationStart(\n\t            /** @docsNotRequired */\n\t            id,\n\t            /** @docsNotRequired */\n\t            url) {\n\t            this.id = id;\n\t            this.url = url;\n\t        }\n\t        /** @docsNotRequired */\n\t        NavigationStart.prototype.toString = function () { return \"NavigationStart(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n\t        return NavigationStart;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents an event triggered when a navigation ends successfully.\n\t     *\n\t     * @stable\n\t     */\n\t    var NavigationEnd = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function NavigationEnd(\n\t            /** @docsNotRequired */\n\t            id,\n\t            /** @docsNotRequired */\n\t            url,\n\t            /** @docsNotRequired */\n\t            urlAfterRedirects) {\n\t            this.id = id;\n\t            this.url = url;\n\t            this.urlAfterRedirects = urlAfterRedirects;\n\t        }\n\t        /** @docsNotRequired */\n\t        NavigationEnd.prototype.toString = function () {\n\t            return \"NavigationEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"')\";\n\t        };\n\t        return NavigationEnd;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents an event triggered when a navigation is canceled.\n\t     *\n\t     * @stable\n\t     */\n\t    var NavigationCancel = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function NavigationCancel(\n\t            /** @docsNotRequired */\n\t            id,\n\t            /** @docsNotRequired */\n\t            url,\n\t            /** @docsNotRequired */\n\t            reason) {\n\t            this.id = id;\n\t            this.url = url;\n\t            this.reason = reason;\n\t        }\n\t        /** @docsNotRequired */\n\t        NavigationCancel.prototype.toString = function () { return \"NavigationCancel(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n\t        return NavigationCancel;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.\n\t     *\n\t     * @stable\n\t     */\n\t    var NavigationError = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function NavigationError(\n\t            /** @docsNotRequired */\n\t            id,\n\t            /** @docsNotRequired */\n\t            url,\n\t            /** @docsNotRequired */\n\t            error) {\n\t            this.id = id;\n\t            this.url = url;\n\t            this.error = error;\n\t        }\n\t        /** @docsNotRequired */\n\t        NavigationError.prototype.toString = function () {\n\t            return \"NavigationError(id: \" + this.id + \", url: '\" + this.url + \"', error: \" + this.error + \")\";\n\t        };\n\t        return NavigationError;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents an event triggered when routes are recognized.\n\t     *\n\t     * @stable\n\t     */\n\t    var RoutesRecognized = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function RoutesRecognized(\n\t            /** @docsNotRequired */\n\t            id,\n\t            /** @docsNotRequired */\n\t            url,\n\t            /** @docsNotRequired */\n\t            urlAfterRedirects,\n\t            /** @docsNotRequired */\n\t            state) {\n\t            this.id = id;\n\t            this.url = url;\n\t            this.urlAfterRedirects = urlAfterRedirects;\n\t            this.state = state;\n\t        }\n\t        /** @docsNotRequired */\n\t        RoutesRecognized.prototype.toString = function () {\n\t            return \"RoutesRecognized(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n\t        };\n\t        return RoutesRecognized;\n\t    }());\n\t    function defaultErrorHandler(error) {\n\t        throw error;\n\t    }\n\t    /**\n\t     * @whatItDoes Provides the navigation and url manipulation capabilities.\n\t     *\n\t     * See {@link Routes} for more details and examples.\n\t     *\n\t     * @ngModule RouterModule\n\t     *\n\t     * @stable\n\t     */\n\t    var Router = (function () {\n\t        /**\n\t         * Creates the router service.\n\t         */\n\t        // TODO: vsavkin make internal after the final is out.\n\t        function Router(rootComponentType, urlSerializer, outletMap, location, injector, loader, compiler, config) {\n\t            this.rootComponentType = rootComponentType;\n\t            this.urlSerializer = urlSerializer;\n\t            this.outletMap = outletMap;\n\t            this.location = location;\n\t            this.injector = injector;\n\t            this.config = config;\n\t            this.navigationId = 0;\n\t            /**\n\t             * Error handler that is invoked when a navigation errors.\n\t             *\n\t             * See {@link ErrorHandler} for more information.\n\t             */\n\t            this.errorHandler = defaultErrorHandler;\n\t            /**\n\t             * Indicates if at least one navigation happened.\n\t             */\n\t            this.navigated = false;\n\t            this.resetConfig(config);\n\t            this.routerEvents = new rxjs_Subject.Subject();\n\t            this.currentUrlTree = createEmptyUrlTree();\n\t            this.configLoader = new RouterConfigLoader(loader, compiler);\n\t            this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n\t        }\n\t        /**\n\t         * @internal\n\t         * TODO: this should be removed once the constructor of the router made internal\n\t         */\n\t        Router.prototype.resetRootComponentType = function (rootComponentType) {\n\t            this.rootComponentType = rootComponentType;\n\t            // TODO: vsavkin router 4.0 should make the root component set to null\n\t            // this will simplify the lifecycle of the router.\n\t            this.currentRouterState.root.component = this.rootComponentType;\n\t        };\n\t        /**\n\t         * Sets up the location change listener and performs the initial navigation.\n\t         */\n\t        Router.prototype.initialNavigation = function () {\n\t            this.setUpLocationChangeListener();\n\t            this.navigateByUrl(this.location.path(true), { replaceUrl: true });\n\t        };\n\t        /**\n\t         * Sets up the location change listener.\n\t         */\n\t        Router.prototype.setUpLocationChangeListener = function () {\n\t            var _this = this;\n\t            // Zone.current.wrap is needed because of the issue with RxJS scheduler,\n\t            // which does not work properly with zone.js in IE and Safari\n\t            this.locationSubscription = this.location.subscribe(Zone.current.wrap(function (change) {\n\t                var tree = _this.urlSerializer.parse(change['url']);\n\t                // we fire multiple events for a single URL change\n\t                // we should navigate only once\n\t                return _this.currentUrlTree.toString() !== tree.toString() ?\n\t                    _this.scheduleNavigation(tree, { skipLocationChange: change['pop'], replaceUrl: true }) :\n\t                    null;\n\t            }));\n\t        };\n\t        Object.defineProperty(Router.prototype, \"routerState\", {\n\t            /**\n\t             * Returns the current route state.\n\t             */\n\t            get: function () { return this.currentRouterState; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(Router.prototype, \"url\", {\n\t            /**\n\t             * Returns the current url.\n\t             */\n\t            get: function () { return this.serializeUrl(this.currentUrlTree); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(Router.prototype, \"events\", {\n\t            /**\n\t             * Returns an observable of route events\n\t             */\n\t            get: function () { return this.routerEvents; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * Resets the configuration used for navigation and generating links.\n\t         *\n\t         * ### Usage\n\t         *\n\t         * ```\n\t         * router.resetConfig([\n\t         *  { path: 'team/:id', component: TeamCmp, children: [\n\t         *    { path: 'simple', component: SimpleCmp },\n\t         *    { path: 'user/:name', component: UserCmp }\n\t         *  ] }\n\t         * ]);\n\t         * ```\n\t         */\n\t        Router.prototype.resetConfig = function (config) {\n\t            validateConfig(config);\n\t            this.config = config;\n\t        };\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        Router.prototype.ngOnDestroy = function () { this.dispose(); };\n\t        /**\n\t         * Disposes of the router.\n\t         */\n\t        Router.prototype.dispose = function () { this.locationSubscription.unsubscribe(); };\n\t        /**\n\t         * Applies an array of commands to the current url tree and creates a new url tree.\n\t         *\n\t         * When given an activate route, applies the given commands starting from the route.\n\t         * When not given a route, applies the given command starting from the root.\n\t         *\n\t         * ### Usage\n\t         *\n\t         * ```\n\t         * // create /team/33/user/11\n\t         * router.createUrlTree(['/team', 33, 'user', 11]);\n\t         *\n\t         * // create /team/33;expand=true/user/11\n\t         * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n\t         *\n\t         * // you can collapse static segments like this (this works only with the first passed-in value):\n\t         * router.createUrlTree(['/team/33/user', userId]);\n\t         *\n\t         * // If the first segment can contain slashes, and you do not want the router to split it, you\n\t         * // can do the following:\n\t         *\n\t         * router.createUrlTree([{segmentPath: '/one/two'}]);\n\t         *\n\t         * // create /team/33/(user/11//right:chat)\n\t         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n\t         *\n\t         * // remove the right secondary node\n\t         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n\t         *\n\t         * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n\t         *\n\t         * // navigate to /team/33/user/11/details\n\t         * router.createUrlTree(['details'], {relativeTo: route});\n\t         *\n\t         * // navigate to /team/33/user/22\n\t         * router.createUrlTree(['../22'], {relativeTo: route});\n\t         *\n\t         * // navigate to /team/44/user/22\n\t         * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n\t         * ```\n\t         */\n\t        Router.prototype.createUrlTree = function (commands, _a) {\n\t            var _b = _a === void 0 ? {} : _a, relativeTo = _b.relativeTo, queryParams = _b.queryParams, fragment = _b.fragment, preserveQueryParams = _b.preserveQueryParams, preserveFragment = _b.preserveFragment;\n\t            var a = relativeTo ? relativeTo : this.routerState.root;\n\t            var q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams;\n\t            var f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n\t            return createUrlTree(a, this.currentUrlTree, commands, q, f);\n\t        };\n\t        /**\n\t         * Navigate based on the provided url. This navigation is always absolute.\n\t         *\n\t         * Returns a promise that:\n\t         * - is resolved with 'true' when navigation succeeds\n\t         * - is resolved with 'false' when navigation fails\n\t         * - is rejected when an error happens\n\t         *\n\t         * ### Usage\n\t         *\n\t         * ```\n\t         * router.navigateByUrl(\"/team/33/user/11\");\n\t         *\n\t         * // Navigate without updating the URL\n\t         * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n\t         * ```\n\t         *\n\t         * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n\t         * and does not apply any delta to the current one.\n\t         */\n\t        Router.prototype.navigateByUrl = function (url, extras) {\n\t            if (extras === void 0) { extras = { skipLocationChange: false }; }\n\t            if (url instanceof UrlTree) {\n\t                return this.scheduleNavigation(url, extras);\n\t            }\n\t            else {\n\t                var urlTree = this.urlSerializer.parse(url);\n\t                return this.scheduleNavigation(urlTree, extras);\n\t            }\n\t        };\n\t        /**\n\t         * Navigate based on the provided array of commands and a starting point.\n\t         * If no starting route is provided, the navigation is absolute.\n\t         *\n\t         * Returns a promise that:\n\t         * - is resolved with 'true' when navigation succeeds\n\t         * - is resolved with 'false' when navigation fails\n\t         * - is rejected when an error happens\n\t         *\n\t         * ### Usage\n\t         *\n\t         * ```\n\t         * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n\t         *\n\t         * // Navigate without updating the URL\n\t         * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true });\n\t         * ```\n\t         *\n\t         * In opposite to `navigateByUrl`, `navigate` always takes a delta\n\t         * that is applied to the current URL.\n\t         */\n\t        Router.prototype.navigate = function (commands, extras) {\n\t            if (extras === void 0) { extras = { skipLocationChange: false }; }\n\t            return this.scheduleNavigation(this.createUrlTree(commands, extras), extras);\n\t        };\n\t        /**\n\t         * Serializes a {@link UrlTree} into a string.\n\t         */\n\t        Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };\n\t        /**\n\t         * Parses a string into a {@link UrlTree}.\n\t         */\n\t        Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };\n\t        /**\n\t         * Returns if the url is activated or not.\n\t         */\n\t        Router.prototype.isActive = function (url, exact) {\n\t            if (url instanceof UrlTree) {\n\t                return containsTree(this.currentUrlTree, url, exact);\n\t            }\n\t            else {\n\t                var urlTree = this.urlSerializer.parse(url);\n\t                return containsTree(this.currentUrlTree, urlTree, exact);\n\t            }\n\t        };\n\t        Router.prototype.scheduleNavigation = function (url, extras) {\n\t            var _this = this;\n\t            var id = ++this.navigationId;\n\t            this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n\t            return Promise.resolve().then(function (_) { return _this.runNavigate(url, extras.skipLocationChange, extras.replaceUrl, id); });\n\t        };\n\t        Router.prototype.runNavigate = function (url, shouldPreventPushState, shouldReplaceUrl, id) {\n\t            var _this = this;\n\t            if (id !== this.navigationId) {\n\t                this.location.go(this.urlSerializer.serialize(this.currentUrlTree));\n\t                this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \" + id + \" is not equal to the current navigation id \" + this.navigationId));\n\t                return Promise.resolve(false);\n\t            }\n\t            return new Promise(function (resolvePromise, rejectPromise) {\n\t                var state;\n\t                var navigationIsSuccessful;\n\t                var preActivation;\n\t                var appliedUrl;\n\t                var storedState = _this.currentRouterState;\n\t                var storedUrl = _this.currentUrlTree;\n\t                var redirectsApplied$ = applyRedirects(_this.injector, _this.configLoader, url, _this.config);\n\t                var snapshot$ = rxjs_operator_mergeMap.mergeMap.call(redirectsApplied$, function (u) {\n\t                    appliedUrl = u;\n\t                    return recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl));\n\t                });\n\t                var emitRecognzied$ = rxjs_operator_map.map.call(snapshot$, function (newRouterStateSnapshot) {\n\t                    _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), newRouterStateSnapshot));\n\t                    return newRouterStateSnapshot;\n\t                });\n\t                var routerState$ = rxjs_operator_map.map.call(emitRecognzied$, function (routerStateSnapshot) {\n\t                    return createRouterState(routerStateSnapshot, _this.currentRouterState);\n\t                });\n\t                var preactivation$ = rxjs_operator_map.map.call(routerState$, function (newState) {\n\t                    state = newState;\n\t                    preActivation =\n\t                        new PreActivation(state.snapshot, _this.currentRouterState.snapshot, _this.injector);\n\t                    preActivation.traverse(_this.outletMap);\n\t                });\n\t                var preactivation2$ = rxjs_operator_mergeMap.mergeMap.call(preactivation$, function () { return preActivation.checkGuards(); });\n\t                var resolveData$ = rxjs_operator_mergeMap.mergeMap.call(preactivation2$, function (shouldActivate) {\n\t                    if (shouldActivate) {\n\t                        return rxjs_operator_map.map.call(preActivation.resolveData(), function () { return shouldActivate; });\n\t                    }\n\t                    else {\n\t                        return rxjs_observable_of.of(shouldActivate);\n\t                    }\n\t                });\n\t                resolveData$\n\t                    .forEach(function (shouldActivate) {\n\t                    if (!shouldActivate || id !== _this.navigationId) {\n\t                        navigationIsSuccessful = false;\n\t                        return;\n\t                    }\n\t                    _this.currentUrlTree = appliedUrl;\n\t                    _this.currentRouterState = state;\n\t                    if (!shouldPreventPushState) {\n\t                        var path = _this.urlSerializer.serialize(appliedUrl);\n\t                        if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {\n\t                            _this.location.replaceState(path);\n\t                        }\n\t                        else {\n\t                            _this.location.go(path);\n\t                        }\n\t                    }\n\t                    new ActivateRoutes(state, storedState).activate(_this.outletMap);\n\t                    navigationIsSuccessful = true;\n\t                })\n\t                    .then(function () {\n\t                    _this.navigated = true;\n\t                    if (navigationIsSuccessful) {\n\t                        _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl)));\n\t                        resolvePromise(true);\n\t                    }\n\t                    else {\n\t                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));\n\t                        resolvePromise(false);\n\t                    }\n\t                }, function (e) {\n\t                    if (e instanceof NavigationCancelingError) {\n\t                        _this.navigated = true;\n\t                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));\n\t                        resolvePromise(false);\n\t                    }\n\t                    else {\n\t                        _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));\n\t                        try {\n\t                            resolvePromise(_this.errorHandler(e));\n\t                        }\n\t                        catch (ee) {\n\t                            rejectPromise(ee);\n\t                        }\n\t                    }\n\t                    if (id === _this.navigationId) {\n\t                        _this.currentRouterState = storedState;\n\t                        _this.currentUrlTree = storedUrl;\n\t                        _this.location.replaceState(_this.serializeUrl(storedUrl));\n\t                    }\n\t                });\n\t            });\n\t        };\n\t        return Router;\n\t    }());\n\t    var CanActivate = (function () {\n\t        function CanActivate(path) {\n\t            this.path = path;\n\t        }\n\t        Object.defineProperty(CanActivate.prototype, \"route\", {\n\t            get: function () { return this.path[this.path.length - 1]; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        return CanActivate;\n\t    }());\n\t    var CanDeactivate = (function () {\n\t        function CanDeactivate(component, route) {\n\t            this.component = component;\n\t            this.route = route;\n\t        }\n\t        return CanDeactivate;\n\t    }());\n\t    var PreActivation = (function () {\n\t        function PreActivation(future, curr, injector) {\n\t            this.future = future;\n\t            this.curr = curr;\n\t            this.injector = injector;\n\t            this.checks = [];\n\t        }\n\t        PreActivation.prototype.traverse = function (parentOutletMap) {\n\t            var futureRoot = this.future._root;\n\t            var currRoot = this.curr ? this.curr._root : null;\n\t            this.traverseChildRoutes(futureRoot, currRoot, parentOutletMap, [futureRoot.value]);\n\t        };\n\t        PreActivation.prototype.checkGuards = function () {\n\t            var _this = this;\n\t            if (this.checks.length === 0)\n\t                return rxjs_observable_of.of(true);\n\t            var checks$ = rxjs_observable_from.from(this.checks);\n\t            var runningChecks$ = rxjs_operator_map.map.call(checks$, function (s) {\n\t                if (s instanceof CanActivate) {\n\t                    return andObservables(rxjs_observable_from.from([_this.runCanActivateChild(s.path), _this.runCanActivate(s.route)]));\n\t                }\n\t                else if (s instanceof CanDeactivate) {\n\t                    // workaround https://github.com/Microsoft/TypeScript/issues/7271\n\t                    var s2 = s;\n\t                    return _this.runCanDeactivate(s2.component, s2.route);\n\t                }\n\t                else {\n\t                    throw new Error('Cannot be reached');\n\t                }\n\t            });\n\t            var mergedChecks$ = rxjs_operator_mergeAll.mergeAll.call(runningChecks$);\n\t            return rxjs_operator_every.every.call(mergedChecks$, function (result) { return result === true; });\n\t        };\n\t        PreActivation.prototype.resolveData = function () {\n\t            var _this = this;\n\t            if (this.checks.length === 0)\n\t                return rxjs_observable_of.of(null);\n\t            var checks$ = rxjs_observable_from.from(this.checks);\n\t            var runningChecks$ = rxjs_operator_concatMap.concatMap.call(checks$, function (s) {\n\t                if (s instanceof CanActivate) {\n\t                    return _this.runResolve(s.route);\n\t                }\n\t                else {\n\t                    return rxjs_observable_of.of(null);\n\t                }\n\t            });\n\t            return rxjs_operator_reduce.reduce.call(runningChecks$, function (_, __) { return _; });\n\t        };\n\t        PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, outletMap, futurePath) {\n\t            var _this = this;\n\t            var prevChildren = nodeChildrenAsMap(currNode);\n\t            futureNode.children.forEach(function (c) {\n\t                _this.traverseRoutes(c, prevChildren[c.value.outlet], outletMap, futurePath.concat([c.value]));\n\t                delete prevChildren[c.value.outlet];\n\t            });\n\t            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap._outlets[k]); });\n\t        };\n\t        PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentOutletMap, futurePath) {\n\t            var future = futureNode.value;\n\t            var curr = currNode ? currNode.value : null;\n\t            var outlet = parentOutletMap ? parentOutletMap._outlets[futureNode.value.outlet] : null;\n\t            // reusing the node\n\t            if (curr && future._routeConfig === curr._routeConfig) {\n\t                if (!shallowEqual(future.params, curr.params)) {\n\t                    this.checks.push(new CanDeactivate(outlet.component, curr), new CanActivate(futurePath));\n\t                }\n\t                else {\n\t                    // we need to set the data\n\t                    future.data = curr.data;\n\t                    future._resolvedData = curr._resolvedData;\n\t                }\n\t                // If we have a component, we need to go through an outlet.\n\t                if (future.component) {\n\t                    this.traverseChildRoutes(futureNode, currNode, outlet ? outlet.outletMap : null, futurePath);\n\t                }\n\t                else {\n\t                    this.traverseChildRoutes(futureNode, currNode, parentOutletMap, futurePath);\n\t                }\n\t            }\n\t            else {\n\t                if (curr) {\n\t                    this.deactiveRouteAndItsChildren(currNode, outlet);\n\t                }\n\t                this.checks.push(new CanActivate(futurePath));\n\t                // If we have a component, we need to go through an outlet.\n\t                if (future.component) {\n\t                    this.traverseChildRoutes(futureNode, null, outlet ? outlet.outletMap : null, futurePath);\n\t                }\n\t                else {\n\t                    this.traverseChildRoutes(futureNode, null, parentOutletMap, futurePath);\n\t                }\n\t            }\n\t        };\n\t        PreActivation.prototype.deactiveRouteAndItsChildren = function (route, outlet) {\n\t            var _this = this;\n\t            var prevChildren = nodeChildrenAsMap(route);\n\t            forEach(prevChildren, function (v, k) {\n\t                var childOutlet = outlet ? outlet.outletMap._outlets[k] : null;\n\t                _this.deactiveRouteAndItsChildren(v, childOutlet);\n\t            });\n\t            var component = outlet && outlet.isActivated ? outlet.component : null;\n\t            this.checks.push(new CanDeactivate(component, route.value));\n\t        };\n\t        PreActivation.prototype.runCanActivate = function (future) {\n\t            var _this = this;\n\t            var canActivate = future._routeConfig ? future._routeConfig.canActivate : null;\n\t            if (!canActivate || canActivate.length === 0)\n\t                return rxjs_observable_of.of(true);\n\t            var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canActivate), function (c) {\n\t                var guard = _this.getToken(c, future);\n\t                if (guard.canActivate) {\n\t                    return wrapIntoObservable(guard.canActivate(future, _this.future));\n\t                }\n\t                else {\n\t                    return wrapIntoObservable(guard(future, _this.future));\n\t                }\n\t            });\n\t            return andObservables(obs);\n\t        };\n\t        PreActivation.prototype.runCanActivateChild = function (path) {\n\t            var _this = this;\n\t            var future = path[path.length - 1];\n\t            var canActivateChildGuards = path.slice(0, path.length - 1)\n\t                .reverse()\n\t                .map(function (p) { return _this.extractCanActivateChild(p); })\n\t                .filter(function (_) { return _ !== null; });\n\t            return andObservables(rxjs_operator_map.map.call(rxjs_observable_from.from(canActivateChildGuards), function (d) {\n\t                var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(d.guards), function (c) {\n\t                    var guard = _this.getToken(c, c.node);\n\t                    if (guard.canActivateChild) {\n\t                        return wrapIntoObservable(guard.canActivateChild(future, _this.future));\n\t                    }\n\t                    else {\n\t                        return wrapIntoObservable(guard(future, _this.future));\n\t                    }\n\t                });\n\t                return andObservables(obs);\n\t            }));\n\t        };\n\t        PreActivation.prototype.extractCanActivateChild = function (p) {\n\t            var canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;\n\t            if (!canActivateChild || canActivateChild.length === 0)\n\t                return null;\n\t            return { node: p, guards: canActivateChild };\n\t        };\n\t        PreActivation.prototype.runCanDeactivate = function (component, curr) {\n\t            var _this = this;\n\t            var canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;\n\t            if (!canDeactivate || canDeactivate.length === 0)\n\t                return rxjs_observable_of.of(true);\n\t            var canDeactivate$ = rxjs_operator_map.map.call(rxjs_observable_from.from(canDeactivate), function (c) {\n\t                var guard = _this.getToken(c, curr);\n\t                if (guard.canDeactivate) {\n\t                    return wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr));\n\t                }\n\t                else {\n\t                    return wrapIntoObservable(guard(component, curr, _this.curr));\n\t                }\n\t            });\n\t            var merged$ = rxjs_operator_mergeAll.mergeAll.call(canDeactivate$);\n\t            return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });\n\t        };\n\t        PreActivation.prototype.runResolve = function (future) {\n\t            var resolve = future._resolve;\n\t            return rxjs_operator_map.map.call(this.resolveNode(resolve, future), function (resolvedData) {\n\t                future._resolvedData = resolvedData;\n\t                future.data = merge(future.data, inheritedParamsDataResolve(future).resolve);\n\t                return null;\n\t            });\n\t        };\n\t        PreActivation.prototype.resolveNode = function (resolve, future) {\n\t            var _this = this;\n\t            return waitForMap(resolve, function (k, v) {\n\t                var resolver = _this.getToken(v, future);\n\t                return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, _this.future)) :\n\t                    wrapIntoObservable(resolver(future, _this.future));\n\t            });\n\t        };\n\t        PreActivation.prototype.getToken = function (token, snapshot) {\n\t            var config = closestLoadedConfig(snapshot);\n\t            var injector = config ? config.injector : this.injector;\n\t            return injector.get(token);\n\t        };\n\t        return PreActivation;\n\t    }());\n\t    var ActivateRoutes = (function () {\n\t        function ActivateRoutes(futureState, currState) {\n\t            this.futureState = futureState;\n\t            this.currState = currState;\n\t        }\n\t        ActivateRoutes.prototype.activate = function (parentOutletMap) {\n\t            var futureRoot = this.futureState._root;\n\t            var currRoot = this.currState ? this.currState._root : null;\n\t            advanceActivatedRoute(this.futureState.root);\n\t            this.activateChildRoutes(futureRoot, currRoot, parentOutletMap);\n\t        };\n\t        ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, outletMap) {\n\t            var _this = this;\n\t            var prevChildren = nodeChildrenAsMap(currNode);\n\t            futureNode.children.forEach(function (c) {\n\t                _this.activateRoutes(c, prevChildren[c.value.outlet], outletMap);\n\t                delete prevChildren[c.value.outlet];\n\t            });\n\t            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap); });\n\t        };\n\t        ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentOutletMap) {\n\t            var future = futureNode.value;\n\t            var curr = currNode ? currNode.value : null;\n\t            // reusing the node\n\t            if (future === curr) {\n\t                // advance the route to push the parameters\n\t                advanceActivatedRoute(future);\n\t                // If we have a normal route, we need to go through an outlet.\n\t                if (future.component) {\n\t                    var outlet = getOutlet(parentOutletMap, future);\n\t                    this.activateChildRoutes(futureNode, currNode, outlet.outletMap);\n\t                }\n\t                else {\n\t                    this.activateChildRoutes(futureNode, currNode, parentOutletMap);\n\t                }\n\t            }\n\t            else {\n\t                if (curr) {\n\t                    this.deactiveRouteAndItsChildren(currNode, parentOutletMap);\n\t                }\n\t                // if we have a normal route, we need to advance the route\n\t                // and place the component into the outlet. After that recurse.\n\t                if (future.component) {\n\t                    advanceActivatedRoute(future);\n\t                    var outlet = getOutlet(parentOutletMap, futureNode.value);\n\t                    var outletMap = new RouterOutletMap();\n\t                    this.placeComponentIntoOutlet(outletMap, future, outlet);\n\t                    this.activateChildRoutes(futureNode, null, outletMap);\n\t                }\n\t                else {\n\t                    advanceActivatedRoute(future);\n\t                    this.activateChildRoutes(futureNode, null, parentOutletMap);\n\t                }\n\t            }\n\t        };\n\t        ActivateRoutes.prototype.placeComponentIntoOutlet = function (outletMap, future, outlet) {\n\t            var resolved = [{ provide: ActivatedRoute, useValue: future }, {\n\t                    provide: RouterOutletMap,\n\t                    useValue: outletMap\n\t                }];\n\t            var config = parentLoadedConfig(future.snapshot);\n\t            var loadedFactoryResolver = null;\n\t            var loadedInjector = null;\n\t            if (config) {\n\t                loadedFactoryResolver = config.factoryResolver;\n\t                loadedInjector = config.injector;\n\t                resolved.push({ provide: _angular_core.ComponentFactoryResolver, useValue: loadedFactoryResolver });\n\t            }\n\t            outlet.activate(future, loadedFactoryResolver, loadedInjector, _angular_core.ReflectiveInjector.resolve(resolved), outletMap);\n\t        };\n\t        ActivateRoutes.prototype.deactiveRouteAndItsChildren = function (route, parentOutletMap) {\n\t            var _this = this;\n\t            var prevChildren = nodeChildrenAsMap(route);\n\t            var outlet = null;\n\t            // getOutlet throws when cannot find the right outlet,\n\t            // which can happen if an outlet was in an NgIf and was removed\n\t            try {\n\t                outlet = getOutlet(parentOutletMap, route.value);\n\t            }\n\t            catch (e) {\n\t                return;\n\t            }\n\t            var childOutletMap = outlet.outletMap;\n\t            forEach(prevChildren, function (v, k) {\n\t                if (route.value.component) {\n\t                    _this.deactiveRouteAndItsChildren(v, childOutletMap);\n\t                }\n\t                else {\n\t                    _this.deactiveRouteAndItsChildren(v, parentOutletMap);\n\t                }\n\t            });\n\t            if (outlet && outlet.isActivated) {\n\t                outlet.deactivate();\n\t            }\n\t        };\n\t        return ActivateRoutes;\n\t    }());\n\t    function parentLoadedConfig(snapshot) {\n\t        var s = snapshot.parent;\n\t        while (s) {\n\t            var c = s._routeConfig;\n\t            if (c && c._loadedConfig)\n\t                return c._loadedConfig;\n\t            if (c && c.component)\n\t                return null;\n\t            s = s.parent;\n\t        }\n\t        return null;\n\t    }\n\t    function closestLoadedConfig(snapshot) {\n\t        if (!snapshot)\n\t            return null;\n\t        var s = snapshot.parent;\n\t        while (s) {\n\t            var c = s._routeConfig;\n\t            if (c && c._loadedConfig)\n\t                return c._loadedConfig;\n\t            s = s.parent;\n\t        }\n\t        return null;\n\t    }\n\t    function nodeChildrenAsMap(node) {\n\t        return node ? node.children.reduce(function (m, c) {\n\t            m[c.value.outlet] = c;\n\t            return m;\n\t        }, {}) : {};\n\t    }\n\t    function getOutlet(outletMap, route) {\n\t        var outlet = outletMap._outlets[route.outlet];\n\t        if (!outlet) {\n\t            var componentName = route.component.name;\n\t            if (route.outlet === PRIMARY_OUTLET) {\n\t                throw new Error(\"Cannot find primary outlet to load '\" + componentName + \"'\");\n\t            }\n\t            else {\n\t                throw new Error(\"Cannot find the outlet \" + route.outlet + \" to load '\" + componentName + \"'\");\n\t            }\n\t        }\n\t        return outlet;\n\t    }\n\t\n\t    /**\n\t     * @whatItDoes Lets you link to specific parts of your app.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * Consider the following route configuration:\n\t\n\t     * ```\n\t     * [{ path: 'user/:name', component: UserCmp }]\n\t     * ```\n\t     *\n\t     * When linking to this `user/:name` route, you can write:\n\t     *\n\t     * ```\n\t     * <a routerLink='/user/bob'>link to user component</a>\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * The RouterLink directives let you link to specific parts of your app.\n\t     *\n\t     * Whe the link is static, you can use the directive as follows:\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\">link to user component</a>\n\t     * ```\n\t     *\n\t     * If you use dynamic values to generate the link, you can pass an array of path\n\t     * segments, followed by the params for each segment.\n\t     *\n\t     * For instance `['/team', teamId, 'user', userName, {details: true}]`\n\t     * means that we want to generate a link to `/team/11/user/bob;details=true`.\n\t     *\n\t     * Multiple static segments can be merged into one (e.g., `['/team/11/user', userName, {details:\n\t     true}]`).\n\t     *\n\t     * The first segment name can be prepended with `/`, `./`, or `../`:\n\t     * * If the first segment begins with `/`, the router will look up the route from the root of the\n\t     app.\n\t     * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n\t     * instead look in the children of the current activated route.\n\t     * * And if the first segment begins with `../`, the router will go up one level.\n\t     *\n\t     * You can set query params and fragment as follows:\n\t     *\n\t     * ```\n\t     * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">link to user\n\t     component</a>\n\t     * ```\n\t     * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n\t     *\n\t     * You can also tell the directive to preserve the current query params and fragment:\n\t     *\n\t     * ```\n\t     * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>link to user\n\t     component</a>\n\t     * ```\n\t     *\n\t     * The router link directive always treats the provided input as a delta to the current url.\n\t     *\n\t     * For instance, if the current url is `/user/(box//aux:team)`.\n\t     *\n\t     * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n\t     * `/user/(jim//aux:team)`.\n\t     *\n\t     * @selector ':not(a)[routerLink]'\n\t     * @ngModule RouterModule\n\t     *\n\t     * See {@link Router.createUrlTree} for more information.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterLink = (function () {\n\t        function RouterLink(router, route, locationStrategy) {\n\t            this.router = router;\n\t            this.route = route;\n\t            this.locationStrategy = locationStrategy;\n\t            this.commands = [];\n\t        }\n\t        Object.defineProperty(RouterLink.prototype, \"routerLink\", {\n\t            set: function (data) {\n\t                if (Array.isArray(data)) {\n\t                    this.commands = data;\n\t                }\n\t                else {\n\t                    this.commands = [data];\n\t                }\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLink.prototype.onClick = function (button, ctrlKey, metaKey) {\n\t            if (button !== 0 || ctrlKey || metaKey) {\n\t                return true;\n\t            }\n\t            this.router.navigateByUrl(this.urlTree);\n\t            return false;\n\t        };\n\t        Object.defineProperty(RouterLink.prototype, \"urlTree\", {\n\t            get: function () {\n\t                return this.router.createUrlTree(this.commands, {\n\t                    relativeTo: this.route,\n\t                    queryParams: this.queryParams,\n\t                    fragment: this.fragment,\n\t                    preserveQueryParams: toBool(this.preserveQueryParams),\n\t                    preserveFragment: toBool(this.preserveFragment)\n\t                });\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLink.decorators = [\n\t            { type: _angular_core.Directive, args: [{ selector: ':not(a)[routerLink]' },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterLink.ctorParameters = [\n\t            { type: Router, },\n\t            { type: ActivatedRoute, },\n\t            { type: _angular_common.LocationStrategy, },\n\t        ];\n\t        RouterLink.propDecorators = {\n\t            'queryParams': [{ type: _angular_core.Input },],\n\t            'fragment': [{ type: _angular_core.Input },],\n\t            'preserveQueryParams': [{ type: _angular_core.Input },],\n\t            'preserveFragment': [{ type: _angular_core.Input },],\n\t            'routerLink': [{ type: _angular_core.Input },],\n\t            'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey'],] },],\n\t        };\n\t        return RouterLink;\n\t    }());\n\t    /**\n\t     * @whatItDoes Lets you link to specific parts of your app.\n\t     *\n\t     * See {@link RouterLink} for more information.\n\t     *\n\t     * @selector 'a[routerLink]'\n\t     * @ngModule RouterModule\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterLinkWithHref = (function () {\n\t        function RouterLinkWithHref(router, route, locationStrategy) {\n\t            var _this = this;\n\t            this.router = router;\n\t            this.route = route;\n\t            this.locationStrategy = locationStrategy;\n\t            this.commands = [];\n\t            this.subscription = router.events.subscribe(function (s) {\n\t                if (s instanceof NavigationEnd) {\n\t                    _this.updateTargetUrlAndHref();\n\t                }\n\t            });\n\t        }\n\t        Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\n\t            set: function (data) {\n\t                if (Array.isArray(data)) {\n\t                    this.commands = data;\n\t                }\n\t                else {\n\t                    this.commands = [data];\n\t                }\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };\n\t        RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n\t        RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey) {\n\t            if (button !== 0 || ctrlKey || metaKey) {\n\t                return true;\n\t            }\n\t            if (typeof this.target === 'string' && this.target != '_self') {\n\t                return true;\n\t            }\n\t            this.router.navigateByUrl(this.urlTree);\n\t            return false;\n\t        };\n\t        RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {\n\t            this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n\t        };\n\t        Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\n\t            get: function () {\n\t                return this.router.createUrlTree(this.commands, {\n\t                    relativeTo: this.route,\n\t                    queryParams: this.queryParams,\n\t                    fragment: this.fragment,\n\t                    preserveQueryParams: toBool(this.preserveQueryParams),\n\t                    preserveFragment: toBool(this.preserveFragment)\n\t                });\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLinkWithHref.decorators = [\n\t            { type: _angular_core.Directive, args: [{ selector: 'a[routerLink]' },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterLinkWithHref.ctorParameters = [\n\t            { type: Router, },\n\t            { type: ActivatedRoute, },\n\t            { type: _angular_common.LocationStrategy, },\n\t        ];\n\t        RouterLinkWithHref.propDecorators = {\n\t            'target': [{ type: _angular_core.Input },],\n\t            'queryParams': [{ type: _angular_core.Input },],\n\t            'fragment': [{ type: _angular_core.Input },],\n\t            'routerLinkOptions': [{ type: _angular_core.Input },],\n\t            'preserveQueryParams': [{ type: _angular_core.Input },],\n\t            'preserveFragment': [{ type: _angular_core.Input },],\n\t            'href': [{ type: _angular_core.HostBinding },],\n\t            'routerLink': [{ type: _angular_core.Input },],\n\t            'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey'],] },],\n\t        };\n\t        return RouterLinkWithHref;\n\t    }());\n\t    function toBool(s) {\n\t        if (s === '')\n\t            return true;\n\t        return !!s;\n\t    }\n\t\n\t    /**\n\t     * @whatItDoes Lets you add a CSS class to an element when the link's route becomes active.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n\t     * becomes active.\n\t     *\n\t     * Consider the following example:\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n\t     * ```\n\t     *\n\t     * When the url is either '/user' or '/user/bob', the active-link class will\n\t     * be added to the `a` tag. If the url changes, the class will be removed.\n\t     *\n\t     * You can set more than one class, as follows:\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n\t     * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n\t     * ```\n\t     *\n\t     * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n\t     * only when the url matches the link exactly.\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n\t     * true}\">Bob</a>\n\t     * ```\n\t     *\n\t     * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n\t     *\n\t     * ```\n\t     * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n\t     *   <a routerLink=\"/user/jim\">Jim</a>\n\t     *   <a routerLink=\"/user/bob\">Bob</a>\n\t     * </div>\n\t     * ```\n\t     *\n\t     * This will set the active-link class on the div tag if the url is either '/user/jim' or\n\t     * '/user/bob'.\n\t     *\n\t     * @selector ':not(a)[routerLink]'\n\t     * @ngModule RouterModule\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterLinkActive = (function () {\n\t        function RouterLinkActive(router, element, renderer) {\n\t            var _this = this;\n\t            this.router = router;\n\t            this.element = element;\n\t            this.renderer = renderer;\n\t            this.classes = [];\n\t            this.routerLinkActiveOptions = { exact: false };\n\t            this.subscription = router.events.subscribe(function (s) {\n\t                if (s instanceof NavigationEnd) {\n\t                    _this.update();\n\t                }\n\t            });\n\t        }\n\t        RouterLinkActive.prototype.ngAfterContentInit = function () {\n\t            var _this = this;\n\t            this.links.changes.subscribe(function (s) { return _this.update(); });\n\t            this.linksWithHrefs.changes.subscribe(function (s) { return _this.update(); });\n\t            this.update();\n\t        };\n\t        Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\n\t            set: function (data) {\n\t                if (Array.isArray(data)) {\n\t                    this.classes = data;\n\t                }\n\t                else {\n\t                    this.classes = data.split(' ');\n\t                }\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };\n\t        RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n\t        RouterLinkActive.prototype.update = function () {\n\t            var _this = this;\n\t            if (!this.links || !this.linksWithHrefs || !this.router.navigated)\n\t                return;\n\t            var isActive = this.hasActiveLink();\n\t            this.classes.forEach(function (c) { return _this.renderer.setElementClass(_this.element.nativeElement, c, isActive); });\n\t        };\n\t        RouterLinkActive.prototype.isLinkActive = function (router) {\n\t            var _this = this;\n\t            return function (link) {\n\t                return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\n\t            };\n\t        };\n\t        RouterLinkActive.prototype.hasActiveLink = function () {\n\t            return this.links.some(this.isLinkActive(this.router)) ||\n\t                this.linksWithHrefs.some(this.isLinkActive(this.router));\n\t        };\n\t        RouterLinkActive.decorators = [\n\t            { type: _angular_core.Directive, args: [{ selector: '[routerLinkActive]' },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterLinkActive.ctorParameters = [\n\t            { type: Router, },\n\t            { type: _angular_core.ElementRef, },\n\t            { type: _angular_core.Renderer, },\n\t        ];\n\t        RouterLinkActive.propDecorators = {\n\t            'links': [{ type: _angular_core.ContentChildren, args: [RouterLink, { descendants: true },] },],\n\t            'linksWithHrefs': [{ type: _angular_core.ContentChildren, args: [RouterLinkWithHref, { descendants: true },] },],\n\t            'routerLinkActiveOptions': [{ type: _angular_core.Input },],\n\t            'routerLinkActive': [{ type: _angular_core.Input },],\n\t        };\n\t        return RouterLinkActive;\n\t    }());\n\t\n\t    /**\n\t     * @whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router\n\t     * state.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * <router-outlet></router-outlet>\n\t     * <router-outlet name='left'></router-outlet>\n\t     * <router-outlet name='right'></router-outlet>\n\t     * ```\n\t     *\n\t     * A router outlet will emit an activate event any time a new component is being instantiated,\n\t     * and a deactivate event when it is being destroyed.\n\t     *\n\t     * ```\n\t     * <router-outlet\n\t     *   (activate)='onActivate($event)'\n\t     *   (deactivate)='onDeactivate($event)'></router-outlet>\n\t     * ```\n\t     * @selector 'a[routerLink]'\n\t     * @ngModule RouterModule\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterOutlet = (function () {\n\t        function RouterOutlet(parentOutletMap, location, resolver, name) {\n\t            this.parentOutletMap = parentOutletMap;\n\t            this.location = location;\n\t            this.resolver = resolver;\n\t            this.name = name;\n\t            this.activateEvents = new _angular_core.EventEmitter();\n\t            this.deactivateEvents = new _angular_core.EventEmitter();\n\t            parentOutletMap.registerOutlet(name ? name : PRIMARY_OUTLET, this);\n\t        }\n\t        RouterOutlet.prototype.ngOnDestroy = function () { this.parentOutletMap.removeOutlet(this.name ? this.name : PRIMARY_OUTLET); };\n\t        Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\n\t            get: function () { return !!this.activated; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(RouterOutlet.prototype, \"component\", {\n\t            get: function () {\n\t                if (!this.activated)\n\t                    throw new Error('Outlet is not activated');\n\t                return this.activated.instance;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\n\t            get: function () {\n\t                if (!this.activated)\n\t                    throw new Error('Outlet is not activated');\n\t                return this._activatedRoute;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterOutlet.prototype.deactivate = function () {\n\t            if (this.activated) {\n\t                var c = this.component;\n\t                this.activated.destroy();\n\t                this.activated = null;\n\t                this.deactivateEvents.emit(c);\n\t            }\n\t        };\n\t        RouterOutlet.prototype.activate = function (activatedRoute, loadedResolver, loadedInjector, providers, outletMap) {\n\t            if (this.isActivated) {\n\t                throw new Error('Cannot activate an already activated outlet');\n\t            }\n\t            this.outletMap = outletMap;\n\t            this._activatedRoute = activatedRoute;\n\t            var snapshot = activatedRoute._futureSnapshot;\n\t            var component = snapshot._routeConfig.component;\n\t            var factory;\n\t            if (loadedResolver) {\n\t                factory = loadedResolver.resolveComponentFactory(component);\n\t            }\n\t            else {\n\t                factory = this.resolver.resolveComponentFactory(component);\n\t            }\n\t            var injector = loadedInjector ? loadedInjector : this.location.parentInjector;\n\t            var inj = _angular_core.ReflectiveInjector.fromResolvedProviders(providers, injector);\n\t            this.activated = this.location.createComponent(factory, this.location.length, inj, []);\n\t            this.activated.changeDetectorRef.detectChanges();\n\t            this.activateEvents.emit(this.activated.instance);\n\t        };\n\t        RouterOutlet.decorators = [\n\t            { type: _angular_core.Directive, args: [{ selector: 'router-outlet' },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterOutlet.ctorParameters = [\n\t            { type: RouterOutletMap, },\n\t            { type: _angular_core.ViewContainerRef, },\n\t            { type: _angular_core.ComponentFactoryResolver, },\n\t            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['name',] },] },\n\t        ];\n\t        RouterOutlet.propDecorators = {\n\t            'activateEvents': [{ type: _angular_core.Output, args: ['activate',] },],\n\t            'deactivateEvents': [{ type: _angular_core.Output, args: ['deactivate',] },],\n\t        };\n\t        return RouterOutlet;\n\t    }());\n\t\n\t    /**\n\t     * @whatItDoes Provides a preloading strategy.\n\t     *\n\t     * @experimental\n\t     */\n\t    var PreloadingStrategy = (function () {\n\t        function PreloadingStrategy() {\n\t        }\n\t        return PreloadingStrategy;\n\t    }());\n\t    /**\n\t     * @whatItDoes Provides a preloading strategy that preloads all modules as quicky as possible.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n\t     * ```\n\t     *\n\t     * @experimental\n\t     */\n\t    var PreloadAllModules = (function () {\n\t        function PreloadAllModules() {\n\t        }\n\t        PreloadAllModules.prototype.preload = function (route, fn) {\n\t            return rxjs_operator_catch._catch.call(fn(), function () { return rxjs_observable_of.of(null); });\n\t        };\n\t        return PreloadAllModules;\n\t    }());\n\t    /**\n\t     * @whatItDoes Provides a preloading strategy that does not preload any modules.\n\t     *\n\t     * @description\n\t     *\n\t     * This strategy is enabled by default.\n\t     *\n\t     * @experimental\n\t     */\n\t    var NoPreloading = (function () {\n\t        function NoPreloading() {\n\t        }\n\t        NoPreloading.prototype.preload = function (route, fn) { return rxjs_observable_of.of(null); };\n\t        return NoPreloading;\n\t    }());\n\t    /**\n\t     * The preloader optimistically loads all router configurations to\n\t     * make navigations into lazily-loaded sections of the application faster.\n\t     *\n\t     * The preloader runs in the background. When the router bootstraps, the preloader\n\t     * starts listening to all navigation events. After every such event, the preloader\n\t     * will check if any configurations can be loaded lazily.\n\t     *\n\t     * If a route is protected by `canLoad` guards, the preloaded will not load it.\n\t     */\n\t    var RouterPreloader = (function () {\n\t        function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n\t            this.router = router;\n\t            this.injector = injector;\n\t            this.preloadingStrategy = preloadingStrategy;\n\t            this.loader = new RouterConfigLoader(moduleLoader, compiler);\n\t        }\n\t        ;\n\t        RouterPreloader.prototype.setUpPreloading = function () {\n\t            var _this = this;\n\t            var navigations = rxjs_operator_filter.filter.call(this.router.events, function (e) { return e instanceof NavigationEnd; });\n\t            this.subscription = rxjs_operator_concatMap.concatMap.call(navigations, function () { return _this.preload(); }).subscribe(function (v) { });\n\t        };\n\t        RouterPreloader.prototype.preload = function () { return this.processRoutes(this.injector, this.router.config); };\n\t        RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n\t        RouterPreloader.prototype.processRoutes = function (injector, routes) {\n\t            var res = [];\n\t            for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n\t                var c = routes_1[_i];\n\t                // we already have the config loaded, just recurce\n\t                if (c.loadChildren && !c.canLoad && c._loadedConfig) {\n\t                    var childConfig = c._loadedConfig;\n\t                    res.push(this.processRoutes(childConfig.injector, childConfig.routes));\n\t                }\n\t                else if (c.loadChildren && !c.canLoad) {\n\t                    res.push(this.preloadConfig(injector, c));\n\t                }\n\t                else if (c.children) {\n\t                    res.push(this.processRoutes(injector, c.children));\n\t                }\n\t            }\n\t            return rxjs_operator_mergeAll.mergeAll.call(rxjs_observable_from.from(res));\n\t        };\n\t        RouterPreloader.prototype.preloadConfig = function (injector, route) {\n\t            var _this = this;\n\t            return this.preloadingStrategy.preload(route, function () {\n\t                var loaded = _this.loader.load(injector, route.loadChildren);\n\t                return rxjs_operator_mergeMap.mergeMap.call(loaded, function (config) {\n\t                    var c = route;\n\t                    c._loadedConfig = config;\n\t                    return _this.processRoutes(config.injector, config.routes);\n\t                });\n\t            });\n\t        };\n\t        RouterPreloader.decorators = [\n\t            { type: _angular_core.Injectable },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterPreloader.ctorParameters = [\n\t            { type: Router, },\n\t            { type: _angular_core.NgModuleFactoryLoader, },\n\t            { type: _angular_core.Compiler, },\n\t            { type: _angular_core.Injector, },\n\t            { type: PreloadingStrategy, },\n\t        ];\n\t        return RouterPreloader;\n\t    }());\n\t\n\t    /**\n\t     * @whatItDoes Contains a list of directives\n\t     * @stable\n\t     */\n\t    var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n\t    /**\n\t     * @whatItDoes Is used in DI to configure the router.\n\t     * @stable\n\t     */\n\t    var ROUTER_CONFIGURATION = new _angular_core.OpaqueToken('ROUTER_CONFIGURATION');\n\t    /**\n\t     * @docsNotRequired\n\t     */\n\t    var ROUTER_FORROOT_GUARD = new _angular_core.OpaqueToken('ROUTER_FORROOT_GUARD');\n\t    var ROUTER_PROVIDERS = [\n\t        _angular_common.Location, { provide: UrlSerializer, useClass: DefaultUrlSerializer }, {\n\t            provide: Router,\n\t            useFactory: setupRouter,\n\t            deps: [\n\t                _angular_core.ApplicationRef, UrlSerializer, RouterOutletMap, _angular_common.Location, _angular_core.Injector, _angular_core.NgModuleFactoryLoader,\n\t                _angular_core.Compiler, ROUTES, ROUTER_CONFIGURATION\n\t            ]\n\t        },\n\t        RouterOutletMap, { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n\t        { provide: _angular_core.NgModuleFactoryLoader, useClass: _angular_core.SystemJsNgModuleLoader }, RouterPreloader, NoPreloading,\n\t        PreloadAllModules, { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } }\n\t    ];\n\t    /**\n\t     * @whatItDoes Adds router directives and providers.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n\t     * Since the router deals with a global shared resource--location, we cannot have\n\t     * more than one router service active.\n\t     *\n\t     * That is why there are two ways to create the module: `RouterModule.forRoot` and\n\t     * `RouterModule.forChild`.\n\t     *\n\t     * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n\t     * service itself.\n\t     * * `forChild` creates a module that contains all the directives and the given routes, but does not\n\t     * include\n\t     * the router service.\n\t     *\n\t     * When registered at the root, the module should be used as follows\n\t     *\n\t     * ```\n\t     * @NgModule({\n\t     *   imports: [RouterModule.forRoot(ROUTES)]\n\t     * })\n\t     * class MyNgModule {}\n\t     * ```\n\t     *\n\t     * For submodules and lazy loaded submodules the module should be used as follows:\n\t     *\n\t     * ```\n\t     * @NgModule({\n\t     *   imports: [RouterModule.forChild(ROUTES)]\n\t     * })\n\t     * class MyNgModule {}\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * Managing state transitions is one of the hardest parts of building applications. This is\n\t     * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n\t     * In addition, we often want to split applications into multiple bundles and load them on demand.\n\t     * Doing this transparently is not trivial.\n\t     *\n\t     * The Angular 2 router solves these problems. Using the router, you can declaratively specify\n\t     * application states, manage state transitions while taking care of the URL, and load bundles on\n\t     * demand.\n\t     *\n\t     * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n\t     * overview of how the router should be used.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterModule = (function () {\n\t        function RouterModule(guard) {\n\t        }\n\t        /**\n\t         * Creates a module with all the router providers and directives. It also optionally sets up an\n\t         * application listener to perform an initial navigation.\n\t         *\n\t         * Options:\n\t         * * `enableTracing` makes the router log all its internal events to the console.\n\t         * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n\t         * API.\n\t         * * `initialNavigation` disables the initial navigation.\n\t         * * `errorHandler` provides a custom error handler.\n\t         */\n\t        RouterModule.forRoot = function (routes, config) {\n\t            return {\n\t                ngModule: RouterModule,\n\t                providers: [\n\t                    ROUTER_PROVIDERS, provideRoutes(routes), {\n\t                        provide: ROUTER_FORROOT_GUARD,\n\t                        useFactory: provideForRootGuard,\n\t                        deps: [[Router, new _angular_core.Optional(), new _angular_core.SkipSelf()]]\n\t                    },\n\t                    { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} }, {\n\t                        provide: _angular_common.LocationStrategy,\n\t                        useFactory: provideLocationStrategy,\n\t                        deps: [\n\t                            _angular_common.PlatformLocation, [new _angular_core.Inject(_angular_common.APP_BASE_HREF), new _angular_core.Optional()], ROUTER_CONFIGURATION\n\t                        ]\n\t                    },\n\t                    {\n\t                        provide: PreloadingStrategy,\n\t                        useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n\t                            NoPreloading\n\t                    },\n\t                    provideRouterInitializer()\n\t                ]\n\t            };\n\t        };\n\t        /**\n\t         * Creates a module with all the router directives and a provider registering routes.\n\t         */\n\t        RouterModule.forChild = function (routes) {\n\t            return { ngModule: RouterModule, providers: [provideRoutes(routes)] };\n\t        };\n\t        RouterModule.decorators = [\n\t            { type: _angular_core.NgModule, args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterModule.ctorParameters = [\n\t            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [ROUTER_FORROOT_GUARD,] },] },\n\t        ];\n\t        return RouterModule;\n\t    }());\n\t    function provideLocationStrategy(platformLocationStrategy, baseHref, options) {\n\t        if (options === void 0) { options = {}; }\n\t        return options.useHash ? new _angular_common.HashLocationStrategy(platformLocationStrategy, baseHref) :\n\t            new _angular_common.PathLocationStrategy(platformLocationStrategy, baseHref);\n\t    }\n\t    function provideForRootGuard(router) {\n\t        if (router) {\n\t            throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n\t        }\n\t        return 'guarded';\n\t    }\n\t    /**\n\t     * @whatItDoes Registers routes.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @NgModule({\n\t     *   imports: [RouterModule.forChild(ROUTES)],\n\t     *   providers: [provideRoutes(EXTRA_ROUTES)]\n\t     * })\n\t     * class MyNgModule {}\n\t     * ```\n\t     *\n\t     * @stable\n\t     */\n\t    function provideRoutes(routes) {\n\t        return [\n\t            { provide: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },\n\t            { provide: ROUTES, multi: true, useValue: routes }\n\t        ];\n\t    }\n\t    function setupRouter(ref, urlSerializer, outletMap, location, injector, loader, compiler, config, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        var r = new Router(null, urlSerializer, outletMap, location, injector, loader, compiler, flatten(config));\n\t        if (opts.errorHandler) {\n\t            r.errorHandler = opts.errorHandler;\n\t        }\n\t        if (opts.enableTracing) {\n\t            r.events.subscribe(function (e) {\n\t                console.group(\"Router Event: \" + e.constructor.name);\n\t                console.log(e.toString());\n\t                console.log(e);\n\t                console.groupEnd();\n\t            });\n\t        }\n\t        return r;\n\t    }\n\t    function rootRoute(router) {\n\t        return router.routerState.root;\n\t    }\n\t    function initialRouterNavigation(router, ref, preloader, opts) {\n\t        return function () {\n\t            router.resetRootComponentType(ref.componentTypes[0]);\n\t            preloader.setUpPreloading();\n\t            if (opts.initialNavigation === false) {\n\t                router.setUpLocationChangeListener();\n\t            }\n\t            else {\n\t                router.initialNavigation();\n\t            }\n\t        };\n\t    }\n\t    function provideRouterInitializer() {\n\t        return {\n\t            provide: _angular_core.APP_BOOTSTRAP_LISTENER,\n\t            multi: true,\n\t            useFactory: initialRouterNavigation,\n\t            deps: [Router, _angular_core.ApplicationRef, RouterPreloader, ROUTER_CONFIGURATION]\n\t        };\n\t    }\n\t\n\t    var __router_private__ = {\n\t        ROUTER_PROVIDERS: ROUTER_PROVIDERS,\n\t        ROUTES: ROUTES,\n\t        flatten: flatten\n\t    };\n\t\n\t    exports.RouterLink = RouterLink;\n\t    exports.RouterLinkWithHref = RouterLinkWithHref;\n\t    exports.RouterLinkActive = RouterLinkActive;\n\t    exports.RouterOutlet = RouterOutlet;\n\t    exports.NavigationCancel = NavigationCancel;\n\t    exports.NavigationEnd = NavigationEnd;\n\t    exports.NavigationError = NavigationError;\n\t    exports.NavigationStart = NavigationStart;\n\t    exports.Router = Router;\n\t    exports.RoutesRecognized = RoutesRecognized;\n\t    exports.RouterModule = RouterModule;\n\t    exports.provideRoutes = provideRoutes;\n\t    exports.RouterOutletMap = RouterOutletMap;\n\t    exports.NoPreloading = NoPreloading;\n\t    exports.PreloadAllModules = PreloadAllModules;\n\t    exports.PreloadingStrategy = PreloadingStrategy;\n\t    exports.ActivatedRoute = ActivatedRoute;\n\t    exports.ActivatedRouteSnapshot = ActivatedRouteSnapshot;\n\t    exports.RouterState = RouterState;\n\t    exports.RouterStateSnapshot = RouterStateSnapshot;\n\t    exports.PRIMARY_OUTLET = PRIMARY_OUTLET;\n\t    exports.DefaultUrlSerializer = DefaultUrlSerializer;\n\t    exports.UrlSegment = UrlSegment;\n\t    exports.UrlSerializer = UrlSerializer;\n\t    exports.UrlTree = UrlTree;\n\t    exports.__router_private__ = __router_private__;\n\t\n\t}));\n\n\n/***/ },\n\n/***/ 144:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subject_1 = __webpack_require__(45);\n\tvar ObjectUnsubscribedError_1 = __webpack_require__(93);\n\t/**\n\t * @class BehaviorSubject<T>\n\t */\n\tvar BehaviorSubject = (function (_super) {\n\t    __extends(BehaviorSubject, _super);\n\t    function BehaviorSubject(_value) {\n\t        _super.call(this);\n\t        this._value = _value;\n\t    }\n\t    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n\t        get: function () {\n\t            return this.getValue();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    BehaviorSubject.prototype._subscribe = function (subscriber) {\n\t        var subscription = _super.prototype._subscribe.call(this, subscriber);\n\t        if (subscription && !subscription.closed) {\n\t            subscriber.next(this._value);\n\t        }\n\t        return subscription;\n\t    };\n\t    BehaviorSubject.prototype.getValue = function () {\n\t        if (this.hasError) {\n\t            throw this.thrownError;\n\t        }\n\t        else if (this.closed) {\n\t            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n\t        }\n\t        else {\n\t            return this._value;\n\t        }\n\t    };\n\t    BehaviorSubject.prototype.next = function (value) {\n\t        _super.prototype.next.call(this, this._value = value);\n\t    };\n\t    return BehaviorSubject;\n\t}(Subject_1.Subject));\n\texports.BehaviorSubject = BehaviorSubject;\n\t//# sourceMappingURL=BehaviorSubject.js.map\n\n/***/ },\n\n/***/ 145:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar InnerSubscriber = (function (_super) {\n\t    __extends(InnerSubscriber, _super);\n\t    function InnerSubscriber(parent, outerValue, outerIndex) {\n\t        _super.call(this);\n\t        this.parent = parent;\n\t        this.outerValue = outerValue;\n\t        this.outerIndex = outerIndex;\n\t        this.index = 0;\n\t    }\n\t    InnerSubscriber.prototype._next = function (value) {\n\t        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n\t    };\n\t    InnerSubscriber.prototype._error = function (error) {\n\t        this.parent.notifyError(error, this);\n\t        this.unsubscribe();\n\t    };\n\t    InnerSubscriber.prototype._complete = function () {\n\t        this.parent.notifyComplete(this);\n\t        this.unsubscribe();\n\t    };\n\t    return InnerSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.InnerSubscriber = InnerSubscriber;\n\t//# sourceMappingURL=InnerSubscriber.js.map\n\n/***/ },\n\n/***/ 146:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(11);\n\t/**\n\t * Represents a push-based event or value that an {@link Observable} can emit.\n\t * This class is particularly useful for operators that manage notifications,\n\t * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n\t * others. Besides wrapping the actual delivered value, it also annotates it\n\t * with metadata of, for instance, what type of push message it is (`next`,\n\t * `error`, or `complete`).\n\t *\n\t * @see {@link materialize}\n\t * @see {@link dematerialize}\n\t * @see {@link observeOn}\n\t *\n\t * @class Notification<T>\n\t */\n\tvar Notification = (function () {\n\t    function Notification(kind, value, exception) {\n\t        this.kind = kind;\n\t        this.value = value;\n\t        this.exception = exception;\n\t        this.hasValue = kind === 'N';\n\t    }\n\t    /**\n\t     * Delivers to the given `observer` the value wrapped by this Notification.\n\t     * @param {Observer} observer\n\t     * @return\n\t     */\n\t    Notification.prototype.observe = function (observer) {\n\t        switch (this.kind) {\n\t            case 'N':\n\t                return observer.next && observer.next(this.value);\n\t            case 'E':\n\t                return observer.error && observer.error(this.exception);\n\t            case 'C':\n\t                return observer.complete && observer.complete();\n\t        }\n\t    };\n\t    /**\n\t     * Given some {@link Observer} callbacks, deliver the value represented by the\n\t     * current Notification to the correctly corresponding callback.\n\t     * @param {function(value: T): void} next An Observer `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.do = function (next, error, complete) {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return next && next(this.value);\n\t            case 'E':\n\t                return error && error(this.exception);\n\t            case 'C':\n\t                return complete && complete();\n\t        }\n\t    };\n\t    /**\n\t     * Takes an Observer or its individual callback functions, and calls `observe`\n\t     * or `do` methods accordingly.\n\t     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n\t     * the `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n\t        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n\t            return this.observe(nextOrObserver);\n\t        }\n\t        else {\n\t            return this.do(nextOrObserver, error, complete);\n\t        }\n\t    };\n\t    /**\n\t     * Returns a simple Observable that just delivers the notification represented\n\t     * by this Notification instance.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.toObservable = function () {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return Observable_1.Observable.of(this.value);\n\t            case 'E':\n\t                return Observable_1.Observable.throw(this.exception);\n\t            case 'C':\n\t                return Observable_1.Observable.empty();\n\t        }\n\t        throw new Error('unexpected notification kind value');\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `next` from a\n\t     * given value.\n\t     * @param {T} value The `next` value.\n\t     * @return {Notification<T>} The \"next\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createNext = function (value) {\n\t        if (typeof value !== 'undefined') {\n\t            return new Notification('N', value);\n\t        }\n\t        return this.undefinedValueNotification;\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `error` from a\n\t     * given error.\n\t     * @param {any} [err] The `error` exception.\n\t     * @return {Notification<T>} The \"error\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createError = function (err) {\n\t        return new Notification('E', undefined, err);\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `complete`.\n\t     * @return {Notification<any>} The valueless \"complete\" Notification.\n\t     */\n\t    Notification.createComplete = function () {\n\t        return this.completeNotification;\n\t    };\n\t    Notification.completeNotification = new Notification('C');\n\t    Notification.undefinedValueNotification = new Notification('N', undefined);\n\t    return Notification;\n\t}());\n\texports.Notification = Notification;\n\t//# sourceMappingURL=Notification.js.map\n\n/***/ },\n\n/***/ 57:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar OuterSubscriber = (function (_super) {\n\t    __extends(OuterSubscriber, _super);\n\t    function OuterSubscriber() {\n\t        _super.apply(this, arguments);\n\t    }\n\t    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        this.destination.next(innerValue);\n\t    };\n\t    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n\t        this.destination.error(error);\n\t    };\n\t    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        this.destination.complete();\n\t    };\n\t    return OuterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.OuterSubscriber = OuterSubscriber;\n\t//# sourceMappingURL=OuterSubscriber.js.map\n\n/***/ },\n\n/***/ 149:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(11);\n\tvar ScalarObservable_1 = __webpack_require__(89);\n\tvar EmptyObservable_1 = __webpack_require__(87);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ArrayLikeObservable = (function (_super) {\n\t    __extends(ArrayLikeObservable, _super);\n\t    function ArrayLikeObservable(arrayLike, scheduler) {\n\t        _super.call(this);\n\t        this.arrayLike = arrayLike;\n\t        this.scheduler = scheduler;\n\t        if (!scheduler && arrayLike.length === 1) {\n\t            this._isScalar = true;\n\t            this.value = arrayLike[0];\n\t        }\n\t    }\n\t    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n\t        var length = arrayLike.length;\n\t        if (length === 0) {\n\t            return new EmptyObservable_1.EmptyObservable();\n\t        }\n\t        else if (length === 1) {\n\t            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n\t        }\n\t        else {\n\t            return new ArrayLikeObservable(arrayLike, scheduler);\n\t        }\n\t    };\n\t    ArrayLikeObservable.dispatch = function (state) {\n\t        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        if (index >= length) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(arrayLike[index]);\n\t        state.index = index + 1;\n\t        this.schedule(state);\n\t    };\n\t    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n\t        var length = arrayLike.length;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n\t                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            for (var i = 0; i < length && !subscriber.closed; i++) {\n\t                subscriber.next(arrayLike[i]);\n\t            }\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return ArrayLikeObservable;\n\t}(Observable_1.Observable));\n\texports.ArrayLikeObservable = ArrayLikeObservable;\n\t//# sourceMappingURL=ArrayLikeObservable.js.map\n\n/***/ },\n\n/***/ 86:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(11);\n\tvar ScalarObservable_1 = __webpack_require__(89);\n\tvar EmptyObservable_1 = __webpack_require__(87);\n\tvar isScheduler_1 = __webpack_require__(167);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ArrayObservable = (function (_super) {\n\t    __extends(ArrayObservable, _super);\n\t    function ArrayObservable(array, scheduler) {\n\t        _super.call(this);\n\t        this.array = array;\n\t        this.scheduler = scheduler;\n\t        if (!scheduler && array.length === 1) {\n\t            this._isScalar = true;\n\t            this.value = array[0];\n\t        }\n\t    }\n\t    ArrayObservable.create = function (array, scheduler) {\n\t        return new ArrayObservable(array, scheduler);\n\t    };\n\t    /**\n\t     * Creates an Observable that emits some values you specify as arguments,\n\t     * immediately one after the other, and then emits a complete notification.\n\t     *\n\t     * <span class=\"informal\">Emits the arguments you provide, then completes.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/of.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the arguments given, and the complete notification thereafter. It can\n\t     * be used for composing with other Observables, such as with {@link concat}.\n\t     * By default, it uses a `null` Scheduler, which means the `next`\n\t     * notifications are sent synchronously, although with a different Scheduler\n\t     * it is possible to determine when those notifications will be delivered.\n\t     *\n\t     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n\t     * var numbers = Rx.Observable.of(10, 20, 30);\n\t     * var letters = Rx.Observable.of('a', 'b', 'c');\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = numbers.concat(letters).concat(interval);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link empty}\n\t     * @see {@link never}\n\t     * @see {@link throw}\n\t     *\n\t     * @param {...T} values Arguments that represent `next` values to be emitted.\n\t     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n\t     * the emissions of the `next` notifications.\n\t     * @return {Observable<T>} An Observable that emits each given input value.\n\t     * @static true\n\t     * @name of\n\t     * @owner Observable\n\t     */\n\t    ArrayObservable.of = function () {\n\t        var array = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            array[_i - 0] = arguments[_i];\n\t        }\n\t        var scheduler = array[array.length - 1];\n\t        if (isScheduler_1.isScheduler(scheduler)) {\n\t            array.pop();\n\t        }\n\t        else {\n\t            scheduler = null;\n\t        }\n\t        var len = array.length;\n\t        if (len > 1) {\n\t            return new ArrayObservable(array, scheduler);\n\t        }\n\t        else if (len === 1) {\n\t            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n\t        }\n\t        else {\n\t            return new EmptyObservable_1.EmptyObservable(scheduler);\n\t        }\n\t    };\n\t    ArrayObservable.dispatch = function (state) {\n\t        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n\t        if (index >= count) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(array[index]);\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        state.index = index + 1;\n\t        this.schedule(state);\n\t    };\n\t    ArrayObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var array = this.array;\n\t        var count = array.length;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n\t                array: array, index: index, count: count, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            for (var i = 0; i < count && !subscriber.closed; i++) {\n\t                subscriber.next(array[i]);\n\t            }\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return ArrayObservable;\n\t}(Observable_1.Observable));\n\texports.ArrayObservable = ArrayObservable;\n\t//# sourceMappingURL=ArrayObservable.js.map\n\n/***/ },\n\n/***/ 87:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(11);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar EmptyObservable = (function (_super) {\n\t    __extends(EmptyObservable, _super);\n\t    function EmptyObservable(scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable that emits no items to the Observer and immediately\n\t     * emits a complete notification.\n\t     *\n\t     * <span class=\"informal\">Just emits 'complete', and nothing else.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/empty.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the complete notification. It can be used for composing with other\n\t     * Observables, such as in a {@link mergeMap}.\n\t     *\n\t     * @example <caption>Emit the number 7, then complete.</caption>\n\t     * var result = Rx.Observable.empty().startWith(7);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = interval.mergeMap(x =>\n\t     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n\t     * );\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link never}\n\t     * @see {@link of}\n\t     * @see {@link throw}\n\t     *\n\t     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n\t     * the emission of the complete notification.\n\t     * @return {Observable} An \"empty\" Observable: emits only the complete\n\t     * notification.\n\t     * @static true\n\t     * @name empty\n\t     * @owner Observable\n\t     */\n\t    EmptyObservable.create = function (scheduler) {\n\t        return new EmptyObservable(scheduler);\n\t    };\n\t    EmptyObservable.dispatch = function (arg) {\n\t        var subscriber = arg.subscriber;\n\t        subscriber.complete();\n\t    };\n\t    EmptyObservable.prototype._subscribe = function (subscriber) {\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n\t        }\n\t        else {\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return EmptyObservable;\n\t}(Observable_1.Observable));\n\texports.EmptyObservable = EmptyObservable;\n\t//# sourceMappingURL=EmptyObservable.js.map\n\n/***/ },\n\n/***/ 150:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isArray_1 = __webpack_require__(63);\n\tvar isPromise_1 = __webpack_require__(96);\n\tvar PromiseObservable_1 = __webpack_require__(88);\n\tvar IteratorObservable_1 = __webpack_require__(151);\n\tvar ArrayObservable_1 = __webpack_require__(86);\n\tvar ArrayLikeObservable_1 = __webpack_require__(149);\n\tvar iterator_1 = __webpack_require__(59);\n\tvar Observable_1 = __webpack_require__(11);\n\tvar observeOn_1 = __webpack_require__(162);\n\tvar observable_1 = __webpack_require__(60);\n\tvar isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar FromObservable = (function (_super) {\n\t    __extends(FromObservable, _super);\n\t    function FromObservable(ish, scheduler) {\n\t        _super.call(this, null);\n\t        this.ish = ish;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable from an Array, an array-like object, a Promise, an\n\t     * iterable object, or an Observable-like object.\n\t     *\n\t     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n\t     *\n\t     * <img src=\"./img/from.png\" width=\"100%\">\n\t     *\n\t     * Convert various other objects and data types into Observables. `from`\n\t     * converts a Promise or an array-like or an\n\t     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n\t     * object into an Observable that emits the items in that promise or array or\n\t     * iterable. A String, in this context, is treated as an array of characters.\n\t     * Observable-like objects (contains a function named with the ES2015 Symbol\n\t     * for Observable) can also be converted through this operator.\n\t     *\n\t     * @example <caption>Converts an array to an Observable</caption>\n\t     * var array = [10, 20, 30];\n\t     * var result = Rx.Observable.from(array);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n\t     * function* generateDoubles(seed) {\n\t     *   var i = seed;\n\t     *   while (true) {\n\t     *     yield i;\n\t     *     i = 2 * i; // double it\n\t     *   }\n\t     * }\n\t     *\n\t     * var iterator = generateDoubles(3);\n\t     * var result = Rx.Observable.from(iterator).take(10);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link fromEvent}\n\t     * @see {@link fromEventPattern}\n\t     * @see {@link fromPromise}\n\t     *\n\t     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n\t     * Observable-like, an Array, an iterable or an array-like object to be\n\t     * converted.\n\t     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n\t     * emissions of values.\n\t     * @return {Observable<T>} The Observable whose values are originally from the\n\t     * input object that was converted.\n\t     * @static true\n\t     * @name from\n\t     * @owner Observable\n\t     */\n\t    FromObservable.create = function (ish, scheduler) {\n\t        if (ish != null) {\n\t            if (typeof ish[observable_1.$$observable] === 'function') {\n\t                if (ish instanceof Observable_1.Observable && !scheduler) {\n\t                    return ish;\n\t                }\n\t                return new FromObservable(ish, scheduler);\n\t            }\n\t            else if (isArray_1.isArray(ish)) {\n\t                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n\t            }\n\t            else if (isPromise_1.isPromise(ish)) {\n\t                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n\t            }\n\t            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {\n\t                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n\t            }\n\t            else if (isArrayLike(ish)) {\n\t                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n\t            }\n\t        }\n\t        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n\t    };\n\t    FromObservable.prototype._subscribe = function (subscriber) {\n\t        var ish = this.ish;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler == null) {\n\t            return ish[observable_1.$$observable]().subscribe(subscriber);\n\t        }\n\t        else {\n\t            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n\t        }\n\t    };\n\t    return FromObservable;\n\t}(Observable_1.Observable));\n\texports.FromObservable = FromObservable;\n\t//# sourceMappingURL=FromObservable.js.map\n\n/***/ },\n\n/***/ 151:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = __webpack_require__(26);\n\tvar Observable_1 = __webpack_require__(11);\n\tvar iterator_1 = __webpack_require__(59);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar IteratorObservable = (function (_super) {\n\t    __extends(IteratorObservable, _super);\n\t    function IteratorObservable(iterator, scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t        if (iterator == null) {\n\t            throw new Error('iterator cannot be null.');\n\t        }\n\t        this.iterator = getIterator(iterator);\n\t    }\n\t    IteratorObservable.create = function (iterator, scheduler) {\n\t        return new IteratorObservable(iterator, scheduler);\n\t    };\n\t    IteratorObservable.dispatch = function (state) {\n\t        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n\t        if (hasError) {\n\t            subscriber.error(state.error);\n\t            return;\n\t        }\n\t        var result = iterator.next();\n\t        if (result.done) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(result.value);\n\t        state.index = index + 1;\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        this.schedule(state);\n\t    };\n\t    IteratorObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n\t                index: index, iterator: iterator, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            do {\n\t                var result = iterator.next();\n\t                if (result.done) {\n\t                    subscriber.complete();\n\t                    break;\n\t                }\n\t                else {\n\t                    subscriber.next(result.value);\n\t                }\n\t                if (subscriber.closed) {\n\t                    break;\n\t                }\n\t            } while (true);\n\t        }\n\t    };\n\t    return IteratorObservable;\n\t}(Observable_1.Observable));\n\texports.IteratorObservable = IteratorObservable;\n\tvar StringIterator = (function () {\n\t    function StringIterator(str, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = str.length; }\n\t        this.str = str;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };\n\t    StringIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.str.charAt(this.idx++)\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return StringIterator;\n\t}());\n\tvar ArrayIterator = (function () {\n\t    function ArrayIterator(arr, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = toLength(arr); }\n\t        this.arr = arr;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };\n\t    ArrayIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.arr[this.idx++]\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return ArrayIterator;\n\t}());\n\tfunction getIterator(obj) {\n\t    var i = obj[iterator_1.$$iterator];\n\t    if (!i && typeof obj === 'string') {\n\t        return new StringIterator(obj);\n\t    }\n\t    if (!i && obj.length !== undefined) {\n\t        return new ArrayIterator(obj);\n\t    }\n\t    if (!i) {\n\t        throw new TypeError('object is not iterable');\n\t    }\n\t    return obj[iterator_1.$$iterator]();\n\t}\n\tvar maxSafeInteger = Math.pow(2, 53) - 1;\n\tfunction toLength(o) {\n\t    var len = +o.length;\n\t    if (isNaN(len)) {\n\t        return 0;\n\t    }\n\t    if (len === 0 || !numberIsFinite(len)) {\n\t        return len;\n\t    }\n\t    len = sign(len) * Math.floor(Math.abs(len));\n\t    if (len <= 0) {\n\t        return 0;\n\t    }\n\t    if (len > maxSafeInteger) {\n\t        return maxSafeInteger;\n\t    }\n\t    return len;\n\t}\n\tfunction numberIsFinite(value) {\n\t    return typeof value === 'number' && root_1.root.isFinite(value);\n\t}\n\tfunction sign(value) {\n\t    var valueAsNumber = +value;\n\t    if (valueAsNumber === 0) {\n\t        return valueAsNumber;\n\t    }\n\t    if (isNaN(valueAsNumber)) {\n\t        return valueAsNumber;\n\t    }\n\t    return valueAsNumber < 0 ? -1 : 1;\n\t}\n\t//# sourceMappingURL=IteratorObservable.js.map\n\n/***/ },\n\n/***/ 89:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(11);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ScalarObservable = (function (_super) {\n\t    __extends(ScalarObservable, _super);\n\t    function ScalarObservable(value, scheduler) {\n\t        _super.call(this);\n\t        this.value = value;\n\t        this.scheduler = scheduler;\n\t        this._isScalar = true;\n\t        if (scheduler) {\n\t            this._isScalar = false;\n\t        }\n\t    }\n\t    ScalarObservable.create = function (value, scheduler) {\n\t        return new ScalarObservable(value, scheduler);\n\t    };\n\t    ScalarObservable.dispatch = function (state) {\n\t        var done = state.done, value = state.value, subscriber = state.subscriber;\n\t        if (done) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(value);\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        state.done = true;\n\t        this.schedule(state);\n\t    };\n\t    ScalarObservable.prototype._subscribe = function (subscriber) {\n\t        var value = this.value;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n\t                done: false, value: value, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            subscriber.next(value);\n\t            if (!subscriber.closed) {\n\t                subscriber.complete();\n\t            }\n\t        }\n\t    };\n\t    return ScalarObservable;\n\t}(Observable_1.Observable));\n\texports.ScalarObservable = ScalarObservable;\n\t//# sourceMappingURL=ScalarObservable.js.map\n\n/***/ },\n\n/***/ 152:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar FromObservable_1 = __webpack_require__(150);\n\texports.from = FromObservable_1.FromObservable.create;\n\t//# sourceMappingURL=from.js.map\n\n/***/ },\n\n/***/ 153:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ArrayObservable_1 = __webpack_require__(86);\n\texports.of = ArrayObservable_1.ArrayObservable.of;\n\t//# sourceMappingURL=of.js.map\n\n/***/ },\n\n/***/ 154:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = __webpack_require__(57);\n\tvar subscribeToResult_1 = __webpack_require__(64);\n\t/**\n\t * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n\t * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n\t *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n\t *  is returned by the `selector` will be used to continue the observable chain.\n\t * @return {Observable} an observable that originates from either the source or the observable returned by the\n\t *  catch `selector` function.\n\t * @method catch\n\t * @owner Observable\n\t */\n\tfunction _catch(selector) {\n\t    var operator = new CatchOperator(selector);\n\t    var caught = this.lift(operator);\n\t    return (operator.caught = caught);\n\t}\n\texports._catch = _catch;\n\tvar CatchOperator = (function () {\n\t    function CatchOperator(selector) {\n\t        this.selector = selector;\n\t    }\n\t    CatchOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n\t    };\n\t    return CatchOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar CatchSubscriber = (function (_super) {\n\t    __extends(CatchSubscriber, _super);\n\t    function CatchSubscriber(destination, selector, caught) {\n\t        _super.call(this, destination);\n\t        this.selector = selector;\n\t        this.caught = caught;\n\t    }\n\t    // NOTE: overriding `error` instead of `_error` because we don't want\n\t    // to have this flag this subscriber as `isStopped`.\n\t    CatchSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var result = void 0;\n\t            try {\n\t                result = this.selector(err, this.caught);\n\t            }\n\t            catch (err) {\n\t                this.destination.error(err);\n\t                return;\n\t            }\n\t            this.unsubscribe();\n\t            this.destination.remove(this);\n\t            subscribeToResult_1.subscribeToResult(this, result);\n\t        }\n\t    };\n\t    return CatchSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t//# sourceMappingURL=catch.js.map\n\n/***/ },\n\n/***/ 155:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar mergeAll_1 = __webpack_require__(91);\n\t/**\n\t * Converts a higher-order Observable into a first-order Observable by\n\t * concatenating the inner Observables in order.\n\t *\n\t * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n\t * inner Observable after the other.</span>\n\t *\n\t * <img src=\"./img/concatAll.png\" width=\"100%\">\n\t *\n\t * Joins every Observable emitted by the source (a higher-order Observable), in\n\t * a serial fashion. It subscribes to each inner Observable only after the\n\t * previous inner Observable has completed, and merges all of their values into\n\t * the returned observable.\n\t *\n\t * __Warning:__ If the source Observable emits Observables quickly and\n\t * endlessly, and the inner Observables it emits generally complete slower than\n\t * the source emits, you can run into memory issues as the incoming Observables\n\t * collect in an unbounded buffer.\n\t *\n\t * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n\t * to `1`.\n\t *\n\t * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n\t * var firstOrder = higherOrder.concatAll();\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @see {@link combineAll}\n\t * @see {@link concat}\n\t * @see {@link concatMap}\n\t * @see {@link concatMapTo}\n\t * @see {@link exhaust}\n\t * @see {@link mergeAll}\n\t * @see {@link switch}\n\t * @see {@link zipAll}\n\t *\n\t * @return {Observable} An Observable emitting values from all the inner\n\t * Observables concatenated.\n\t * @method concatAll\n\t * @owner Observable\n\t */\n\tfunction concatAll() {\n\t    return this.lift(new mergeAll_1.MergeAllOperator(1));\n\t}\n\texports.concatAll = concatAll;\n\t//# sourceMappingURL=concatAll.js.map\n\n/***/ },\n\n/***/ 156:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar mergeMap_1 = __webpack_require__(92);\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable, in a serialized fashion waiting for each one to complete before\n\t * merging the next.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link concatAll}.</span>\n\t *\n\t * <img src=\"./img/concatMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an (so-called \"inner\") Observable. Each new inner Observable is\n\t * concatenated with the previous inner Observable.\n\t *\n\t * __Warning:__ if source values arrive endlessly and faster than their\n\t * corresponding inner Observables can complete, it will result in memory issues\n\t * as inner Observables amass in an unbounded buffer waiting for their turn to\n\t * be subscribed to.\n\t *\n\t * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n\t * to `1`.\n\t *\n\t * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link concat}\n\t * @see {@link concatAll}\n\t * @see {@link concatMapTo}\n\t * @see {@link exhaustMap}\n\t * @see {@link mergeMap}\n\t * @see {@link switchMap}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @return {Observable} an observable of values merged from the projected\n\t * Observables as they were subscribed to, one at a time. Optionally, these\n\t * values may have been projected from a passed `projectResult` argument.\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and taking values from each projected inner\n\t * Observable sequentially.\n\t * @method concatMap\n\t * @owner Observable\n\t */\n\tfunction concatMap(project, resultSelector) {\n\t    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));\n\t}\n\texports.concatMap = concatMap;\n\t//# sourceMappingURL=concatMap.js.map\n\n/***/ },\n\n/***/ 157:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n\t * @param {function} predicate a function for determining if an item meets a specified condition.\n\t * @param {any} [thisArg] optional object to use for `this` in the callback\n\t * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.\n\t * @method every\n\t * @owner Observable\n\t */\n\tfunction every(predicate, thisArg) {\n\t    return this.lift(new EveryOperator(predicate, thisArg, this));\n\t}\n\texports.every = every;\n\tvar EveryOperator = (function () {\n\t    function EveryOperator(predicate, thisArg, source) {\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.source = source;\n\t    }\n\t    EveryOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n\t    };\n\t    return EveryOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar EverySubscriber = (function (_super) {\n\t    __extends(EverySubscriber, _super);\n\t    function EverySubscriber(destination, predicate, thisArg, source) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.source = source;\n\t        this.index = 0;\n\t        this.thisArg = thisArg || this;\n\t    }\n\t    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n\t        this.destination.next(everyValueMatch);\n\t        this.destination.complete();\n\t    };\n\t    EverySubscriber.prototype._next = function (value) {\n\t        var result = false;\n\t        try {\n\t            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (!result) {\n\t            this.notifyComplete(false);\n\t        }\n\t    };\n\t    EverySubscriber.prototype._complete = function () {\n\t        this.notifyComplete(true);\n\t    };\n\t    return EverySubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=every.js.map\n\n/***/ },\n\n/***/ 158:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * Filter items emitted by the source Observable by only emitting those that\n\t * satisfy a specified predicate.\n\t *\n\t * <span class=\"informal\">Like\n\t * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n\t * it only emits a value from the source if it passes a criterion function.</span>\n\t *\n\t * <img src=\"./img/filter.png\" width=\"100%\">\n\t *\n\t * Similar to the well-known `Array.prototype.filter` method, this operator\n\t * takes values from the source Observable, passes them through a `predicate`\n\t * function and only emits those values that yielded `true`.\n\t *\n\t * @example <caption>Emit only click events whose target was a DIV element</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n\t * clicksOnDivs.subscribe(x => console.log(x));\n\t *\n\t * @see {@link distinct}\n\t * @see {@link distinctKey}\n\t * @see {@link distinctUntilChanged}\n\t * @see {@link distinctUntilKeyChanged}\n\t * @see {@link ignoreElements}\n\t * @see {@link partition}\n\t * @see {@link skip}\n\t *\n\t * @param {function(value: T, index: number): boolean} predicate A function that\n\t * evaluates each value emitted by the source Observable. If it returns `true`,\n\t * the value is emitted, if `false` the value is not passed to the output\n\t * Observable. The `index` parameter is the number `i` for the i-th source\n\t * emission that has happened since the subscription, starting from the number\n\t * `0`.\n\t * @param {any} [thisArg] An optional argument to determine the value of `this`\n\t * in the `predicate` function.\n\t * @return {Observable} An Observable of values from the source that were\n\t * allowed by the `predicate` function.\n\t * @method filter\n\t * @owner Observable\n\t */\n\tfunction filter(predicate, thisArg) {\n\t    return this.lift(new FilterOperator(predicate, thisArg));\n\t}\n\texports.filter = filter;\n\tvar FilterOperator = (function () {\n\t    function FilterOperator(predicate, thisArg) {\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t    }\n\t    FilterOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n\t    };\n\t    return FilterOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar FilterSubscriber = (function (_super) {\n\t    __extends(FilterSubscriber, _super);\n\t    function FilterSubscriber(destination, predicate, thisArg) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.count = 0;\n\t        this.predicate = predicate;\n\t    }\n\t    // the try catch block below is left specifically for\n\t    // optimization and perf reasons. a tryCatcher is not necessary here.\n\t    FilterSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.predicate.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            this.destination.next(value);\n\t        }\n\t    };\n\t    return FilterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=filter.js.map\n\n/***/ },\n\n/***/ 159:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\tvar EmptyError_1 = __webpack_require__(62);\n\t/**\n\t * Emits only the first value (or the first value that meets some condition)\n\t * emitted by the source Observable.\n\t *\n\t * <span class=\"informal\">Emits only the first value. Or emits only the first\n\t * value that passes some test.</span>\n\t *\n\t * <img src=\"./img/first.png\" width=\"100%\">\n\t *\n\t * If called with no arguments, `first` emits the first value of the source\n\t * Observable, then completes. If called with a `predicate` function, `first`\n\t * emits the first value of the source that matches the specified condition. It\n\t * may also take a `resultSelector` function to produce the output value from\n\t * the input value, and a `defaultValue` to emit in case the source completes\n\t * before it is able to emit a valid value. Throws an error if `defaultValue`\n\t * was not provided and a matching element is not found.\n\t *\n\t * @example <caption>Emit only the first click that happens on the DOM</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.first();\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @example <caption>Emits the first click that happens on a DIV</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link filter}\n\t * @see {@link find}\n\t * @see {@link take}\n\t *\n\t * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n\t * callback if the Observable completes before any `next` notification was sent.\n\t *\n\t * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n\t * An optional function called with each item to test for condition matching.\n\t * @param {function(value: T, index: number): R} [resultSelector] A function to\n\t * produce the value on the output Observable based on the values\n\t * and the indices of the source Observable. The arguments passed to this\n\t * function are:\n\t * - `value`: the value that was emitted on the source.\n\t * - `index`: the \"index\" of the value from the source.\n\t * @param {R} [defaultValue] The default value emitted in case no valid value\n\t * was found on the source.\n\t * @return {Observable<T|R>} an Observable of the first item that matches the\n\t * condition.\n\t * @method first\n\t * @owner Observable\n\t */\n\tfunction first(predicate, resultSelector, defaultValue) {\n\t    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));\n\t}\n\texports.first = first;\n\tvar FirstOperator = (function () {\n\t    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t    }\n\t    FirstOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n\t    };\n\t    return FirstOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar FirstSubscriber = (function (_super) {\n\t    __extends(FirstSubscriber, _super);\n\t    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t        this.index = 0;\n\t        this.hasCompleted = false;\n\t    }\n\t    FirstSubscriber.prototype._next = function (value) {\n\t        var index = this.index++;\n\t        if (this.predicate) {\n\t            this._tryPredicate(value, index);\n\t        }\n\t        else {\n\t            this._emit(value, index);\n\t        }\n\t    };\n\t    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.predicate(value, index, this.source);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            this._emit(value, index);\n\t        }\n\t    };\n\t    FirstSubscriber.prototype._emit = function (value, index) {\n\t        if (this.resultSelector) {\n\t            this._tryResultSelector(value, index);\n\t            return;\n\t        }\n\t        this._emitFinal(value);\n\t    };\n\t    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this._emitFinal(result);\n\t    };\n\t    FirstSubscriber.prototype._emitFinal = function (value) {\n\t        var destination = this.destination;\n\t        destination.next(value);\n\t        destination.complete();\n\t        this.hasCompleted = true;\n\t    };\n\t    FirstSubscriber.prototype._complete = function () {\n\t        var destination = this.destination;\n\t        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n\t            destination.next(this.defaultValue);\n\t            destination.complete();\n\t        }\n\t        else if (!this.hasCompleted) {\n\t            destination.error(new EmptyError_1.EmptyError);\n\t        }\n\t    };\n\t    return FirstSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=first.js.map\n\n/***/ },\n\n/***/ 160:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\tvar EmptyError_1 = __webpack_require__(62);\n\t/**\n\t * Returns an Observable that emits only the last item emitted by the source Observable.\n\t * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n\t * the last item from the source Observable, the resulting Observable will emit the last item\n\t * from the source Observable that satisfies the predicate.\n\t *\n\t * <img src=\"./img/last.png\" width=\"100%\">\n\t *\n\t * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n\t * callback if the Observable completes before any `next` notification was sent.\n\t * @param {function} predicate - the condition any source emitted item has to satisfy.\n\t * @return {Observable} an Observable that emits only the last item satisfying the given condition\n\t * from the source, or an NoSuchElementException if no such items are emitted.\n\t * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n\t * @method last\n\t * @owner Observable\n\t */\n\tfunction last(predicate, resultSelector, defaultValue) {\n\t    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));\n\t}\n\texports.last = last;\n\tvar LastOperator = (function () {\n\t    function LastOperator(predicate, resultSelector, defaultValue, source) {\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t    }\n\t    LastOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n\t    };\n\t    return LastOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar LastSubscriber = (function (_super) {\n\t    __extends(LastSubscriber, _super);\n\t    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t        this.hasValue = false;\n\t        this.index = 0;\n\t        if (typeof defaultValue !== 'undefined') {\n\t            this.lastValue = defaultValue;\n\t            this.hasValue = true;\n\t        }\n\t    }\n\t    LastSubscriber.prototype._next = function (value) {\n\t        var index = this.index++;\n\t        if (this.predicate) {\n\t            this._tryPredicate(value, index);\n\t        }\n\t        else {\n\t            if (this.resultSelector) {\n\t                this._tryResultSelector(value, index);\n\t                return;\n\t            }\n\t            this.lastValue = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    LastSubscriber.prototype._tryPredicate = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.predicate(value, index, this.source);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            if (this.resultSelector) {\n\t                this._tryResultSelector(value, index);\n\t                return;\n\t            }\n\t            this.lastValue = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.lastValue = result;\n\t        this.hasValue = true;\n\t    };\n\t    LastSubscriber.prototype._complete = function () {\n\t        var destination = this.destination;\n\t        if (this.hasValue) {\n\t            destination.next(this.lastValue);\n\t            destination.complete();\n\t        }\n\t        else {\n\t            destination.error(new EmptyError_1.EmptyError);\n\t        }\n\t    };\n\t    return LastSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=last.js.map\n\n/***/ },\n\n/***/ 161:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * Applies a given `project` function to each value emitted by the source\n\t * Observable, and emits the resulting values as an Observable.\n\t *\n\t * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n\t * it passes each source value through a transformation function to get\n\t * corresponding output values.</span>\n\t *\n\t * <img src=\"./img/map.png\" width=\"100%\">\n\t *\n\t * Similar to the well known `Array.prototype.map` function, this operator\n\t * applies a projection to each value and emits that projection in the output\n\t * Observable.\n\t *\n\t * @example <caption>Map every every click to the clientX position of that click</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var positions = clicks.map(ev => ev.clientX);\n\t * positions.subscribe(x => console.log(x));\n\t *\n\t * @see {@link mapTo}\n\t * @see {@link pluck}\n\t *\n\t * @param {function(value: T, index: number): R} project The function to apply\n\t * to each `value` emitted by the source Observable. The `index` parameter is\n\t * the number `i` for the i-th emission that has happened since the\n\t * subscription, starting from the number `0`.\n\t * @param {any} [thisArg] An optional argument to define what `this` is in the\n\t * `project` function.\n\t * @return {Observable<R>} An Observable that emits the values from the source\n\t * Observable transformed by the given `project` function.\n\t * @method map\n\t * @owner Observable\n\t */\n\tfunction map(project, thisArg) {\n\t    if (typeof project !== 'function') {\n\t        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n\t    }\n\t    return this.lift(new MapOperator(project, thisArg));\n\t}\n\texports.map = map;\n\tvar MapOperator = (function () {\n\t    function MapOperator(project, thisArg) {\n\t        this.project = project;\n\t        this.thisArg = thisArg;\n\t    }\n\t    MapOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n\t    };\n\t    return MapOperator;\n\t}());\n\texports.MapOperator = MapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MapSubscriber = (function (_super) {\n\t    __extends(MapSubscriber, _super);\n\t    function MapSubscriber(destination, project, thisArg) {\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.count = 0;\n\t        this.thisArg = thisArg || this;\n\t    }\n\t    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n\t    // using try/catch optimizations.\n\t    MapSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.project.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    return MapSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=map.js.map\n\n/***/ },\n\n/***/ 91:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = __webpack_require__(57);\n\tvar subscribeToResult_1 = __webpack_require__(64);\n\t/**\n\t * Converts a higher-order Observable into a first-order Observable which\n\t * concurrently delivers all values that are emitted on the inner Observables.\n\t *\n\t * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n\t *\n\t * <img src=\"./img/mergeAll.png\" width=\"100%\">\n\t *\n\t * `mergeAll` subscribes to an Observable that emits Observables, also known as\n\t * a higher-order Observable. Each time it observes one of these emitted inner\n\t * Observables, it subscribes to that and delivers all the values from the\n\t * inner Observable on the output Observable. The output Observable only\n\t * completes once all inner Observables have completed. Any error delivered by\n\t * a inner Observable will be immediately emitted on the output Observable.\n\t *\n\t * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n\t * var firstOrder = higherOrder.mergeAll();\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n\t * var firstOrder = higherOrder.mergeAll(2);\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @see {@link combineAll}\n\t * @see {@link concatAll}\n\t * @see {@link exhaust}\n\t * @see {@link merge}\n\t * @see {@link mergeMap}\n\t * @see {@link mergeMapTo}\n\t * @see {@link mergeScan}\n\t * @see {@link switch}\n\t * @see {@link zipAll}\n\t *\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n\t * Observables being subscribed to concurrently.\n\t * @return {Observable} An Observable that emits values coming from all the\n\t * inner Observables emitted by the source Observable.\n\t * @method mergeAll\n\t * @owner Observable\n\t */\n\tfunction mergeAll(concurrent) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    return this.lift(new MergeAllOperator(concurrent));\n\t}\n\texports.mergeAll = mergeAll;\n\tvar MergeAllOperator = (function () {\n\t    function MergeAllOperator(concurrent) {\n\t        this.concurrent = concurrent;\n\t    }\n\t    MergeAllOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new MergeAllSubscriber(observer, this.concurrent));\n\t    };\n\t    return MergeAllOperator;\n\t}());\n\texports.MergeAllOperator = MergeAllOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MergeAllSubscriber = (function (_super) {\n\t    __extends(MergeAllSubscriber, _super);\n\t    function MergeAllSubscriber(destination, concurrent) {\n\t        _super.call(this, destination);\n\t        this.concurrent = concurrent;\n\t        this.hasCompleted = false;\n\t        this.buffer = [];\n\t        this.active = 0;\n\t    }\n\t    MergeAllSubscriber.prototype._next = function (observable) {\n\t        if (this.active < this.concurrent) {\n\t            this.active++;\n\t            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n\t        }\n\t        else {\n\t            this.buffer.push(observable);\n\t        }\n\t    };\n\t    MergeAllSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.active === 0 && this.buffer.length === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        else if (this.active === 0 && this.hasCompleted) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return MergeAllSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\texports.MergeAllSubscriber = MergeAllSubscriber;\n\t//# sourceMappingURL=mergeAll.js.map\n\n/***/ },\n\n/***/ 92:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar subscribeToResult_1 = __webpack_require__(64);\n\tvar OuterSubscriber_1 = __webpack_require__(57);\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link mergeAll}.</span>\n\t *\n\t * <img src=\"./img/mergeMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an Observable, and then merging those resulting Observables and\n\t * emitting the results of this merger.\n\t *\n\t * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n\t * var letters = Rx.Observable.of('a', 'b', 'c');\n\t * var result = letters.mergeMap(x =>\n\t *   Rx.Observable.interval(1000).map(i => x+i)\n\t * );\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link concatMap}\n\t * @see {@link exhaustMap}\n\t * @see {@link merge}\n\t * @see {@link mergeAll}\n\t * @see {@link mergeMapTo}\n\t * @see {@link mergeScan}\n\t * @see {@link switchMap}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n\t * Observables being subscribed to concurrently.\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and merging the results of the Observables obtained\n\t * from this transformation.\n\t * @method mergeMap\n\t * @owner Observable\n\t */\n\tfunction mergeMap(project, resultSelector, concurrent) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    if (typeof resultSelector === 'number') {\n\t        concurrent = resultSelector;\n\t        resultSelector = null;\n\t    }\n\t    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n\t}\n\texports.mergeMap = mergeMap;\n\tvar MergeMapOperator = (function () {\n\t    function MergeMapOperator(project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t    }\n\t    MergeMapOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n\t    };\n\t    return MergeMapOperator;\n\t}());\n\texports.MergeMapOperator = MergeMapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MergeMapSubscriber = (function (_super) {\n\t    __extends(MergeMapSubscriber, _super);\n\t    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t        this.hasCompleted = false;\n\t        this.buffer = [];\n\t        this.active = 0;\n\t        this.index = 0;\n\t    }\n\t    MergeMapSubscriber.prototype._next = function (value) {\n\t        if (this.active < this.concurrent) {\n\t            this._tryNext(value);\n\t        }\n\t        else {\n\t            this.buffer.push(value);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._tryNext = function (value) {\n\t        var result;\n\t        var index = this.index++;\n\t        try {\n\t            result = this.project(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.active++;\n\t        this._innerSub(result, value, index);\n\t    };\n\t    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n\t        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n\t    };\n\t    MergeMapSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.active === 0 && this.buffer.length === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        if (this.resultSelector) {\n\t            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        else {\n\t            this.destination.next(innerValue);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        else if (this.active === 0 && this.hasCompleted) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return MergeMapSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\texports.MergeMapSubscriber = MergeMapSubscriber;\n\t//# sourceMappingURL=mergeMap.js.map\n\n/***/ },\n\n/***/ 162:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\tvar Notification_1 = __webpack_require__(146);\n\t/**\n\t * @see {@link Notification}\n\t *\n\t * @param scheduler\n\t * @param delay\n\t * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n\t * @method observeOn\n\t * @owner Observable\n\t */\n\tfunction observeOn(scheduler, delay) {\n\t    if (delay === void 0) { delay = 0; }\n\t    return this.lift(new ObserveOnOperator(scheduler, delay));\n\t}\n\texports.observeOn = observeOn;\n\tvar ObserveOnOperator = (function () {\n\t    function ObserveOnOperator(scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n\t    };\n\t    return ObserveOnOperator;\n\t}());\n\texports.ObserveOnOperator = ObserveOnOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ObserveOnSubscriber = (function (_super) {\n\t    __extends(ObserveOnSubscriber, _super);\n\t    function ObserveOnSubscriber(destination, scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        _super.call(this, destination);\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnSubscriber.dispatch = function (arg) {\n\t        var notification = arg.notification, destination = arg.destination;\n\t        notification.observe(destination);\n\t    };\n\t    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n\t        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n\t    };\n\t    ObserveOnSubscriber.prototype._next = function (value) {\n\t        this.scheduleMessage(Notification_1.Notification.createNext(value));\n\t    };\n\t    ObserveOnSubscriber.prototype._error = function (err) {\n\t        this.scheduleMessage(Notification_1.Notification.createError(err));\n\t    };\n\t    ObserveOnSubscriber.prototype._complete = function () {\n\t        this.scheduleMessage(Notification_1.Notification.createComplete());\n\t    };\n\t    return ObserveOnSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.ObserveOnSubscriber = ObserveOnSubscriber;\n\tvar ObserveOnMessage = (function () {\n\t    function ObserveOnMessage(notification, destination) {\n\t        this.notification = notification;\n\t        this.destination = destination;\n\t    }\n\t    return ObserveOnMessage;\n\t}());\n\texports.ObserveOnMessage = ObserveOnMessage;\n\t//# sourceMappingURL=observeOn.js.map\n\n/***/ },\n\n/***/ 163:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * Applies an accumulator function over the source Observable, and returns the\n\t * accumulated result when the source completes, given an optional seed value.\n\t *\n\t * <span class=\"informal\">Combines together all values emitted on the source,\n\t * using an accumulator function that knows how to join a new source value into\n\t * the accumulation from the past.</span>\n\t *\n\t * <img src=\"./img/reduce.png\" width=\"100%\">\n\t *\n\t * Like\n\t * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n\t * `reduce` applies an `accumulator` function against an accumulation and each\n\t * value of the source Observable (from the past) to reduce it to a single\n\t * value, emitted on the output Observable. Note that `reduce` will only emit\n\t * one value, only when the source Observable completes. It is equivalent to\n\t * applying operator {@link scan} followed by operator {@link last}.\n\t *\n\t * Returns an Observable that applies a specified `accumulator` function to each\n\t * item emitted by the source Observable. If a `seed` value is specified, then\n\t * that value will be used as the initial value for the accumulator. If no seed\n\t * value is specified, the first item of the source is used as the seed.\n\t *\n\t * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n\t * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n\t *   .takeUntil(Rx.Observable.interval(5000));\n\t * var ones = clicksInFiveSeconds.mapTo(1);\n\t * var seed = 0;\n\t * var count = ones.reduce((acc, one) => acc + one, seed);\n\t * count.subscribe(x => console.log(x));\n\t *\n\t * @see {@link count}\n\t * @see {@link expand}\n\t * @see {@link mergeScan}\n\t * @see {@link scan}\n\t *\n\t * @param {function(acc: R, value: T): R} accumulator The accumulator function\n\t * called on each source value.\n\t * @param {R} [seed] The initial accumulation value.\n\t * @return {Observable<R>} An observable of the accumulated values.\n\t * @return {Observable<R>} An Observable that emits a single value that is the\n\t * result of accumulating the values emitted by the source Observable.\n\t * @method reduce\n\t * @owner Observable\n\t */\n\tfunction reduce(accumulator, seed) {\n\t    return this.lift(new ReduceOperator(accumulator, seed));\n\t}\n\texports.reduce = reduce;\n\tvar ReduceOperator = (function () {\n\t    function ReduceOperator(accumulator, seed) {\n\t        this.accumulator = accumulator;\n\t        this.seed = seed;\n\t    }\n\t    ReduceOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed));\n\t    };\n\t    return ReduceOperator;\n\t}());\n\texports.ReduceOperator = ReduceOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ReduceSubscriber = (function (_super) {\n\t    __extends(ReduceSubscriber, _super);\n\t    function ReduceSubscriber(destination, accumulator, seed) {\n\t        _super.call(this, destination);\n\t        this.accumulator = accumulator;\n\t        this.hasValue = false;\n\t        this.acc = seed;\n\t        this.accumulator = accumulator;\n\t        this.hasSeed = typeof seed !== 'undefined';\n\t    }\n\t    ReduceSubscriber.prototype._next = function (value) {\n\t        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n\t            this._tryReduce(value);\n\t        }\n\t        else {\n\t            this.acc = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    ReduceSubscriber.prototype._tryReduce = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.accumulator(this.acc, value);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.acc = result;\n\t    };\n\t    ReduceSubscriber.prototype._complete = function () {\n\t        if (this.hasValue || this.hasSeed) {\n\t            this.destination.next(this.acc);\n\t        }\n\t        this.destination.complete();\n\t    };\n\t    return ReduceSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.ReduceSubscriber = ReduceSubscriber;\n\t//# sourceMappingURL=reduce.js.map\n\n/***/ },\n\n/***/ 59:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(26);\n\tvar Symbol = root_1.root.Symbol;\n\tif (typeof Symbol === 'function') {\n\t    if (Symbol.iterator) {\n\t        exports.$$iterator = Symbol.iterator;\n\t    }\n\t    else if (typeof Symbol.for === 'function') {\n\t        exports.$$iterator = Symbol.for('iterator');\n\t    }\n\t}\n\telse {\n\t    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {\n\t        // Bug for mozilla version\n\t        exports.$$iterator = '@@iterator';\n\t    }\n\t    else if (root_1.root.Map) {\n\t        // es6-shim specific logic\n\t        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            var key = keys[i];\n\t            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {\n\t                exports.$$iterator = key;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t    else {\n\t        exports.$$iterator = '@@iterator';\n\t    }\n\t}\n\t//# sourceMappingURL=iterator.js.map\n\n/***/ },\n\n/***/ 62:\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * An error thrown when an Observable or a sequence was queried but has no\n\t * elements.\n\t *\n\t * @see {@link first}\n\t * @see {@link last}\n\t * @see {@link single}\n\t *\n\t * @class EmptyError\n\t */\n\tvar EmptyError = (function (_super) {\n\t    __extends(EmptyError, _super);\n\t    function EmptyError() {\n\t        var err = _super.call(this, 'no elements in sequence');\n\t        this.name = err.name = 'EmptyError';\n\t        this.stack = err.stack;\n\t        this.message = err.message;\n\t    }\n\t    return EmptyError;\n\t}(Error));\n\texports.EmptyError = EmptyError;\n\t//# sourceMappingURL=EmptyError.js.map\n\n/***/ },\n\n/***/ 96:\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isPromise(value) {\n\t    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n\t}\n\texports.isPromise = isPromise;\n\t//# sourceMappingURL=isPromise.js.map\n\n/***/ },\n\n/***/ 167:\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isScheduler(value) {\n\t    return value && typeof value.schedule === 'function';\n\t}\n\texports.isScheduler = isScheduler;\n\t//# sourceMappingURL=isScheduler.js.map\n\n/***/ },\n\n/***/ 64:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(26);\n\tvar isArray_1 = __webpack_require__(63);\n\tvar isPromise_1 = __webpack_require__(96);\n\tvar Observable_1 = __webpack_require__(11);\n\tvar iterator_1 = __webpack_require__(59);\n\tvar InnerSubscriber_1 = __webpack_require__(145);\n\tvar observable_1 = __webpack_require__(60);\n\tfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n\t    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\t    if (destination.closed) {\n\t        return null;\n\t    }\n\t    if (result instanceof Observable_1.Observable) {\n\t        if (result._isScalar) {\n\t            destination.next(result.value);\n\t            destination.complete();\n\t            return null;\n\t        }\n\t        else {\n\t            return result.subscribe(destination);\n\t        }\n\t    }\n\t    if (isArray_1.isArray(result)) {\n\t        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n\t            destination.next(result[i]);\n\t        }\n\t        if (!destination.closed) {\n\t            destination.complete();\n\t        }\n\t    }\n\t    else if (isPromise_1.isPromise(result)) {\n\t        result.then(function (value) {\n\t            if (!destination.closed) {\n\t                destination.next(value);\n\t                destination.complete();\n\t            }\n\t        }, function (err) { return destination.error(err); })\n\t            .then(null, function (err) {\n\t            // Escaping the Promise trap: globally throw unhandled errors\n\t            root_1.root.setTimeout(function () { throw err; });\n\t        });\n\t        return destination;\n\t    }\n\t    else if (typeof result[iterator_1.$$iterator] === 'function') {\n\t        var iterator = result[iterator_1.$$iterator]();\n\t        do {\n\t            var item = iterator.next();\n\t            if (item.done) {\n\t                destination.complete();\n\t                break;\n\t            }\n\t            destination.next(item.value);\n\t            if (destination.closed) {\n\t                break;\n\t            }\n\t        } while (true);\n\t    }\n\t    else if (typeof result[observable_1.$$observable] === 'function') {\n\t        var obs = result[observable_1.$$observable]();\n\t        if (typeof obs.subscribe !== 'function') {\n\t            destination.error(new Error('invalid observable'));\n\t        }\n\t        else {\n\t            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n\t        }\n\t    }\n\t    else {\n\t        destination.error(new TypeError('unknown type returned'));\n\t    }\n\t    return null;\n\t}\n\texports.subscribeToResult = subscribeToResult;\n\t//# sourceMappingURL=subscribeToResult.js.map\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** main.8180ef8b31c42df2d539.bundle.js\n **/","/// <reference path=\"../lib/vs/index.d.ts\" />\r\nexport * from './timeline/index';\r\nexport * from './network/index';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/index.ts\n **/","import * as Vis from 'vis';\r\n\r\nimport { VisDataSetOptions, VisDataSetQueueOptions, VisId } from '../timeline/index';\r\n\r\nexport interface VisNetworkData extends Vis.IData {}\r\nexport interface VisNode extends Vis.INode {}\r\nexport interface VisEdge extends Vis.IEdge {}\r\nexport interface VisNodeSelectionOptions extends Vis.DataSelectionOptions<VisNode> {}\r\nexport interface VisEdgeSelectionOptions extends Vis.DataSelectionOptions<VisEdge> {}\r\nexport interface VisFitOptions extends Vis.IFitOptions {}\r\nexport interface VisNetworkOptions extends Vis.IOptions {}\r\nexport class VisNetwork extends Vis.Network {}\r\n\r\nexport class VisNodes extends Vis.DataSet<VisNode> {\r\n    public constructor(data?: Array<VisNode>, options?: VisDataSetOptions) {\r\n        super(data, options);\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this.length;\r\n    }\r\n\r\n    public add(data: VisNode | VisNode[], senderId?: VisId): VisId[] {\r\n        return super.add(data, senderId);\r\n    }\r\n\r\n    public clear(senderId?: VisId): VisId[] {\r\n        return super.clear(senderId);\r\n    }\r\n\r\n    public distinct(field: string): any[] {\r\n        return super.distinct(field);\r\n    }\r\n\r\n    public flush(): void {\r\n        super.flush();\r\n    }\r\n\r\n    public forEach(callback: (item: VisNode, id: VisId) => void, options?: VisNodeSelectionOptions): void {\r\n        super.forEach(callback, options);\r\n    }\r\n\r\n    public getAll(options?: VisNodeSelectionOptions): VisNode[] {\r\n        return super.get(options);\r\n    }\r\n\r\n    public getById(id: VisId, options?: VisNodeSelectionOptions): VisNode {\r\n        return super.get(id, options);\r\n    }\r\n\r\n    public getByIds(ids: VisId[], options?: VisNodeSelectionOptions): VisNode[] {\r\n        return super.get(ids, options);\r\n    }\r\n\r\n    public getDataSet(): VisNodes {\r\n        return super.getDataSet() as VisNodes;\r\n    }\r\n\r\n    public getIds(options?: VisNodeSelectionOptions): VisId[] {\r\n        return super.getIds(options);\r\n    }\r\n\r\n    public map(callback: (item: VisNode, id: VisId) => any, options?: VisNodeSelectionOptions): any[] {\r\n        return super.map(callback, options);\r\n    }\r\n\r\n    public max(field: string): VisNode {\r\n        return super.max(field);\r\n    }\r\n\r\n    public min(field: string): VisNode {\r\n        return super.min(field);\r\n    }\r\n\r\n    public on(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.on(event, callback);\r\n    }\r\n\r\n    public off(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.off(event, callback);\r\n    }\r\n\r\n    public removeItems(ids: VisId[], senderId?: VisId): VisId[] {\r\n        return super.remove(ids, senderId);\r\n    }\r\n\r\n    public setOptions(options?: VisDataSetQueueOptions): void {\r\n        super.setOptions(options);\r\n    }\r\n\r\n    public update(data: VisNode[], senderId?: VisId): VisId[] {\r\n        return super.update(data, senderId);\r\n    }\r\n}\r\n\r\nexport class VisEdges extends Vis.DataSet<VisEdge> {\r\n    public constructor(data?: Array<VisEdge>, options?: VisDataSetOptions) {\r\n        super(data, options);\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this.length;\r\n    }\r\n\r\n    public add(data: VisEdge | VisEdge[], senderId?: VisId): VisId[] {\r\n        return super.add(data, senderId);\r\n    }\r\n\r\n    public clear(senderId?: VisId): VisId[] {\r\n        return super.clear(senderId);\r\n    }\r\n\r\n    public distinct(field: string): any[] {\r\n        return super.distinct(field);\r\n    }\r\n\r\n    public flush(): void {\r\n        super.flush();\r\n    }\r\n\r\n    public forEach(callback: (item: VisEdge, id: VisId) => void, options?: VisEdgeSelectionOptions): void {\r\n        super.forEach(callback, options);\r\n    }\r\n\r\n    public getAll(options?: VisEdgeSelectionOptions): VisEdge[] {\r\n        return super.get(options);\r\n    }\r\n\r\n    public getById(id: VisId, options?: VisEdgeSelectionOptions): VisEdge {\r\n        return super.get(id, options);\r\n    }\r\n\r\n    public getByIds(ids: VisId[], options?: VisEdgeSelectionOptions): VisEdge[] {\r\n        return super.get(ids, options);\r\n    }\r\n\r\n    public getDataSet(): VisEdges {\r\n        return super.getDataSet() as VisEdges;\r\n    }\r\n\r\n    public getIds(options?: VisEdgeSelectionOptions): VisId[] {\r\n        return super.getIds(options);\r\n    }\r\n\r\n    public map(callback: (item: VisEdge, id: VisId) => any, options?: VisEdgeSelectionOptions): any[] {\r\n        return super.map(callback, options);\r\n    }\r\n\r\n    public max(field: string): VisEdge {\r\n        return super.max(field);\r\n    }\r\n\r\n    public min(field: string): VisEdge {\r\n        return super.min(field);\r\n    }\r\n\r\n    public on(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.on(event, callback);\r\n    }\r\n\r\n    public off(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.off(event, callback);\r\n    }\r\n\r\n    public removeItems(ids: VisId[], senderId?: VisId): VisId[] {\r\n        return super.remove(ids, senderId);\r\n    }\r\n\r\n    public setOptions(options?: VisDataSetQueueOptions): void {\r\n        super.setOptions(options);\r\n    }\r\n\r\n    public update(data: VisEdge[], senderId?: VisId): VisId[] {\r\n        return super.update(data, senderId);\r\n    }\r\n}\r\n\r\nexport * from './vis-network.directive';\r\nexport * from './vis-network.service';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/network/index.ts\n **/","import {\r\n  Directive,\r\n  Input,\r\n  Output,\r\n  EventEmitter,\r\n  OnDestroy,\r\n  OnInit,\r\n  OnChanges,\r\n  ElementRef,\r\n  SimpleChange } from '@angular/core';\r\n\r\nimport { VisNetworkService } from './vis-network.service';\r\n\r\nimport {\r\n  VisNetworkData,\r\n  VisNetworkOptions\r\n} from './index';\r\n\r\n/**\r\n * Use this directive with a div container to show network data.\r\n * \r\n * @export\r\n * @class VisNetworkDirective\r\n * @implements {OnInit}\r\n * @implements {OnDestroy}\r\n * @implements {OnChanges}\r\n */\r\n@Directive({\r\n  selector: '[visNetwork]'\r\n})\r\nexport class VisNetworkDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n  /**\r\n   * The name or identifier of the network (must be unique in your application).\r\n   * This property is used once on init and must not be changed.\r\n   * \r\n   * @type {string}\r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  @Input('visNetwork')\r\n  public visNetwork: string;\r\n\r\n  /**\r\n   * The data that will be used to create the network.\r\n   * Changes to the nodes or edges property won't be detected but\r\n   * changes to the reference of this object.\r\n   * Changes lead to a call to setData of this network instance.\r\n   * \r\n   * @type {VisNetworkData}\r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  @Input()\r\n  public visNetworkData: VisNetworkData;\r\n\r\n  /**\r\n   * The options that will be used with this network instance.\r\n   * Only reference changes to the whole options object will be detected\r\n   * but not changes to properties.\r\n   * Changes lead to a call to setOptions of the network instance.\r\n   * \r\n   * @type {VisNetworkOptions}\r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  @Input()\r\n  public visNetworkOptions: VisNetworkOptions;\r\n\r\n  /**\r\n   * This event will be raised when the network is initialized.\r\n   * At this point of time the network is successfully registered\r\n   * with the VisNetworkService and you can register to events.\r\n   * The event data is the name of the network as a string.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  @Output()\r\n  public initialized: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  private _visNetworkContainer: any;\r\n  private _isInitialized: boolean = false;\r\n\r\n  /**\r\n   * Creates an instance of VisNetworkDirective.\r\n   * \r\n   * @param {ElementRef} elementRef The HTML element reference.\r\n   * @param {VisNetworkService} visNetworkService The VisNetworkService.\r\n   * \r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  public constructor(private elementRef: ElementRef, private visNetworkService: VisNetworkService) {\r\n    this._visNetworkContainer = elementRef.nativeElement;\r\n  }\r\n\r\n  /**\r\n   * Create the network when at least visNetwork and visNetworkData\r\n   * are defined. \r\n   * \r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  public ngOnInit(): void {\r\n    if (!this._isInitialized && this.visNetwork && this.visNetworkData) {\r\n      this.createNetwork();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the network data or options on reference changes to\r\n   * the visNetworkData or visNetworkOptions properties.\r\n   * \r\n   * @param {{[propName: string]: SimpleChange}} changes\r\n   * \r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  public ngOnChanges(changes: {[propName: string]: SimpleChange}): void {\r\n\r\n    if (!this._isInitialized && this.visNetwork && this.visNetworkData) {\r\n      this.createNetwork();\r\n    }\r\n\r\n    for (let propertyName in changes) {\r\n      if (changes.hasOwnProperty(propertyName)) {\r\n        let change = changes[propertyName];\r\n        if (!change.isFirstChange()) {\r\n          if (propertyName === 'visNetworkData') {\r\n            this.visNetworkService.setData(this.visNetwork, changes[propertyName].currentValue);\r\n          }\r\n          if (propertyName === 'visNetworkOptions') {\r\n            this.visNetworkService.setOptions(this.visNetwork, changes[propertyName].currentValue);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calls the destroy function for this network instance.\r\n   * \r\n   * \r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  public ngOnDestroy(): void {\r\n    this._isInitialized = false;\r\n    this.visNetworkService.destroy(this.visNetwork);\r\n  }\r\n\r\n  private createNetwork(): void {\r\n    this.visNetworkService.create(\r\n      this.visNetwork,\r\n      this._visNetworkContainer,\r\n      this.visNetworkData,\r\n      this.visNetworkOptions);\r\n    this._isInitialized = true;\r\n    this.initialized.emit(this.visNetwork);\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/network/vis-network.directive.ts\n **/","import { Injectable, EventEmitter } from '@angular/core';\r\n\r\nimport {\r\n  VisNetwork,\r\n  VisFitOptions,\r\n  VisNetworkData,\r\n  VisNetworkOptions } from './index';\r\n\r\n/**\r\n * A service to create, manage and control VisNetwork instances.\r\n * \r\n * @export\r\n * @class VisNetworkService\r\n */\r\n@Injectable()\r\nexport class VisNetworkService {\r\n\r\n  /**\r\n   * Fired when the user clicks the mouse or taps on a touchscreen device.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public click: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the user double clicks the mouse or double taps on a touchscreen device.\r\n   * Since a double click is in fact 2 clicks, 2 click events are fired, followed by a double click event.\r\n   * If you do not want to use the click events if a double click event is fired,\r\n   * just check the time between click events before processing them.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public doubleClick: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the user click on the canvas with the right mouse button.\r\n   * The right mouse button does not select by default.\r\n   * You can use the method getNodeAt to select the node if you want.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public oncontext: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the user clicks and holds the mouse or taps and holds on a touchscreen device.\r\n   * A click event is also fired in this case.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public hold: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired after drawing on the canvas has been completed.\r\n   * Can be used to draw on top of the network.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public release: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the selection has changed by user action.\r\n   * This means a node or edge has been selected, added to the selection or deselected.\r\n   * All select events are only triggered on click and hold.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public select: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a node has been selected by the user.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public selectNode: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a edge has been selected by the user.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public selectEdge: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a node (or nodes) has (or have) been deselected by the user.\r\n   * The previous selection is the list of nodes and edges that were selected before the last user event.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public deselectNode: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a edge (or edges) has (or have) been deselected by the user.\r\n   * The previous selection is the list of nodes and edges that were selected before the last user event.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public deselectEdge: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when starting a drag.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public dragStart: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when dragging node(s) or the view.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public dragging: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the drag has finished.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public dragEnd: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over a node.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public hoverNode: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired if the option interaction:{hover:true} is enabled and\r\n   * the mouse moved away from a node it was hovering over before.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public blurNode: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over an edge.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public hoverEdge: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired if the option interaction:{hover:true} is enabled and\r\n   * the mouse moved away from an edge it was hovering over before.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public blurEdge: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the user zooms in or out.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public zoom: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the popup (tooltip) is shown.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public showPopup: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the popup (tooltip) is hidden.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public hidePopup: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when stabilization starts.\r\n   * This is also the case when you drag a node and the physics\r\n   * simulation restarts to stabilize again.\r\n   * Stabilization does not neccesarily imply 'without showing'.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public startStabilizing: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a multiple of the updateInterval number of iterations is reached.\r\n   * This only occurs in the 'hidden' stabilization.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public stabilizationProgress: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the 'hidden' stabilization finishes.\r\n   * This does not necessarily mean the network is stabilized;\r\n   * it could also mean that the amount of iterations defined in the options has been reached.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public stabilizationIterationsDone: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the 'hidden' stabilization finishes.\r\n   * This does not necessarily mean the network is stabilized;\r\n   * it could also mean that the amount of iterations defined in the options has been reached.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public stabilized: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the size of the canvas has been resized,\r\n   * either by a redraw call when the container div has changed in size,\r\n   * a setSize() call with new values or a setOptions() with new width and/or height values.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public resize: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired before the redrawing begins.\r\n   * The simulation step has completed at this point.\r\n   * Can be used to move custom elements before starting drawing the new frame.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public initRedraw: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired after the canvas has been cleared, scaled and translated to\r\n   * the viewing position but before all edges and nodes are drawn.\r\n   * Can be used to draw behind the network.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public beforeDrawing: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired after drawing on the canvas has been completed.\r\n   * Can be used to draw on top of the network.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public afterDrawing: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when an animation is finished.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public animationFinished: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a user changes any option in the configurator.\r\n   * The options object can be used with the setOptions method or stringified using JSON.stringify().\r\n   * You do not have to manually put the options into the network: this is done automatically.\r\n   * You can use the event to store user options in the database.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public configChange: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  private _networks: {[id: string]: VisNetwork} = {};\r\n\r\n  /**\r\n   * Creates a new network instance.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {HTMLElement} container The HTML element that contains the network view.\r\n   * @param {VisNetworkData} data The initial network nodes and edges.\r\n   * @param {VisNetworkOptions} [options] The network options.\r\n   * \r\n   * @throws {Error} Thrown when a network with the same name already exists.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public create(\r\n    visNetwork: string,\r\n    container: HTMLElement,\r\n    data: VisNetworkData,\r\n    options?: VisNetworkOptions): void {\r\n    if (this._networks[visNetwork]) {\r\n      throw new Error(`Network with id ${visNetwork} already exists.`);\r\n    }\r\n\r\n    this._networks[visNetwork] = new VisNetwork(container, data, options);\r\n  }\r\n\r\n  /**\r\n   * Remove the network from the DOM and remove all Hammer bindings and references.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public destroy(visNetwork: string): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].destroy();\r\n      delete this._networks[visNetwork];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activates an event.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {string} eventName The event name.\r\n   * @param {boolean} preventDefault Stops the default behavior of the event.\r\n   * @returns {boolean} Returns true when the event was activated.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public on(visNetwork: string, eventName: string, preventDefault?: boolean): boolean {\r\n    if (this._networks[visNetwork]) {\r\n      let that: {[index: string]: any} = this;\r\n      this._networks[visNetwork].on(eventName, (params: any) => {\r\n        let emitter = that[eventName] as EventEmitter<any>;\r\n        if (emitter) {\r\n          emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\r\n        }\r\n        if (preventDefault && params.event) {\r\n          params.event.preventDefault();\r\n        }\r\n      });\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Deactivates an event.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {string} eventName The event name.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public off(visNetwork: string, eventName: string): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].off(eventName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activates an event listener only once.\r\n   * After it has taken place, the event listener will be removed.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {string} eventName The event name.\r\n   * @returns {boolean} Returns true when the event was activated.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public once(visNetwork: string, eventName: string): boolean {\r\n    if (this._networks[visNetwork]) {\r\n      let that: {[index: string]: any} = this;\r\n      this._networks[visNetwork].on(eventName, (params: any) => {\r\n        let emitter = that[eventName] as EventEmitter<any>;\r\n        if (emitter) {\r\n          emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\r\n          this.off(visNetwork, eventName);\r\n        }\r\n      });\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Override all the data in the network.\r\n   * If stabilization is enabled in the physics module,\r\n   * the network will stabilize again.\r\n   * This method is also performed when first initializing the network.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisNetworkData} data The network data.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public setData(visNetwork: string, data: VisNetworkData): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].setData(data);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the options.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisNetworkOptions} options The network options.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public setOptions(visNetwork: string, options: VisNetworkOptions): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].setOptions(options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Selects the nodes corresponding to the id's in the input array.\r\n   * This method unselects all other objects before selecting its own objects.\r\n   * Does not fire events.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {string[]} nodeIds The node ids that should be selected.\r\n   * @param {boolean} [highlightEdges] If highlightEdges is true or undefined,\r\n   *                                   the neighbouring edges will also be selected.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public selectNodes(visNetwork: string, nodeIds: string[], highlightEdges?: boolean): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].selectNodes(nodeIds, highlightEdges);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an object with selected nodes and edges ids.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @returns {{ nodes: string[], edges: string[] }}\r\n   * The selected node and edge ids or undefined when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getSelection(visNetwork: string): { nodes: string[], edges: string[] } {\r\n    if (this._networks[visNetwork]) {\r\n      return this._networks[visNetwork].getSelection();\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of selected node ids.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @returns {string[]} The selected node ids or undefined when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getSelectedNodes(visNetwork: string): string[] {\r\n    if (this._networks[visNetwork]) {\r\n      return this._networks[visNetwork].getSelectedNodes();\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of selected edge ids.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @returns {string[]} The selected edge ids or undefined when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getSelectedEdges(visNetwork: string): string[] {\r\n    if (this._networks[visNetwork]) {\r\n      return this._networks[visNetwork].getSelectedEdges();\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Unselect all objects.\r\n   * Does not fire events.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public unselectAll(visNetwork: string): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].unselectAll();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Zooms out so all nodes fit on the canvas.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisFitOptions} [options] Options to customize.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public fit(visNetwork: string, options?: VisFitOptions): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].fit(options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Redraw the network.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public redraw(visNetwork: string): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].redraw();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Programatically enable the edit mode.\r\n   * Similar effect to pressing the edit button.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public enableEditMode(visNetwork: string): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].enableEditMode();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Go into addEdge mode.\r\n   * The explaination from addNodeMode applies here as well.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public addEdgeMode(visNetwork: string): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].addEdgeMode();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Programatically disable the edit mode.\r\n   * Similar effect to pressing the close icon\r\n   * (small cross in the corner of the toolbar).\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public disableEditMode(visNetwork: string): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].disableEditMode();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete selected.\r\n   * Having edit mode or manipulation enabled is not required.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public deleteSelected(visNetwork: string): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].deleteSelected();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Makes a cluster.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {*} [options] The joinCondition function is presented with all nodes.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public cluster(visNetwork: string, options?: any): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].cluster(options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Opens the cluster, releases the contained nodes and edges,\r\n   * removing the cluster node and cluster edges.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {string} nodeId The node id that represents the cluster.\r\n   * @param {*} [options] Cluster options.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public openCluster(visNetwork: string, nodeId: string, options?: any): void {\r\n    if (this._networks[visNetwork]) {\r\n      this._networks[visNetwork].openCluster(nodeId, options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the node whose ID has been supplied is a cluster.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {string} nodeId The associated node id.\r\n   * @returns {boolean} True if the node whose ID has been supplied is a cluster.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public isCluster(visNetwork: string, nodeId: string): boolean {\r\n    if (this._networks[visNetwork]) {\r\n      return this._networks[visNetwork].isCluster(nodeId);\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * If you like the layout of your network and would like it to start in the same way next time,\r\n   * ask for the seed using this method and put it in the layout.randomSeed option.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @returns {number} The seed of the current network or -1 when the network is not defined.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getSeed(visNetwork: string): number {\r\n    if (this._networks[visNetwork]) {\r\n      return this._networks[visNetwork].getSeed();\r\n    }\r\n\r\n    return -1;\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/network/vis-network.service.ts\n **/","import * as Vis from 'vis';\r\n\r\nexport interface VisTimelineItem extends Vis.DataItem {}\r\nexport interface VisTimelineGroup extends Vis.DataGroup {}\r\nexport interface VisDataSetOptions extends Vis.DataSetOptions {}\r\nexport interface VisTimelineOptions extends Vis.TimelineOptions {}\r\nexport class VisTimelineItems extends Vis.DataSet<VisTimelineItem> {\r\n    public constructor(data?: Array<VisTimelineItem>, options?: VisDataSetOptions) {\r\n        super(data, options);\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this.length;\r\n    }\r\n\r\n    public add(data: VisTimelineItem | VisTimelineItem[], senderId?: VisId): VisId[] {\r\n        return super.add(data, senderId);\r\n    }\r\n\r\n    public clear(senderId?: VisId): VisId[] {\r\n        return super.clear(senderId);\r\n    }\r\n\r\n    public distinct(field: string): any[] {\r\n        return super.distinct(field);\r\n    }\r\n\r\n    public flush(): void {\r\n        super.flush();\r\n    }\r\n\r\n    public forEach(callback: (item: VisTimelineItem, id: VisId) => void, options?: VisItemSelectionOptions): void {\r\n        super.forEach(callback, options);\r\n    }\r\n\r\n    public getAll(options?: VisItemSelectionOptions): VisTimelineItem[] {\r\n        return super.get(options);\r\n    }\r\n\r\n    public getById(id: VisId, options?: VisItemSelectionOptions): VisTimelineItem {\r\n        return super.get(id, options);\r\n    }\r\n\r\n    public getByIds(ids: VisId[], options?: VisItemSelectionOptions): VisTimelineItem[] {\r\n        return super.get(ids, options);\r\n    }\r\n\r\n    public getDataSet(): VisTimelineItems {\r\n        return super.getDataSet() as VisTimelineItems;\r\n    }\r\n\r\n    public getIds(options?: VisItemSelectionOptions): VisId[] {\r\n        return super.getIds(options);\r\n    }\r\n\r\n    public map(callback: (item: VisTimelineItem, id: VisId) => any, options?: VisItemSelectionOptions): any[] {\r\n        return super.map(callback, options);\r\n    }\r\n\r\n    public max(field: string): VisTimelineItem {\r\n        return super.max(field);\r\n    }\r\n\r\n    public min(field: string): VisTimelineItem {\r\n        return super.min(field);\r\n    }\r\n\r\n    public on(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.on(event, callback);\r\n    }\r\n\r\n    public off(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.off(event, callback);\r\n    }\r\n\r\n    public removeItems(ids: VisId[], senderId?: VisId): VisId[] {\r\n        return super.remove(ids, senderId);\r\n    }\r\n\r\n    public setOptions(options?: VisDataSetQueueOptions): void {\r\n        super.setOptions(options);\r\n    }\r\n\r\n    public update(data: VisTimelineItem[], senderId?: VisId): VisId[] {\r\n        return super.update(data, senderId);\r\n    }\r\n}\r\nexport class VisTimelineGroups extends Vis.DataSet<VisTimelineGroup> {\r\n    public constructor(data?: Array<VisTimelineGroup>, options?: VisDataSetOptions) {\r\n        super(data, options);\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this.length;\r\n    }\r\n\r\n    public add(data: VisTimelineGroup | VisTimelineGroup[], senderId?: VisId): VisId[] {\r\n        return super.add(data, senderId);\r\n    }\r\n\r\n    public clear(senderId?: VisId): VisId[] {\r\n        return super.clear(senderId);\r\n    }\r\n\r\n    public distinct(field: string): any[] {\r\n        return super.distinct(field);\r\n    }\r\n\r\n    public flush(): void {\r\n        super.flush();\r\n    }\r\n\r\n    public forEach(callback: (item: VisTimelineGroup, id: VisId) => void, options?: VisGroupSelectionOptions): void {\r\n        super.forEach(callback, options);\r\n    }\r\n\r\n    public getAll(options?: VisGroupSelectionOptions): VisTimelineGroup[] {\r\n        return super.get(options);\r\n    }\r\n\r\n    public getById(id: VisId, options?: VisGroupSelectionOptions): VisTimelineGroup {\r\n        return super.get(id, options);\r\n    }\r\n\r\n    public getByIds(ids: VisId[], options?: VisGroupSelectionOptions): VisTimelineGroup[] {\r\n        return super.get(ids, options);\r\n    }\r\n\r\n    public getDataSet(): VisTimelineGroups {\r\n        return super.getDataSet() as VisTimelineGroups;\r\n    }\r\n\r\n    public getIds(options?: VisGroupSelectionOptions): VisId[] {\r\n        return super.getIds(options);\r\n    }\r\n\r\n    public map(callback: (item: VisTimelineGroup, id: VisId) => any, options?: VisGroupSelectionOptions): any[] {\r\n        return super.map(callback, options);\r\n    }\r\n\r\n    public max(field: string): VisTimelineGroup {\r\n        return super.max(field);\r\n    }\r\n\r\n    public min(field: string): VisTimelineGroup {\r\n        return super.min(field);\r\n    }\r\n\r\n    public on(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.on(event, callback);\r\n    }\r\n\r\n    public off(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.off(event, callback);\r\n    }\r\n\r\n    public removeItems(ids: VisId[], senderId?: VisId): VisId[] {\r\n        return super.remove(ids, senderId);\r\n    }\r\n\r\n    public setOptions(options?: VisDataSetQueueOptions): void {\r\n        super.setOptions(options);\r\n    }\r\n\r\n    public update(data: VisTimelineGroup[], senderId?: VisId): VisId[] {\r\n        return super.update(data, senderId);\r\n    }\r\n}\r\n\r\nexport interface VisDataSetQueueOptions extends Vis.DataSetQueueOptions {}\r\nexport interface VisItemSelectionOptions extends Vis.DataSelectionOptions<VisTimelineItem> {}\r\nexport interface VisGroupSelectionOptions extends Vis.DataSelectionOptions<VisTimelineGroup> {}\r\nexport type VisId = Vis.IdType;\r\nexport type VisDate = Vis.DateType;\r\nexport type VisTimelineEvents = Vis.TimelineEvents;\r\nexport interface VisTimelineFitOptions extends Vis.TimelineFitOptions {}\r\nexport interface VisTimelineEventPropertiesResult extends  Vis.TimelineEventPropertiesResult {}\r\n\r\nexport class VisTimeline extends Vis.Timeline {}\r\n\r\nexport * from './vis-timeline.service';\r\nexport * from './vis-timeline.directive';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/timeline/index.ts\n **/","import {\r\n  Directive,\r\n  Input,\r\n  Output,\r\n  EventEmitter,\r\n  OnDestroy,\r\n  OnInit,\r\n  OnChanges,\r\n  ElementRef,\r\n  SimpleChange } from '@angular/core';\r\n\r\nimport { VisTimelineService } from './vis-timeline.service';\r\nimport {\r\n    VisTimelineItems,\r\n    VisTimelineGroups,\r\n    VisTimelineOptions } from './index';\r\n\r\n/**\r\n * Use this directive with a div container to show timeline data.\r\n * \r\n * @export\r\n * @class VisTimelineDirective\r\n * @implements {OnInit}\r\n * @implements {OnDestroy}\r\n * @implements {OnChanges}\r\n */\r\n@Directive({\r\n  selector: '[visTimeline]'\r\n})\r\nexport class VisTimelineDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n    /**\r\n     * The name or identifier of the timeline (must be unique in your application).\r\n     * This property is used once on init and must not be changed.\r\n     * \r\n     * @type {string}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Input('visTimeline')\r\n    public visTimeline: string;\r\n\r\n    /**\r\n     * The data that will be used to create the timeline.\r\n     * Changes will be detected. If the reference changes then\r\n     * setData will be called on this timeline instance.\r\n     * \r\n     * @type {VisTimelineItems}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Input()\r\n    public visTimelineItems: VisTimelineItems;\r\n\r\n    /**\r\n     * The groups that will be used to create the timeline.\r\n     * Changes will be detected. If the reference changes then\r\n     * setGroups will be called on this timeline instance.\r\n     * \r\n     * @type {VisTimelineGroups}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Input()\r\n    public visTimelineGroups: VisTimelineGroups;\r\n\r\n    /**\r\n     * The options that will be used with this timeline.\r\n     * Changes will be detected. If the reference changes then\r\n     * setOptions will be called on this timeline instance.\r\n     * \r\n     * @type {VisTimelineOptions}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Input()\r\n    public visTimelineOptions: VisTimelineOptions;\r\n\r\n    /**\r\n     * This event will be raised when the timline is initialized.\r\n     * At this point of time the timeline is successfully registered\r\n     * with the VisNetworkService and you can register to events.\r\n     * The event data is the name of the timeline as a string.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Output()\r\n    public initialized: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    private _visTimelineContainer: any;\r\n    private _isInitialized: boolean = false;\r\n\r\n    /**\r\n     * Creates an instance of VisTimelineDirective.\r\n     * \r\n     * @param {ElementRef} elementRef The HTML element reference.\r\n     * @param {VisTimelineService} visTimelineService The VisTimelineService.\r\n     * \r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    public constructor(private elementRef: ElementRef, private visTimelineService: VisTimelineService) {\r\n        this._visTimelineContainer = elementRef.nativeElement;\r\n    }\r\n\r\n    /**\r\n     * Create the timeline when at least visNetwork and visNetworkData\r\n     * are defined.\r\n     * \r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    public ngOnInit(): void {\r\n        if (!this._isInitialized && this.visTimeline && this.visTimelineItems) {\r\n            this.createTimeline();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the timeline data, groups or options on reference changes to\r\n     * the visTimelineItems, visTimelineGroups or visTimelineOptions properties.\r\n     * \r\n     * @param {{[propName: string]: SimpleChange}} changes\r\n     * \r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    public ngOnChanges(changes: {[propName: string]: SimpleChange}): void {\r\n        if (!this._isInitialized && this.visTimeline && this.visTimelineItems) {\r\n            this.createTimeline();\r\n        }\r\n\r\n        for (let propertyName in changes) {\r\n          if (changes.hasOwnProperty(propertyName)) {\r\n            let change = changes[propertyName];\r\n            if (!change.isFirstChange()) {\r\n              if (propertyName === 'visTimelineItems') {\r\n                  this.visTimelineService.setItems(this.visTimeline, changes[propertyName].currentValue);\r\n              }\r\n              if (propertyName === 'visTimelineOptions') {\r\n                  this.visTimelineService.setOptions(this.visTimeline, changes[propertyName].currentValue);\r\n              }\r\n              if (propertyName === 'visTimelineGroups') {\r\n                  this.visTimelineService.setGroups(this.visTimeline, changes[propertyName].currentValue);\r\n              }\r\n            }\r\n          }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calls the destroy function for this timeline instance.\r\n     * \r\n     * \r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    public ngOnDestroy(): void {\r\n        this._isInitialized = false;\r\n        this.visTimelineService.destroy(this.visTimeline);\r\n    }\r\n\r\n    private createTimeline(): void {\r\n        if (this.visTimelineGroups) {\r\n            this.visTimelineService.createWithItemsAndGroups(\r\n                this.visTimeline,\r\n                this._visTimelineContainer,\r\n                this.visTimelineItems,\r\n                this.visTimelineGroups,\r\n                this.visTimelineOptions);\r\n        } else {\r\n            this.visTimelineService.createWithItems(\r\n                this.visTimeline,\r\n                this._visTimelineContainer,\r\n                this.visTimelineItems,\r\n                this.visTimelineOptions);\r\n        }\r\n        this._isInitialized = true;\r\n        this.initialized.emit(this.visTimeline);\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/timeline/vis-timeline.directive.ts\n **/","import { Injectable, EventEmitter } from '@angular/core';\r\nimport {\r\n    VisDate,\r\n    VisId,\r\n    VisTimelineItems,\r\n    VisTimelineGroups,\r\n    VisTimelineOptions,\r\n    VisTimelineFitOptions,\r\n    VisTimelineEvents,\r\n    VisTimelineEventPropertiesResult,\r\n    VisTimeline } from './index';\r\n\r\n/**\r\n * A service to create, manage and control VisTimeline instances.\r\n * \r\n * @export\r\n * @class VisTimelineService\r\n */\r\n@Injectable()\r\nexport class VisTimelineService {\r\n    /**\r\n     * Fired when the current time bar redraws.\r\n     * The rate depends on the zoom level.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public currentTimeTick: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when clicked inside the Timeline.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public click: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when right-clicked inside the Timeline.\r\n     * Note that in order to prevent the context menu from showing up,\r\n     * default behavior of the event must be stopped.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public contextmenu: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when double clicked inside the Timeline.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public doubleClick: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * \tFired after the dragging of a group is finished.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public groupDragged: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired once after each graph redraw.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public changed: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired repeatedly when the timeline window is being changed.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public rangechange: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired once after the timeline window has been changed.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public rangechanged: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired after the user selects or deselects items by tapping or holding them.\r\n     * When a use taps an already selected item, the select event is fired again.\r\n     * Not fired when the method setSelectionis executed.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public select: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when the user moves the mouse over an item.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public itemover: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when the user moves the mouse out of an item.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public itemout: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired repeatedly when the user is dragging the custom time bar.\r\n     * Only available when the custom time bar is enabled.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public timechange: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired once after the user has dragged the custom time bar.\r\n     * Only available when the custom time bar is enabled.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public timechanged: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    private _timelines: {[id: string]: VisTimeline} = {};\r\n\r\n    /**\r\n     * Creates a new timeline instance.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {HTMLElement} container The HTML element that contains the timeline view.\r\n     * @param {VisTimelineItems} items The initial timeline items.\r\n     * @param {VisTimelineOptions} [options] The timeline options.\r\n     * \r\n     * @throws {Error} Thrown when timeline already exists.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public createWithItems(\r\n        visTimeline: string,\r\n        container: HTMLElement,\r\n        items: VisTimelineItems,\r\n        options?: VisTimelineOptions): void {\r\n        if (this._timelines[visTimeline]) {\r\n            throw new Error(this.alreadyExistsError(visTimeline));\r\n        }\r\n\r\n        this._timelines[visTimeline] = new VisTimeline(container, items, options);\r\n    }\r\n\r\n    /**\r\n     * Creates a new timeline instance.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {HTMLElement} container The HTML element that contains the timeline view.\r\n     * @param {VisTimelineItems} items The initial timeline items.\r\n     * @param {VisTimelineGroups} groups The initial timeline groups.\r\n     * @param {VisTimelineOptions} [options] The timeline options.\r\n     * \r\n     * @throws {Error} Thrown when timeline already exists.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public createWithItemsAndGroups(\r\n        visTimeline: string,\r\n        container: HTMLElement,\r\n        items: VisTimelineItems,\r\n        groups: VisTimelineGroups,\r\n        options?: VisTimelineOptions): void {\r\n        if (this._timelines[visTimeline]) {\r\n            throw new Error(this.alreadyExistsError(visTimeline));\r\n        }\r\n\r\n        this._timelines[visTimeline] = new VisTimeline(container, items, groups, options);\r\n    }\r\n\r\n    /**\r\n     * Add new vertical bar representing a custom time that can be dragged by the user.\r\n     * The id is added as CSS class name of the custom time bar,\r\n     * allowing to style multiple time bars differently.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} time Parameter time can be a Date, Number, or String, and is new Date() by default.\r\n     * @param {VisId} [id] Parameter id can be Number or String and is undefined by default. \r\n     * @returns {VisId} The method returns id of the created bar.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public addCustomTime(visTimeline: string, time: VisDate, id?: VisId): VisId {\r\n        if (this._timelines[visTimeline]) {\r\n            return this._timelines[visTimeline].addCustomTime(time, id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adjust the visible window such that it fits all items.\r\n     * See also function focus(id).\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineFitOptions} [options] Optional options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public fit(visTimeline: string, options?: VisTimelineFitOptions): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].fit(options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adjust the visible window such that the selected item is centered on screen. \r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId} id The id of the item.\r\n     * @param {VisTimelineFitOptions} [options] Options options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public focusOnId(visTimeline: string, id: VisId, options?: VisTimelineFitOptions): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].focus(id, options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adjust the visible window such that the selected items are centered on screen. \r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId[]} ids The item ids.\r\n     * @param {VisTimelineFitOptions} [options] Optional options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public focusOnIds(visTimeline: string, ids: VisId[], options?: VisTimelineFitOptions): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].focus(ids, options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current time.\r\n     * Only applicable when option showCurrentTime is true.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {Date} The current time.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getCurrentTime(visTimeline: string): Date {\r\n        if (this._timelines[visTimeline]) {\r\n            return this._timelines[visTimeline].getCurrentTime();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieve the custom time from the custom time bar with given id.\r\n     * Id is undefined by default.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId} [id] The time bar id.\r\n     * @returns {Date} The custom time.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getCustomTime(visTimeline: string, id?: VisId): Date {\r\n        if (this._timelines[visTimeline]) {\r\n            return this._timelines[visTimeline].getCustomTime(id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an Object with relevant properties from an event.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {Event} event The event.\r\n     * @returns {VisTimelineEventPropertiesResult} Properties of an event\r\n     *  \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getEventProperties(visTimeline: string, event: Event): VisTimelineEventPropertiesResult {\r\n        if (this._timelines[visTimeline]) {\r\n            return this._timelines[visTimeline].getEventProperties(event);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the range of all the items as an object containing min: Date and max: Date.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {{ min: Date, max: Date }} The min and max dates.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getItemRange(visTimeline: string): { min: Date, max: Date } {\r\n        if (this._timelines[visTimeline]) {\r\n            return this._timelines[visTimeline].getItemRange();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get an array with the ids of the currently selected items.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {VisId[]} The currently selected items.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getSelection(visTimeline: string): VisId[] {\r\n        if (this._timelines[visTimeline]) {\r\n            return this._timelines[visTimeline].getSelection();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get an array with the ids of the currently visible items.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {VisId[]} The currently visible items.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getVisibleItems(visTimeline: string): VisId[] {\r\n        if (this._timelines[visTimeline]) {\r\n            return this._timelines[visTimeline].getVisibleItems();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current visible window.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {{ start: Date, end: Date }} Returns an object with properties start: Date and end: Date.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getWindow(visTimeline: string): { start: Date, end: Date } {\r\n        if (this._timelines[visTimeline]) {\r\n            return this._timelines[visTimeline].getWindow();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \tMove the window such that given time is centered on screen.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} time Parameter time can be a Date, Number, or String.\r\n     * @param {VisTimelineFitOptions} [options] Optional options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public moveTo(visTimeline: string, time: VisDate, options?: VisTimelineFitOptions): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].moveTo(time, options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force a redraw of the Timeline.\r\n     * The size of all items will be recalculated.\r\n     * Can be useful to manually redraw when option autoResize=false and the window has been resized,\r\n     * or when the items CSS has been changed.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public redraw(visTimeline: string): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].redraw();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove vertical bars previously added to the timeline via addCustomTime method.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId} id Parameter id is the ID of the custom vertical bar returned by addCustomTime method.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public removeCustomTime(visTimeline: string, id: VisId): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].removeCustomTime(id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a current time.\r\n     * This can be used for example to ensure that a client's time is synchronized\r\n     * with a shared server time.\r\n     * Only applicable when option showCurrentTime is true.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} time time can be a Date object, numeric timestamp, or ISO date string.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setCurrentTime(visTimeline: string, time: VisDate): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setCurrentTime(time);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \tAdjust the time of a custom time bar.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} time Parameter time can be a Date object, numeric timestamp, or ISO date string.\r\n     * @param {VisId} [id] Parameter id is the id of the custom time bar, and is undefined by default.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setCustomTime(visTimeline: string, time: VisDate, id?: VisId): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setCustomTime(time, id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adjust the title attribute of a custom time bar.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {string} title Parameter title is the string to be set as title. Use empty string to hide the title completely.\r\n     * @param {VisId} [id] Parameter id is the id of the custom time bar, and is undefined by default.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setCustomTimeTitle(visTimeline: string, title: string, id?: VisId): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setCustomTimeTitle(title, id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set both groups and items at once.\r\n     * Both properties are optional.\r\n     * This is a convenience method for individually calling both setItems(items) and setGroups(groups).\r\n     * Both items and groups can be an Array with Objects, a DataSet (offering 2 way data binding),\r\n     * or a DataView (offering 1 way data binding).\r\n     * For each of the groups, the items of the timeline are filtered on the property group,\r\n     * which must correspond with the id of the group.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {{ groups?: VisTimelineGroups; items?: VisTimelineItems }} data The new timline data.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setData(visTimeline: string, data: { groups?: VisTimelineGroups; items?: VisTimelineItems }): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setData(data);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a data set with groups for the Timeline.\r\n     * For each of the groups, the items of the timeline are filtered on the property group,\r\n     * which must correspond with the id of the group.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineGroups} groups a DataSet (offering 2 way data binding)\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setGroups(visTimeline: string, groups: VisTimelineGroups): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setGroups(groups);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a data set with items for the Timeline.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineItems} items can be an Array with Objects, a DataSet (offering 2 way data binding)\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setItems(visTimeline: string, items: VisTimelineItems): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setItems(items);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set or update options.\r\n     * It is possible to change any option of the timeline at any time.\r\n     * You can for example switch orientation on the fly.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineOptions} options The new options of the timeline.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setOptions(visTimeline: string, options: VisTimelineOptions): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setOptions(options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select one item by its id.#\r\n     * The currently selected items will be unselected.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId} id The id of the item that should be selected.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setSelectionToId(visTimeline: string, id: VisId): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setSelection(id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select multiple items by their id.\r\n     * The currently selected items will be unselected.\r\n     * To unselect all selected items, call `setSelection([])`.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId[]} ids The ids of the irems that should be selected.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setSelectionToIds(visTimeline: string, ids: VisId[]): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setSelection(ids);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the current visible window.\r\n     * \r\n     * If the parameter value of start or end is null, the parameter will be left unchanged.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} start The parameters start can be a Date, Number, or String.\r\n     * @param {VisDate} end The parameters end can be a Date, Number, or String.\r\n     * @param {VisTimelineFitOptions} [options] Optional options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setWindow(visTimeline: string, start: VisDate, end: VisDate, options?: VisTimelineFitOptions): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].setWindow(start, end, options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the Timeline.\r\n     * The timeline is removed from memory.\r\n     * All DOM elements and event listeners are cleaned up.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public destroy(visTimeline: string): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].destroy();\r\n            delete this._timelines[visTimeline];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Activates an event.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineEvents} eventName The event name.\r\n     * @param {boolean} preventDefault Stops the default behavior of the event.\r\n     * @returns {boolean} Returns true when the event was activated.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public on(visTimeline: string, eventName: VisTimelineEvents, preventDefault?: boolean): boolean {\r\n        if (this._timelines[visTimeline]) {\r\n            let that: {[index: string]: any} = this;\r\n            this._timelines[visTimeline].on(eventName, (params: any) => {\r\n                let emitter = that[eventName] as EventEmitter<any>;\r\n                if (emitter) {\r\n                    emitter.emit(params ? [visTimeline].concat(params) : visTimeline);\r\n                }\r\n                if (preventDefault && params.event) {\r\n                    params.event.preventDefault();\r\n                }\r\n            });\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Deactivates an event.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineEvents} eventName The event name.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public off(visTimeline: string, eventName: VisTimelineEvents): void {\r\n        if (this._timelines[visTimeline]) {\r\n            this._timelines[visTimeline].off(eventName, undefined);\r\n        }\r\n    }\r\n\r\n    private doesNotExistError(visTimeline: string): string {\r\n        return `Timeline with id ${visTimeline} does not exist.`;\r\n    }\r\n\r\n    private alreadyExistsError(visTimeline: string): string {\r\n        return `Timeline with id ${visTimeline} already exists.`;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/timeline/vis-timeline.service.ts\n **/","module.exports = \"<div class=\\\"container\\\">\\r\\n  <div class=\\\"header clearfix\\\">\\r\\n    <nav>\\r\\n      <ul class=\\\"nav nav-pills pull-right\\\">\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/home\\\">Home</a></li>\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/network\\\">Network</a></li>\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/timeline\\\">Timeline</a></li>\\r\\n      </ul>\\r\\n    </nav>\\r\\n    <h3 class=\\\"text-muted\\\">ng2-vis - an angular2 vis.js wrapper</h3>\\r\\n  </div>\\r\\n  <router-outlet></router-outlet>\\r\\n</div>\\r\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/demo.component.html\n ** module id = 138\n ** module chunks = 1\n **/","import { Component } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'example-app',\r\n  template: require('./demo.component.html'),\r\n})\r\nexport class DemoComponent {\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo/demo.component.ts\n **/","import { NgModule } from '@angular/core';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { BrowserModule } from '@angular/platform-browser';\r\nimport { CommonModule } from '@angular/common';\r\nimport { RouterModule }   from '@angular/router';\r\n\r\nimport { VisNetworkExampleComponent } from './network/network-example.component';\r\nimport { VisTimelineExampleComponent } from './timeline/timeline-example.component';\r\nimport { VisModule } from '../ng2-vis';\r\nimport { DemoComponent } from './demo.component';\r\nimport { HomeComponent } from './home/home.component';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    DemoComponent,\r\n    HomeComponent,\r\n    VisNetworkExampleComponent,\r\n    VisTimelineExampleComponent\r\n  ],\r\n  imports: [\r\n    BrowserModule,\r\n    FormsModule,\r\n    VisModule,\r\n    CommonModule,\r\n    RouterModule.forRoot([\r\n      { path: 'timeline', component: VisTimelineExampleComponent },\r\n      { path: '', redirectTo: '/home', pathMatch: 'full' },\r\n      { path: 'home', component: HomeComponent },\r\n      { path: 'network', component: VisNetworkExampleComponent },\r\n      { path: '**', component: HomeComponent }\r\n    ])\r\n  ],\r\n  providers: [],\r\n  bootstrap: [DemoComponent]\r\n})\r\nexport class VisDemoModule {\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo/demo.module.ts\n **/","module.exports = \"<div class=\\\"jumbotron\\\">\\r\\n  <h1>ng2-vis</h1>\\r\\n  <p class=\\\"lead\\\"><strong>Note:</strong> these examples mimic the ones for <code>vis</code>, but using <code>ng2-vis</code>.</p>\\r\\n  <p>\\r\\n    <a class=\\\"btn btn-lg btn-success\\\" href=\\\"https://github.com/seveves/ng2-vis\\\" role=\\\"button\\\">Get it on GitHub</a>\\r\\n    <a class=\\\"btn btn-lg btn-success\\\" href=\\\"http://visjs.org\\\" role=\\\"button\\\">Check out visjs.org</a>\\r\\n  </p>\\r\\n</div>\\r\\n<h2>Examples</h2>\\r\\n<div class=\\\"row\\\">\\r\\n  <div class=\\\"col-sm-6 col-md-4\\\">\\r\\n    <div class=\\\"thumbnail\\\">\\r\\n      <img src=\\\"http://visjs.org/images/network.png\\\" alt=\\\"Network Examples\\\">\\r\\n      <div class=\\\"caption\\\">\\r\\n        <h3>Network</h3>\\r\\n        <p>Display dynamic, automatically organised, customizable network views.</p>\\r\\n        <p><a routerLink=\\\"/network\\\" class=\\\"btn btn-primary\\\" role=\\\"button\\\">Examples</a></p>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n  <div class=\\\"col-sm-6 col-md-4\\\">\\r\\n    <div class=\\\"thumbnail\\\">\\r\\n      <img src=\\\"http://visjs.org/images/timeline.png\\\" alt=\\\"Timeline Examples\\\">\\r\\n      <div class=\\\"caption\\\">\\r\\n        <h3>Timeline</h3>\\r\\n        <p>Create a fully customizable, interactive timeline with items and ranges.</p>\\r\\n        <p><a routerLink=\\\"/timeline\\\" class=\\\"btn btn-primary\\\" role=\\\"button\\\">Examples</a></p>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n</div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/home/home.component.html\n ** module id = 139\n ** module chunks = 1\n **/","import { Component } from '@angular/core';\r\n\r\n@Component({\r\n    selector: 'home-example',\r\n    template: require('./home.component.html'),\r\n})\r\nexport class HomeComponent {}\n\n\n/** WEBPACK FOOTER **\n ** ./demo/home/home.component.ts\n **/","import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n\r\nimport { VisDemoModule } from './demo.module';\r\nplatformBrowserDynamic().bootstrapModule(VisDemoModule);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo/index.ts\n **/","module.exports = \".network-canvas {\\r\\n    width: 100%;\\r\\n    height: 400px;\\r\\n    border: 1px solid lightgray;\\r\\n}\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/network/network-example.component.css\n ** module id = 140\n ** module chunks = 1\n **/","module.exports = \"<h2>Network</h2>\\r\\n<h3>Basic usage</h3>\\r\\n<div class=\\\"network-canvas\\\" [visNetwork]=\\\"visNetwork\\\" [visNetworkData]=\\\"visNetworkData\\\" [visNetworkOptions]=\\\"visNetworkOptions\\\" (initialized)=\\\"networkInitialized()\\\"></div>\\r\\n<button type=\\\"button\\\" class=\\\"btn btn-default\\\" (click)=\\\"addNode()\\\">Add node</button>\\r\\n<p><strong>Note:</strong> Open your dev tools to see the console output when the network receives click events.</p>\\r\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/network/network-example.component.html\n ** module id = 141\n ** module chunks = 1\n **/","import { Component, OnInit, OnDestroy } from '@angular/core';\r\n\r\nimport {\r\n    VisNode,\r\n    VisNodes,\r\n    VisEdges,\r\n    VisNetworkService,\r\n    VisNetworkData,\r\n    VisNetworkOptions } from '../../components/network';\r\n\r\nclass ExampleNetworkData implements VisNetworkData {\r\n    public nodes: VisNodes;\r\n    public edges: VisEdges;\r\n}\r\n\r\n@Component({\r\n    selector: 'network-example',\r\n    template: require('./network-example.component.html'),\r\n    styles: [\r\n        require('./network-example.component.css')\r\n    ]\r\n})\r\nexport class VisNetworkExampleComponent implements OnInit, OnDestroy {\r\n\r\n    public visNetwork: string = 'networkId1';\r\n    public visNetworkData: ExampleNetworkData;\r\n    public visNetworkOptions: VisNetworkOptions;\r\n\r\n    public constructor(private visNetworkService: VisNetworkService) { }\r\n\r\n    public addNode(): void {\r\n        let newId = this.visNetworkData.nodes.getLength() + 1;\r\n        this.visNetworkData.nodes.add({ id: newId.toString(), label: 'Node ' + newId });\r\n        this.visNetworkService.fit(this.visNetwork);\r\n    }\r\n\r\n    public networkInitialized(): void {\r\n        // now we can use the service to register on events\r\n        this.visNetworkService.on(this.visNetwork, 'click');\r\n\r\n        // open your console/dev tools to see the click params\r\n        this.visNetworkService.click\r\n            .subscribe((eventData: any[]) => {\r\n                if (eventData[0] === this.visNetwork) {\r\n                    console.log(eventData[1]);\r\n                }\r\n            });\r\n    }\r\n\r\n    public ngOnInit(): void {\r\n        let nodes = new VisNodes([\r\n            { id: '1', label: 'Node 1' },\r\n            { id: '2', label: 'Node 2' },\r\n            { id: '3', label: 'Node 3' },\r\n            { id: '4', label: 'Node 4' },\r\n            { id: '5', label: 'Node 5', title: 'Title of Node 5' }]);\r\n\r\n        let edges = new VisEdges([\r\n            { from: '1', to: '3' },\r\n            { from: '1', to: '2' },\r\n            { from: '2', to: '4' },\r\n            { from: '2', to: '5' }]);\r\n\r\n        this.visNetworkData = {\r\n            nodes: nodes,\r\n            edges: edges\r\n        };\r\n\r\n        this.visNetworkOptions = {};\r\n    }\r\n\r\n    public ngOnDestroy(): void {\r\n        this.visNetworkService.off(this.visNetwork, 'click');\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo/network/network-example.component.ts\n **/","module.exports = \"\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/timeline/timeline-example.component.css\n ** module id = 142\n ** module chunks = 1\n **/","module.exports = \"<h2>Timeline</h2>\\r\\n<h3>Basic usage</h3>\\r\\n<div [visTimeline]=\\\"visTimeline\\\" [visTimelineItems]=\\\"visTimelineItems\\\" (initialized)=\\\"timelineInitialized()\\\"></div>\\r\\n<button type=\\\"button\\\" class=\\\"btn btn-default\\\" (click)=\\\"addItem()\\\">Add and focus</button>\\r\\n<p><strong>Note:</strong> Open your dev tools to see the console output when the timeline receives click events.</p>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/timeline/timeline-example.component.html\n ** module id = 143\n ** module chunks = 1\n **/","import { Component, OnInit, OnDestroy } from '@angular/core';\r\n\r\nimport { VisTimelineService, VisTimelineItems } from '../../components/timeline';\r\n\r\n@Component({\r\n    selector: 'timeline-example',\r\n    template: require('./timeline-example.component.html'),\r\n    styles: [\r\n        require('./timeline-example.component.css')\r\n    ]\r\n})\r\nexport class VisTimelineExampleComponent implements OnInit, OnDestroy {\r\n\r\n    public visTimeline: string = 'timelineId1';\r\n    public visTimelineItems: VisTimelineItems;\r\n\r\n    public constructor(private visTimelineService: VisTimelineService) {}\r\n\r\n    public timelineInitialized(): void {\r\n        console.log('timeline initialized');\r\n\r\n        // now we can use the service to register on events\r\n        this.visTimelineService.on(this.visTimeline, 'click');\r\n\r\n        // open your console/dev tools to see the click params\r\n        this.visTimelineService.click\r\n            .subscribe((eventData: any[]) => {\r\n                if (eventData[0] === this.visTimeline) {\r\n                    console.log(eventData[1]);\r\n                }\r\n            });\r\n    }\r\n\r\n    public addItem(): void {\r\n        let newLength = this.visTimelineItems.getLength() + 1;\r\n        this.visTimelineItems.add(\r\n            {id: newLength, content: 'item ' + newLength, start: Date.now() }\r\n        );\r\n        this.visTimelineService.focusOnIds(this.visTimeline, [1, newLength]);\r\n    }\r\n\r\n    public ngOnInit(): void {\r\n        this.visTimelineItems = new VisTimelineItems([\r\n            {id: 1, content: 'item 1', start: '2016-04-20'},\r\n            {id: 2, content: 'item 2', start: '2016-04-14'},\r\n            {id: 3, content: 'item 3', start: '2016-04-18'},\r\n            {id: 4, content: 'item 4', start: '2016-04-16', end: '2016-04-19'},\r\n            {id: 5, content: 'item 5', start: '2016-04-25'},\r\n            {id: 6, content: 'item 6', start: '2016-04-27', type: 'point'}\r\n        ]);\r\n    }\r\n\r\n    public ngOnDestroy(): void {\r\n        this.visTimelineService.off(this.visTimeline, 'click');\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./demo/timeline/timeline-example.component.ts\n **/","import { NgModule } from '@angular/core';\r\n\r\nimport { VisNetworkDirective, VisNetworkService } from './components/network/index';\r\nimport { VisTimelineDirective, VisTimelineService } from './components/timeline/index';\r\n\r\nexport * from './components/index';\r\n\r\n@NgModule({\r\n  exports: [VisNetworkDirective, VisTimelineDirective],\r\n  declarations: [VisNetworkDirective, VisTimelineDirective],\r\n  providers: [VisNetworkService, VisTimelineService]\r\n})\r\nexport class VisModule { }\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ng2-vis.ts\n **/","/**\n * @license Angular v3.1.2\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('rxjs/Subject'), require('rxjs/observable/from'), require('rxjs/observable/of'), require('rxjs/operator/concatMap'), require('rxjs/operator/every'), require('rxjs/operator/map'), require('rxjs/operator/mergeAll'), require('rxjs/operator/mergeMap'), require('rxjs/operator/reduce'), require('rxjs/Observable'), require('rxjs/operator/catch'), require('rxjs/operator/concatAll'), require('rxjs/operator/first'), require('rxjs/util/EmptyError'), require('rxjs/observable/fromPromise'), require('rxjs/operator/last'), require('rxjs/BehaviorSubject'), require('rxjs/operator/filter')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', 'rxjs/Subject', 'rxjs/observable/from', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/every', 'rxjs/operator/map', 'rxjs/operator/mergeAll', 'rxjs/operator/mergeMap', 'rxjs/operator/reduce', 'rxjs/Observable', 'rxjs/operator/catch', 'rxjs/operator/concatAll', 'rxjs/operator/first', 'rxjs/util/EmptyError', 'rxjs/observable/fromPromise', 'rxjs/operator/last', 'rxjs/BehaviorSubject', 'rxjs/operator/filter'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.router = global.ng.router || {}),global.ng.common,global.ng.core,global.Rx,global.Rx.Observable,global.Rx.Observable,global.rxjs_operator_concatMap,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype));\n}(this, function (exports,_angular_common,_angular_core,rxjs_Subject,rxjs_observable_from,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_every,rxjs_operator_map,rxjs_operator_mergeAll,rxjs_operator_mergeMap,rxjs_operator_reduce,rxjs_Observable,rxjs_operator_catch,rxjs_operator_concatAll,rxjs_operator_first,rxjs_util_EmptyError,rxjs_observable_fromPromise,l,rxjs_BehaviorSubject,rxjs_operator_filter) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @whatItDoes Name of the primary outlet.\n     *\n     * @stable\n     */\n    var PRIMARY_OUTLET = 'primary';\n    var NavigationCancelingError = (function (_super) {\n        __extends(NavigationCancelingError, _super);\n        function NavigationCancelingError(message) {\n            _super.call(this, message);\n            this.message = message;\n            this.stack = (new Error(message)).stack;\n        }\n        NavigationCancelingError.prototype.toString = function () { return this.message; };\n        return NavigationCancelingError;\n    }(Error));\n\n    function shallowEqualArrays(a, b) {\n        if (a.length !== b.length)\n            return false;\n        for (var i = 0; i < a.length; ++i) {\n            if (!shallowEqual(a[i], b[i]))\n                return false;\n        }\n        return true;\n    }\n    function shallowEqual(a, b) {\n        var k1 = Object.keys(a);\n        var k2 = Object.keys(b);\n        if (k1.length != k2.length) {\n            return false;\n        }\n        var key;\n        for (var i = 0; i < k1.length; i++) {\n            key = k1[i];\n            if (a[key] !== b[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function flatten(a) {\n        var target = [];\n        for (var i = 0; i < a.length; ++i) {\n            for (var j = 0; j < a[i].length; ++j) {\n                target.push(a[i][j]);\n            }\n        }\n        return target;\n    }\n    function last(a) {\n        return a.length > 0 ? a[a.length - 1] : null;\n    }\n    function merge(m1, m2) {\n        var m = {};\n        for (var attr in m1) {\n            if (m1.hasOwnProperty(attr)) {\n                m[attr] = m1[attr];\n            }\n        }\n        for (var attr in m2) {\n            if (m2.hasOwnProperty(attr)) {\n                m[attr] = m2[attr];\n            }\n        }\n        return m;\n    }\n    function forEach(map, callback) {\n        for (var prop in map) {\n            if (map.hasOwnProperty(prop)) {\n                callback(map[prop], prop);\n            }\n        }\n    }\n    function waitForMap(obj, fn) {\n        var waitFor = [];\n        var res = {};\n        forEach(obj, function (a, k) {\n            if (k === PRIMARY_OUTLET) {\n                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n                    res[k] = _;\n                    return _;\n                }));\n            }\n        });\n        forEach(obj, function (a, k) {\n            if (k !== PRIMARY_OUTLET) {\n                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n                    res[k] = _;\n                    return _;\n                }));\n            }\n        });\n        if (waitFor.length > 0) {\n            var concatted$ = rxjs_operator_concatAll.concatAll.call(rxjs_observable_of.of.apply(void 0, waitFor));\n            var last$ = l.last.call(concatted$);\n            return rxjs_operator_map.map.call(last$, function () { return res; });\n        }\n        else {\n            return rxjs_observable_of.of(res);\n        }\n    }\n    function andObservables(observables) {\n        var merged$ = rxjs_operator_mergeAll.mergeAll.call(observables);\n        return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });\n    }\n    function wrapIntoObservable(value) {\n        if (value instanceof rxjs_Observable.Observable) {\n            return value;\n        }\n        else if (value instanceof Promise) {\n            return rxjs_observable_fromPromise.fromPromise(value);\n        }\n        else {\n            return rxjs_observable_of.of(value);\n        }\n    }\n\n    /**\n     * @experimental\n     */\n    var ROUTES = new _angular_core.OpaqueToken('ROUTES');\n    var LoadedRouterConfig = (function () {\n        function LoadedRouterConfig(routes, injector, factoryResolver) {\n            this.routes = routes;\n            this.injector = injector;\n            this.factoryResolver = factoryResolver;\n        }\n        return LoadedRouterConfig;\n    }());\n    var RouterConfigLoader = (function () {\n        function RouterConfigLoader(loader, compiler) {\n            this.loader = loader;\n            this.compiler = compiler;\n        }\n        RouterConfigLoader.prototype.load = function (parentInjector, loadChildren) {\n            return rxjs_operator_map.map.call(this.loadModuleFactory(loadChildren), function (r) {\n                var ref = r.create(parentInjector);\n                return new LoadedRouterConfig(flatten(ref.injector.get(ROUTES)), ref.injector, ref.componentFactoryResolver);\n            });\n        };\n        RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {\n            var _this = this;\n            if (typeof loadChildren === 'string') {\n                return rxjs_observable_fromPromise.fromPromise(this.loader.load(loadChildren));\n            }\n            else {\n                var offlineMode_1 = this.compiler instanceof _angular_core.Compiler;\n                return rxjs_operator_mergeMap.mergeMap.call(wrapIntoObservable(loadChildren()), function (t) { return offlineMode_1 ? rxjs_observable_of.of(t) : rxjs_observable_fromPromise.fromPromise(_this.compiler.compileModuleAsync(t)); });\n            }\n        };\n        return RouterConfigLoader;\n    }());\n\n    function createEmptyUrlTree() {\n        return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n    }\n    function containsTree(container, containee, exact) {\n        if (exact) {\n            return equalSegmentGroups(container.root, containee.root);\n        }\n        else {\n            return containsSegmentGroup(container.root, containee.root);\n        }\n    }\n    function equalSegmentGroups(container, containee) {\n        if (!equalPath(container.segments, containee.segments))\n            return false;\n        if (container.numberOfChildren !== containee.numberOfChildren)\n            return false;\n        for (var c in containee.children) {\n            if (!container.children[c])\n                return false;\n            if (!equalSegmentGroups(container.children[c], containee.children[c]))\n                return false;\n        }\n        return true;\n    }\n    function containsSegmentGroup(container, containee) {\n        return containsSegmentGroupHelper(container, containee, containee.segments);\n    }\n    function containsSegmentGroupHelper(container, containee, containeePaths) {\n        if (container.segments.length > containeePaths.length) {\n            var current = container.segments.slice(0, containeePaths.length);\n            if (!equalPath(current, containeePaths))\n                return false;\n            if (containee.hasChildren())\n                return false;\n            return true;\n        }\n        else if (container.segments.length === containeePaths.length) {\n            if (!equalPath(container.segments, containeePaths))\n                return false;\n            for (var c in containee.children) {\n                if (!container.children[c])\n                    return false;\n                if (!containsSegmentGroup(container.children[c], containee.children[c]))\n                    return false;\n            }\n            return true;\n        }\n        else {\n            var current = containeePaths.slice(0, container.segments.length);\n            var next = containeePaths.slice(container.segments.length);\n            if (!equalPath(container.segments, current))\n                return false;\n            if (!container.children[PRIMARY_OUTLET])\n                return false;\n            return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n        }\n    }\n    /**\n     * @whatItDoes Represents the parsed URL.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'template.html'})\n     * class MyComponent {\n     *   constructor(router: Router) {\n     *     const tree: UrlTree =\n     * router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n     *     const f = tree.fragment; // return 'fragment'\n     *     const q = tree.queryParams; // returns {debug: 'true'}\n     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n     *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n     *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n     *     g.children['support'].segments; // return 1 segment 'help'\n     *   }\n     * }\n     * ```\n     *\n     * @description\n     *\n     * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n     * serialized tree.\n     * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n     *\n     * @stable\n     */\n    var UrlTree = (function () {\n        /**\n         * @internal\n         */\n        function UrlTree(\n            /**\n            * The root segment group of the URL tree.\n             */\n            root,\n            /**\n             * The query params of the URL.\n             */\n            queryParams,\n            /**\n             * The fragment of the URL.\n             */\n            fragment) {\n            this.root = root;\n            this.queryParams = queryParams;\n            this.fragment = fragment;\n        }\n        /**\n         * @docsNotRequired\n         */\n        UrlTree.prototype.toString = function () { return new DefaultUrlSerializer().serialize(this); };\n        return UrlTree;\n    }());\n    /**\n     * @whatItDoes Represents the parsed URL segment.\n     *\n     * See {@link UrlTree} for more information.\n     *\n     * @stable\n     */\n    var UrlSegmentGroup = (function () {\n        function UrlSegmentGroup(\n            /**\n             * The URL segments of this group. See {@link UrlSegment} for more information.\n             */\n            segments,\n            /**\n             * The list of children of this group.\n             */\n            children) {\n            var _this = this;\n            this.segments = segments;\n            this.children = children;\n            /**\n             * The parent node in the url tree.\n             */\n            this.parent = null;\n            forEach(children, function (v, k) { return v.parent = _this; });\n        }\n        /**\n         * Return true if the segment has child segments\n         */\n        UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };\n        Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\n            /**\n             * Returns the number of child sements.\n             */\n            get: function () { return Object.keys(this.children).length; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @docsNotRequired\n         */\n        UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };\n        return UrlSegmentGroup;\n    }());\n    /**\n     * @whatItDoes Represents a single URL segment.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'template.html'})\n     * class MyComponent {\n     *   constructor(router: Router) {\n     *     const tree: UrlTree = router.parseUrl('/team;id=33');\n     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n     *     const s: UrlSegment[] = g.segments;\n     *     s[0].path; // returns 'team'\n     *     s[0].parameters; // returns {id: 33}\n     *   }\n     * }\n     * ```\n     *\n     * @description\n     *\n     * A UrlSegment is a part of a URL between the two slashes. It contains a path and\n     * the matrix parameters associated with the segment.\n     *\n     * @stable\n     */\n    var UrlSegment = (function () {\n        function UrlSegment(\n            /**\n             * The part part of a URL segment.\n             */\n            path,\n            /**\n             * The matrix parameters associated with a segment.\n             */\n            parameters) {\n            this.path = path;\n            this.parameters = parameters;\n        }\n        /**\n         * @docsNotRequired\n         */\n        UrlSegment.prototype.toString = function () { return serializePath(this); };\n        return UrlSegment;\n    }());\n    function equalPath(a, b) {\n        if (a.length !== b.length)\n            return false;\n        for (var i = 0; i < a.length; ++i) {\n            if (a[i].path !== b[i].path)\n                return false;\n        }\n        return true;\n    }\n    function mapChildrenIntoArray(segment, fn) {\n        var res = [];\n        forEach(segment.children, function (child, childOutlet) {\n            if (childOutlet === PRIMARY_OUTLET) {\n                res = res.concat(fn(child, childOutlet));\n            }\n        });\n        forEach(segment.children, function (child, childOutlet) {\n            if (childOutlet !== PRIMARY_OUTLET) {\n                res = res.concat(fn(child, childOutlet));\n            }\n        });\n        return res;\n    }\n    /**\n     * @whatItDoes Serializes and deserializes a URL string into a URL tree.\n     *\n     * @description The url serialization strategy is customizable. You can\n     * make all URLs case insensitive by providing a custom UrlSerializer.\n     *\n     * See {@link DefaultUrlSerializer} for an example of a URL serializer.\n     *\n     * @stable\n     */\n    var UrlSerializer = (function () {\n        function UrlSerializer() {\n        }\n        return UrlSerializer;\n    }());\n    /**\n     * @whatItDoes A default implementation of the {@link UrlSerializer}.\n     *\n     * @description\n     *\n     * Example URLs:\n     *\n     * ```\n     * /inbox/33(popup:compose)\n     * /inbox/33;open=true/messages/44\n     * ```\n     *\n     * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n     * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n     * specify route specific parameters.\n     *\n     * @stable\n     */\n    var DefaultUrlSerializer = (function () {\n        function DefaultUrlSerializer() {\n        }\n        /**\n         * Parse a url into a {@link UrlTree}.\n         */\n        DefaultUrlSerializer.prototype.parse = function (url) {\n            var p = new UrlParser(url);\n            return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n        };\n        /**\n         * Converts a {@link UrlTree} into a url.\n         */\n        DefaultUrlSerializer.prototype.serialize = function (tree) {\n            var segment = \"/\" + serializeSegment(tree.root, true);\n            var query = serializeQueryParams(tree.queryParams);\n            var fragment = tree.fragment !== null && tree.fragment !== undefined ? \"#\" + encodeURI(tree.fragment) : '';\n            return \"\" + segment + query + fragment;\n        };\n        return DefaultUrlSerializer;\n    }());\n    function serializePaths(segment) {\n        return segment.segments.map(function (p) { return serializePath(p); }).join('/');\n    }\n    function serializeSegment(segment, root) {\n        if (segment.hasChildren() && root) {\n            var primary = segment.children[PRIMARY_OUTLET] ?\n                serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n                '';\n            var children_1 = [];\n            forEach(segment.children, function (v, k) {\n                if (k !== PRIMARY_OUTLET) {\n                    children_1.push(k + \":\" + serializeSegment(v, false));\n                }\n            });\n            if (children_1.length > 0) {\n                return primary + \"(\" + children_1.join('//') + \")\";\n            }\n            else {\n                return \"\" + primary;\n            }\n        }\n        else if (segment.hasChildren() && !root) {\n            var children = mapChildrenIntoArray(segment, function (v, k) {\n                if (k === PRIMARY_OUTLET) {\n                    return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n                }\n                else {\n                    return [(k + \":\" + serializeSegment(v, false))];\n                }\n            });\n            return serializePaths(segment) + \"/(\" + children.join('//') + \")\";\n        }\n        else {\n            return serializePaths(segment);\n        }\n    }\n    function encode(s) {\n        return encodeURIComponent(s);\n    }\n    function decode(s) {\n        return decodeURIComponent(s);\n    }\n    function serializePath(path) {\n        return \"\" + encode(path.path) + serializeParams(path.parameters);\n    }\n    function serializeParams(params) {\n        return pairs(params).map(function (p) { return (\";\" + encode(p.first) + \"=\" + encode(p.second)); }).join('');\n    }\n    function serializeQueryParams(params) {\n        var strs = pairs(params).map(function (p) { return (encode(p.first) + \"=\" + encode(p.second)); });\n        return strs.length > 0 ? \"?\" + strs.join(\"&\") : '';\n    }\n    var Pair = (function () {\n        function Pair(first, second) {\n            this.first = first;\n            this.second = second;\n        }\n        return Pair;\n    }());\n    function pairs(obj) {\n        var res = [];\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                res.push(new Pair(prop, obj[prop]));\n            }\n        }\n        return res;\n    }\n    var SEGMENT_RE = /^[^\\/\\(\\)\\?;=&#]+/;\n    function matchSegments(str) {\n        SEGMENT_RE.lastIndex = 0;\n        var match = str.match(SEGMENT_RE);\n        return match ? match[0] : '';\n    }\n    var QUERY_PARAM_RE = /^[^=\\?&#]+/;\n    function matchQueryParams(str) {\n        QUERY_PARAM_RE.lastIndex = 0;\n        var match = str.match(SEGMENT_RE);\n        return match ? match[0] : '';\n    }\n    var QUERY_PARAM_VALUE_RE = /^[^\\?&#]+/;\n    function matchUrlQueryParamValue(str) {\n        QUERY_PARAM_VALUE_RE.lastIndex = 0;\n        var match = str.match(QUERY_PARAM_VALUE_RE);\n        return match ? match[0] : '';\n    }\n    var UrlParser = (function () {\n        function UrlParser(url) {\n            this.url = url;\n            this.remaining = url;\n        }\n        UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };\n        UrlParser.prototype.capture = function (str) {\n            if (!this.remaining.startsWith(str)) {\n                throw new Error(\"Expected \\\"\" + str + \"\\\".\");\n            }\n            this.remaining = this.remaining.substring(str.length);\n        };\n        UrlParser.prototype.parseRootSegment = function () {\n            if (this.remaining.startsWith('/')) {\n                this.capture('/');\n            }\n            if (this.remaining === '' || this.remaining.startsWith('?') || this.remaining.startsWith('#')) {\n                return new UrlSegmentGroup([], {});\n            }\n            else {\n                return new UrlSegmentGroup([], this.parseChildren());\n            }\n        };\n        UrlParser.prototype.parseChildren = function () {\n            if (this.remaining.length == 0) {\n                return {};\n            }\n            if (this.peekStartsWith('/')) {\n                this.capture('/');\n            }\n            var paths = [];\n            if (!this.peekStartsWith('(')) {\n                paths.push(this.parseSegments());\n            }\n            while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n                this.capture('/');\n                paths.push(this.parseSegments());\n            }\n            var children = {};\n            if (this.peekStartsWith('/(')) {\n                this.capture('/');\n                children = this.parseParens(true);\n            }\n            var res = {};\n            if (this.peekStartsWith('(')) {\n                res = this.parseParens(false);\n            }\n            if (paths.length > 0 || Object.keys(children).length > 0) {\n                res[PRIMARY_OUTLET] = new UrlSegmentGroup(paths, children);\n            }\n            return res;\n        };\n        UrlParser.prototype.parseSegments = function () {\n            var path = matchSegments(this.remaining);\n            if (path === '' && this.peekStartsWith(';')) {\n                throw new Error(\"Empty path url segment cannot have parameters: '\" + this.remaining + \"'.\");\n            }\n            this.capture(path);\n            var matrixParams = {};\n            if (this.peekStartsWith(';')) {\n                matrixParams = this.parseMatrixParams();\n            }\n            return new UrlSegment(decode(path), matrixParams);\n        };\n        UrlParser.prototype.parseQueryParams = function () {\n            var params = {};\n            if (this.peekStartsWith('?')) {\n                this.capture('?');\n                this.parseQueryParam(params);\n                while (this.remaining.length > 0 && this.peekStartsWith('&')) {\n                    this.capture('&');\n                    this.parseQueryParam(params);\n                }\n            }\n            return params;\n        };\n        UrlParser.prototype.parseFragment = function () {\n            if (this.peekStartsWith('#')) {\n                return decodeURI(this.remaining.substring(1));\n            }\n            else {\n                return null;\n            }\n        };\n        UrlParser.prototype.parseMatrixParams = function () {\n            var params = {};\n            while (this.remaining.length > 0 && this.peekStartsWith(';')) {\n                this.capture(';');\n                this.parseParam(params);\n            }\n            return params;\n        };\n        UrlParser.prototype.parseParam = function (params) {\n            var key = matchSegments(this.remaining);\n            if (!key) {\n                return;\n            }\n            this.capture(key);\n            var value = '';\n            if (this.peekStartsWith('=')) {\n                this.capture('=');\n                var valueMatch = matchSegments(this.remaining);\n                if (valueMatch) {\n                    value = valueMatch;\n                    this.capture(value);\n                }\n            }\n            params[decode(key)] = decode(value);\n        };\n        UrlParser.prototype.parseQueryParam = function (params) {\n            var key = matchQueryParams(this.remaining);\n            if (!key) {\n                return;\n            }\n            this.capture(key);\n            var value = '';\n            if (this.peekStartsWith('=')) {\n                this.capture('=');\n                var valueMatch = matchUrlQueryParamValue(this.remaining);\n                if (valueMatch) {\n                    value = valueMatch;\n                    this.capture(value);\n                }\n            }\n            params[decode(key)] = decode(value);\n        };\n        UrlParser.prototype.parseParens = function (allowPrimary) {\n            var segments = {};\n            this.capture('(');\n            while (!this.peekStartsWith(')') && this.remaining.length > 0) {\n                var path = matchSegments(this.remaining);\n                var next = this.remaining[path.length];\n                // if is is not one of these characters, then the segment was unescaped\n                // or the group was not closed\n                if (next !== '/' && next !== ')' && next !== ';') {\n                    throw new Error(\"Cannot parse url '\" + this.url + \"'\");\n                }\n                var outletName = void 0;\n                if (path.indexOf(':') > -1) {\n                    outletName = path.substr(0, path.indexOf(':'));\n                    this.capture(outletName);\n                    this.capture(':');\n                }\n                else if (allowPrimary) {\n                    outletName = PRIMARY_OUTLET;\n                }\n                var children = this.parseChildren();\n                segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n                    new UrlSegmentGroup([], children);\n                if (this.peekStartsWith('//')) {\n                    this.capture('//');\n                }\n            }\n            this.capture(')');\n            return segments;\n        };\n        return UrlParser;\n    }());\n\n    var NoMatch = (function () {\n        function NoMatch(segmentGroup) {\n            if (segmentGroup === void 0) { segmentGroup = null; }\n            this.segmentGroup = segmentGroup;\n        }\n        return NoMatch;\n    }());\n    var AbsoluteRedirect = (function () {\n        function AbsoluteRedirect(segments) {\n            this.segments = segments;\n        }\n        return AbsoluteRedirect;\n    }());\n    function noMatch(segmentGroup) {\n        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });\n    }\n    function absoluteRedirect(segments) {\n        return new rxjs_Observable.Observable(function (obs) { return obs.error(new AbsoluteRedirect(segments)); });\n    }\n    function canLoadFails(route) {\n        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NavigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\" + route.path + \"'\\\" returned false\")); });\n    }\n    function applyRedirects(injector, configLoader, urlTree, config) {\n        return new ApplyRedirects(injector, configLoader, urlTree, config).apply();\n    }\n    var ApplyRedirects = (function () {\n        function ApplyRedirects(injector, configLoader, urlTree, config) {\n            this.injector = injector;\n            this.configLoader = configLoader;\n            this.urlTree = urlTree;\n            this.config = config;\n            this.allowRedirects = true;\n        }\n        ApplyRedirects.prototype.apply = function () {\n            var _this = this;\n            var expanded$ = this.expandSegmentGroup(this.injector, this.config, this.urlTree.root, PRIMARY_OUTLET);\n            var urlTrees$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup); });\n            return rxjs_operator_catch._catch.call(urlTrees$, function (e) {\n                if (e instanceof AbsoluteRedirect) {\n                    // after an absolute redirect we do not apply any more redirects!\n                    _this.allowRedirects = false;\n                    var group = new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = new UrlSegmentGroup(e.segments, {}), _a));\n                    // we need to run matching, so we can fetch all lazy-loaded modules\n                    return _this.match(group);\n                }\n                else if (e instanceof NoMatch) {\n                    throw _this.noMatchError(e);\n                }\n                else {\n                    throw e;\n                }\n                var _a;\n            });\n        };\n        ApplyRedirects.prototype.match = function (segmentGroup) {\n            var _this = this;\n            var expanded$ = this.expandSegmentGroup(this.injector, this.config, segmentGroup, PRIMARY_OUTLET);\n            var mapped$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup); });\n            return rxjs_operator_catch._catch.call(mapped$, function (e) {\n                if (e instanceof NoMatch) {\n                    throw _this.noMatchError(e);\n                }\n                else {\n                    throw e;\n                }\n            });\n        };\n        ApplyRedirects.prototype.noMatchError = function (e) {\n            return new Error(\"Cannot match any routes. URL Segment: '\" + e.segmentGroup + \"'\");\n        };\n        ApplyRedirects.prototype.createUrlTree = function (rootCandidate) {\n            var root = rootCandidate.segments.length > 0 ?\n                new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\n                rootCandidate;\n            return new UrlTree(root, this.urlTree.queryParams, this.urlTree.fragment);\n            var _a;\n        };\n        ApplyRedirects.prototype.expandSegmentGroup = function (injector, routes, segmentGroup, outlet) {\n            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n                return rxjs_operator_map.map.call(this.expandChildren(injector, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });\n            }\n            else {\n                return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);\n            }\n        };\n        ApplyRedirects.prototype.expandChildren = function (injector, routes, segmentGroup) {\n            var _this = this;\n            return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(injector, routes, child, childOutlet); });\n        };\n        ApplyRedirects.prototype.expandSegment = function (injector, segmentGroup, routes, segments, outlet, allowRedirects) {\n            var _this = this;\n            var routes$ = rxjs_observable_of.of.apply(void 0, routes);\n            var processedRoutes$ = rxjs_operator_map.map.call(routes$, function (r) {\n                var expanded$ = _this.expandSegmentAgainstRoute(injector, segmentGroup, routes, r, segments, outlet, allowRedirects);\n                return rxjs_operator_catch._catch.call(expanded$, function (e) {\n                    if (e instanceof NoMatch)\n                        return rxjs_observable_of.of(null);\n                    else\n                        throw e;\n                });\n            });\n            var concattedProcessedRoutes$ = rxjs_operator_concatAll.concatAll.call(processedRoutes$);\n            var first$ = rxjs_operator_first.first.call(concattedProcessedRoutes$, function (s) { return !!s; });\n            return rxjs_operator_catch._catch.call(first$, function (e, _) {\n                if (e instanceof rxjs_util_EmptyError.EmptyError) {\n                    throw new NoMatch(segmentGroup);\n                }\n                else {\n                    throw e;\n                }\n            });\n        };\n        ApplyRedirects.prototype.expandSegmentAgainstRoute = function (injector, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n            if (getOutlet$1(route) !== outlet)\n                return noMatch(segmentGroup);\n            if (route.redirectTo !== undefined && !(allowRedirects && this.allowRedirects))\n                return noMatch(segmentGroup);\n            if (route.redirectTo === undefined) {\n                return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths);\n            }\n            else {\n                return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, paths, outlet);\n            }\n        };\n        ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n            if (route.path === '**') {\n                return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet);\n            }\n            else {\n                return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet);\n            }\n        };\n        ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (injector, routes, route, outlet) {\n            var newSegments = applyRedirectCommands([], route.redirectTo, {});\n            if (route.redirectTo.startsWith('/')) {\n                return absoluteRedirect(newSegments);\n            }\n            else {\n                var group = new UrlSegmentGroup(newSegments, {});\n                return this.expandSegment(injector, group, routes, newSegments, outlet, false);\n            }\n        };\n        ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n            var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\n            if (!matched)\n                return noMatch(segmentGroup);\n            var newSegments = applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);\n            if (route.redirectTo.startsWith('/')) {\n                return absoluteRedirect(newSegments);\n            }\n            else {\n                return this.expandSegment(injector, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n            }\n        };\n        ApplyRedirects.prototype.matchSegmentAgainstRoute = function (injector, rawSegmentGroup, route, segments) {\n            var _this = this;\n            if (route.path === '**') {\n                if (route.loadChildren) {\n                    return rxjs_operator_map.map.call(this.configLoader.load(injector, route.loadChildren), function (r) {\n                        route._loadedConfig = r;\n                        return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n                    });\n                }\n                else {\n                    return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n                }\n            }\n            else {\n                var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments_1 = _a.consumedSegments, lastChild = _a.lastChild;\n                if (!matched)\n                    return noMatch(rawSegmentGroup);\n                var rawSlicedSegments_1 = segments.slice(lastChild);\n                var childConfig$ = this.getChildConfig(injector, route);\n                return rxjs_operator_mergeMap.mergeMap.call(childConfig$, function (routerConfig) {\n                    var childInjector = routerConfig.injector;\n                    var childConfig = routerConfig.routes;\n                    var _a = split(rawSegmentGroup, consumedSegments_1, rawSlicedSegments_1, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n                    if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                        var expanded$ = _this.expandChildren(childInjector, childConfig, segmentGroup);\n                        return rxjs_operator_map.map.call(expanded$, function (children) { return new UrlSegmentGroup(consumedSegments_1, children); });\n                    }\n                    else if (childConfig.length === 0 && slicedSegments.length === 0) {\n                        return rxjs_observable_of.of(new UrlSegmentGroup(consumedSegments_1, {}));\n                    }\n                    else {\n                        var expanded$ = _this.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n                        return rxjs_operator_map.map.call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments_1.concat(cs.segments), cs.children); });\n                    }\n                });\n            }\n        };\n        ApplyRedirects.prototype.getChildConfig = function (injector, route) {\n            var _this = this;\n            if (route.children) {\n                return rxjs_observable_of.of(new LoadedRouterConfig(route.children, injector, null));\n            }\n            else if (route.loadChildren) {\n                return rxjs_operator_mergeMap.mergeMap.call(runGuards(injector, route), function (shouldLoad) {\n                    if (shouldLoad) {\n                        if (route._loadedConfig) {\n                            return rxjs_observable_of.of(route._loadedConfig);\n                        }\n                        else {\n                            return rxjs_operator_map.map.call(_this.configLoader.load(injector, route.loadChildren), function (r) {\n                                route._loadedConfig = r;\n                                return r;\n                            });\n                        }\n                    }\n                    else {\n                        return canLoadFails(route);\n                    }\n                });\n            }\n            else {\n                return rxjs_observable_of.of(new LoadedRouterConfig([], injector, null));\n            }\n        };\n        return ApplyRedirects;\n    }());\n    function runGuards(injector, route) {\n        var canLoad = route.canLoad;\n        if (!canLoad || canLoad.length === 0)\n            return rxjs_observable_of.of(true);\n        var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canLoad), function (c) {\n            var guard = injector.get(c);\n            if (guard.canLoad) {\n                return wrapIntoObservable(guard.canLoad(route));\n            }\n            else {\n                return wrapIntoObservable(guard(route));\n            }\n        });\n        return andObservables(obs);\n    }\n    function match(segmentGroup, route, segments) {\n        var noMatch = { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n        if (route.path === '') {\n            if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n                return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n            }\n            else {\n                return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n            }\n        }\n        var path = route.path;\n        var parts = path.split('/');\n        var positionalParamSegments = {};\n        var consumedSegments = [];\n        var currentIndex = 0;\n        for (var i = 0; i < parts.length; ++i) {\n            if (currentIndex >= segments.length)\n                return noMatch;\n            var current = segments[currentIndex];\n            var p = parts[i];\n            var isPosParam = p.startsWith(':');\n            if (!isPosParam && p !== current.path)\n                return noMatch;\n            if (isPosParam) {\n                positionalParamSegments[p.substring(1)] = current;\n            }\n            consumedSegments.push(current);\n            currentIndex++;\n        }\n        if (route.pathMatch === 'full' &&\n            (segmentGroup.hasChildren() || currentIndex < segments.length)) {\n            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n        }\n        return { matched: true, consumedSegments: consumedSegments, lastChild: currentIndex, positionalParamSegments: positionalParamSegments };\n    }\n    function applyRedirectCommands(segments, redirectTo, posParams) {\n        var r = redirectTo.startsWith('/') ? redirectTo.substring(1) : redirectTo;\n        if (r === '') {\n            return [];\n        }\n        else {\n            return createSegments(redirectTo, r.split('/'), segments, posParams);\n        }\n    }\n    function createSegments(redirectTo, parts, segments, posParams) {\n        return parts.map(function (p) { return p.startsWith(':') ? findPosParam(p, posParams, redirectTo) :\n            findOrCreateSegment(p, segments); });\n    }\n    function findPosParam(part, posParams, redirectTo) {\n        var paramName = part.substring(1);\n        var pos = posParams[paramName];\n        if (!pos)\n            throw new Error(\"Cannot redirect to '\" + redirectTo + \"'. Cannot find '\" + part + \"'.\");\n        return pos;\n    }\n    function findOrCreateSegment(part, segments) {\n        var idx = 0;\n        for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n            var s = segments_1[_i];\n            if (s.path === part) {\n                segments.splice(idx);\n                return s;\n            }\n            idx++;\n        }\n        return new UrlSegment(part, {});\n    }\n    function split(segmentGroup, consumedSegments, slicedSegments, config) {\n        if (slicedSegments.length > 0 &&\n            containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\n        }\n        else if (slicedSegments.length === 0 &&\n            containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\n        }\n        else {\n            return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\n        }\n    }\n    function mergeTrivialChildren(s) {\n        if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n            var c = s.children[PRIMARY_OUTLET];\n            return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n        }\n        else {\n            return s;\n        }\n    }\n    function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n        var res = {};\n        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n            var r = routes_1[_i];\n            if (emptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n            }\n        }\n        return merge(children, res);\n    }\n    function createChildrenForEmptySegments(routes, primarySegmentGroup) {\n        var res = {};\n        res[PRIMARY_OUTLET] = primarySegmentGroup;\n        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n            var r = routes_2[_i];\n            if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n            }\n        }\n        return res;\n    }\n    function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n        return routes\n            .filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r) &&\n            getOutlet$1(r) !== PRIMARY_OUTLET; })\n            .length > 0;\n    }\n    function containsEmptyPathRedirects(segmentGroup, slicedSegments, routes) {\n        return routes.filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r); }).length > 0;\n    }\n    function emptyPathRedirect(segmentGroup, slicedSegments, r) {\n        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n            return false;\n        return r.path === '' && r.redirectTo !== undefined;\n    }\n    function getOutlet$1(route) {\n        return route.outlet ? route.outlet : PRIMARY_OUTLET;\n    }\n\n    function validateConfig(config) {\n        config.forEach(validateNode);\n    }\n    function validateNode(route) {\n        if (Array.isArray(route)) {\n            throw new Error(\"Invalid route configuration: Array cannot be specified\");\n        }\n        if (route.component === undefined && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n            throw new Error(\"Invalid route configuration of route '\" + route.path + \"': a componentless route cannot have a named outlet set\");\n        }\n        if (!!route.redirectTo && !!route.children) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and children cannot be used together\");\n        }\n        if (!!route.redirectTo && !!route.loadChildren) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and loadChildren cannot be used together\");\n        }\n        if (!!route.children && !!route.loadChildren) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': children and loadChildren cannot be used together\");\n        }\n        if (!!route.redirectTo && !!route.component) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and component cannot be used together\");\n        }\n        if (route.redirectTo === undefined && !route.component && !route.children &&\n            !route.loadChildren) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': one of the following must be provided (component or redirectTo or children or loadChildren)\");\n        }\n        if (route.path === undefined) {\n            throw new Error(\"Invalid route configuration: routes must have path specified\");\n        }\n        if (route.path.startsWith('/')) {\n            throw new Error(\"Invalid route configuration of route '\" + route.path + \"': path cannot start with a slash\");\n        }\n        if (route.path === '' && route.redirectTo !== undefined && route.pathMatch === undefined) {\n            var exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n            throw new Error(\"Invalid route configuration of route '{path: \\\"\" + route.path + \"\\\", redirectTo: \\\"\" + route.redirectTo + \"\\\"}': please provide 'pathMatch'. \" + exp);\n        }\n        if (route.pathMatch !== undefined && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': pathMatch can only be set to 'prefix' or 'full'\");\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var Tree = (function () {\n        function Tree(root) {\n            this._root = root;\n        }\n        Object.defineProperty(Tree.prototype, \"root\", {\n            get: function () { return this._root.value; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @internal\n         */\n        Tree.prototype.parent = function (t) {\n            var p = this.pathFromRoot(t);\n            return p.length > 1 ? p[p.length - 2] : null;\n        };\n        /**\n         * @internal\n         */\n        Tree.prototype.children = function (t) {\n            var n = findNode(t, this._root);\n            return n ? n.children.map(function (t) { return t.value; }) : [];\n        };\n        /**\n         * @internal\n         */\n        Tree.prototype.firstChild = function (t) {\n            var n = findNode(t, this._root);\n            return n && n.children.length > 0 ? n.children[0].value : null;\n        };\n        /**\n         * @internal\n         */\n        Tree.prototype.siblings = function (t) {\n            var p = findPath(t, this._root, []);\n            if (p.length < 2)\n                return [];\n            var c = p[p.length - 2].children.map(function (c) { return c.value; });\n            return c.filter(function (cc) { return cc !== t; });\n        };\n        /**\n         * @internal\n         */\n        Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root, []).map(function (s) { return s.value; }); };\n        return Tree;\n    }());\n    function findNode(expected, c) {\n        if (expected === c.value)\n            return c;\n        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n            var cc = _a[_i];\n            var r = findNode(expected, cc);\n            if (r)\n                return r;\n        }\n        return null;\n    }\n    function findPath(expected, c, collected) {\n        collected.push(c);\n        if (expected === c.value)\n            return collected;\n        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n            var cc = _a[_i];\n            var cloned = collected.slice(0);\n            var r = findPath(expected, cc, cloned);\n            if (r.length > 0)\n                return r;\n        }\n        return [];\n    }\n    var TreeNode = (function () {\n        function TreeNode(value, children) {\n            this.value = value;\n            this.children = children;\n        }\n        TreeNode.prototype.toString = function () { return \"TreeNode(\" + this.value + \")\"; };\n        return TreeNode;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @whatItDoes Represents the state of the router.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'template.html'})\n     * class MyComponent {\n     *   constructor(router: Router) {\n     *     const state: RouterState = router.routerState;\n     *     const root: ActivatedRoute = state.root;\n     *     const child = root.firstChild;\n     *     const id: Observable<string> = child.params.map(p => p.id);\n     *     //...\n     *   }\n     * }\n     * ```\n     *\n     * @description\n     * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n     * segments,\n     * the extracted parameters, and the resolved data.\n     *\n     * See {@link ActivatedRoute} for more information.\n     *\n     * @stable\n     */\n    var RouterState = (function (_super) {\n        __extends$1(RouterState, _super);\n        /**\n         * @internal\n         */\n        function RouterState(root,\n            /**\n             * The current snapshot of the router state.\n             */\n            snapshot) {\n            _super.call(this, root);\n            this.snapshot = snapshot;\n            setRouterStateSnapshot(this, root);\n        }\n        RouterState.prototype.toString = function () { return this.snapshot.toString(); };\n        return RouterState;\n    }(Tree));\n    function createEmptyState(urlTree, rootComponent) {\n        var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n        var emptyUrl = new rxjs_BehaviorSubject.BehaviorSubject([new UrlSegment('', {})]);\n        var emptyParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n        var emptyData = new rxjs_BehaviorSubject.BehaviorSubject({});\n        var emptyQueryParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n        var fragment = new rxjs_BehaviorSubject.BehaviorSubject('');\n        var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n        activated.snapshot = snapshot.root;\n        return new RouterState(new TreeNode(activated, []), snapshot);\n    }\n    function createEmptyStateSnapshot(urlTree, rootComponent) {\n        var emptyParams = {};\n        var emptyData = {};\n        var emptyQueryParams = {};\n        var fragment = '';\n        var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n        return new RouterStateSnapshot('', new TreeNode(activated, []));\n    }\n    /**\n     * @whatItDoes Contains the information about a route associated with a component loaded in an\n     * outlet.\n     * ActivatedRoute can also be used to traverse the router state tree.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'./my-component.html'})\n     * class MyComponent {\n     *   constructor(route: ActivatedRoute) {\n     *     const id: Observable<string> = route.params.map(p => p.id);\n     *     const url: Observable<string> = route.url.map(s => s.join(''));\n     *     const user = route.data.map(d => d.user); //includes `data` and `resolve`\n     *   }\n     * }\n     * ```\n     *\n     * @stable\n     */\n    var ActivatedRoute = (function () {\n        /**\n         * @internal\n         */\n        function ActivatedRoute(\n            /**\n             *  The URL segments matched by this route. The observable will emit a new value when\n             *  the array of segments changes.\n             */\n            url,\n            /**\n             * The matrix parameters scoped to this route. The observable will emit a new value when\n             * the set of the parameters changes.\n             */\n            params,\n            /**\n             * The query parameters shared by all the routes. The observable will emit a new value when\n             * the set of the parameters changes.\n             */\n            queryParams,\n            /**\n             * The URL fragment shared by all the routes. The observable will emit a new value when\n             * the URL fragment changes.\n             */\n            fragment,\n            /**\n             * The static and resolved data of this route. The observable will emit a new value when\n             * any of the resolvers returns a new object.\n             */\n            data,\n            /**\n             * The outlet name of the route. It's a constant.\n             */\n            outlet,\n            /**\n             * The component of the route. It's a constant.\n             */\n            component, // TODO: vsavkin: remove |string\n            futureSnapshot) {\n            this.url = url;\n            this.params = params;\n            this.queryParams = queryParams;\n            this.fragment = fragment;\n            this.data = data;\n            this.outlet = outlet;\n            this.component = component;\n            this._futureSnapshot = futureSnapshot;\n        }\n        Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\n            /**\n             * The configuration used to match this route.\n             */\n            get: function () { return this._futureSnapshot.routeConfig; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"root\", {\n            /**\n             * The root of the router state.\n             */\n            get: function () { return this._routerState.root; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\n            /**\n             * The parent of this route in the router state tree.\n             */\n            get: function () { return this._routerState.parent(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\n            /**\n             * The first child of this route in the router state tree.\n             */\n            get: function () { return this._routerState.firstChild(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"children\", {\n            /**\n             * The children of this route in the router state tree.\n             */\n            get: function () { return this._routerState.children(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\n            /**\n             * The path from the root of the router state tree to this route.\n             */\n            get: function () { return this._routerState.pathFromRoot(this); },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @docsNotRequired\n         */\n        ActivatedRoute.prototype.toString = function () {\n            return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\n        };\n        return ActivatedRoute;\n    }());\n    /**\n     * @internal\n     */\n    function inheritedParamsDataResolve(route) {\n        var pathToRoot = route.pathFromRoot;\n        var inhertingStartingFrom = pathToRoot.length - 1;\n        while (inhertingStartingFrom >= 1) {\n            var current = pathToRoot[inhertingStartingFrom];\n            var parent_1 = pathToRoot[inhertingStartingFrom - 1];\n            // current route is an empty path => inherits its parent's params and data\n            if (current.routeConfig && current.routeConfig.path === '') {\n                inhertingStartingFrom--;\n            }\n            else if (!parent_1.component) {\n                inhertingStartingFrom--;\n            }\n            else {\n                break;\n            }\n        }\n        return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {\n            var params = merge(res.params, curr.params);\n            var data = merge(res.data, curr.data);\n            var resolve = merge(res.resolve, curr._resolvedData);\n            return { params: params, data: data, resolve: resolve };\n        }, { params: {}, data: {}, resolve: {} });\n    }\n    /**\n     * @whatItDoes Contains the information about a route associated with a component loaded in an\n     * outlet\n     * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router\n     * state tree.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'./my-component.html'})\n     * class MyComponent {\n     *   constructor(route: ActivatedRoute) {\n     *     const id: string = route.snapshot.params.id;\n     *     const url: string = route.snapshot.url.join('');\n     *     const user = route.snapshot.data.user;\n     *   }\n     * }\n     * ```\n     *\n     * @stable\n     */\n    var ActivatedRouteSnapshot = (function () {\n        /**\n         * @internal\n         */\n        function ActivatedRouteSnapshot(\n            /**\n             *  The URL segments matched by this route.\n             */\n            url,\n            /**\n             * The matrix parameters scoped to this route.\n             */\n            params,\n            /**\n             * The query parameters shared by all the routes.\n             */\n            queryParams,\n            /**\n             * The URL fragment shared by all the routes.\n             */\n            fragment,\n            /**\n             * The static and resolved data of this route.\n             */\n            data,\n            /**\n             * The outlet name of the route.\n             */\n            outlet,\n            /**\n             * The component of the route.\n             */\n            component, routeConfig, urlSegment, lastPathIndex, resolve) {\n            this.url = url;\n            this.params = params;\n            this.queryParams = queryParams;\n            this.fragment = fragment;\n            this.data = data;\n            this.outlet = outlet;\n            this.component = component;\n            this._routeConfig = routeConfig;\n            this._urlSegment = urlSegment;\n            this._lastPathIndex = lastPathIndex;\n            this._resolve = resolve;\n        }\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"routeConfig\", {\n            /**\n             * The configuration used to match this route.\n             */\n            get: function () { return this._routeConfig; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\n            /**\n             * The root of the router state.\n             */\n            get: function () { return this._routerState.root; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\n            /**\n             * The parent of this route in the router state tree.\n             */\n            get: function () { return this._routerState.parent(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\n            /**\n             * The first child of this route in the router state tree.\n             */\n            get: function () { return this._routerState.firstChild(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\n            /**\n             * The children of this route in the router state tree.\n             */\n            get: function () { return this._routerState.children(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\n            /**\n             * The path from the root of the router state tree to this route.\n             */\n            get: function () { return this._routerState.pathFromRoot(this); },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @docsNotRequired\n         */\n        ActivatedRouteSnapshot.prototype.toString = function () {\n            var url = this.url.map(function (s) { return s.toString(); }).join('/');\n            var matched = this._routeConfig ? this._routeConfig.path : '';\n            return \"Route(url:'\" + url + \"', path:'\" + matched + \"')\";\n        };\n        return ActivatedRouteSnapshot;\n    }());\n    /**\n     * @whatItDoes Represents the state of the router at a moment in time.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'template.html'})\n     * class MyComponent {\n     *   constructor(router: Router) {\n     *     const state: RouterState = router.routerState;\n     *     const snapshot: RouterStateSnapshot = state.snapshot;\n     *     const root: ActivatedRouteSnapshot = snapshot.root;\n     *     const child = root.firstChild;\n     *     const id: Observable<string> = child.params.map(p => p.id);\n     *     //...\n     *   }\n     * }\n     * ```\n     *\n     * @description\n     * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about\n     * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n     *\n     * @stable\n     */\n    var RouterStateSnapshot = (function (_super) {\n        __extends$1(RouterStateSnapshot, _super);\n        /**\n         * @internal\n         */\n        function RouterStateSnapshot(\n            /** The url from which this snapshot was created */\n            url, root) {\n            _super.call(this, root);\n            this.url = url;\n            setRouterStateSnapshot(this, root);\n        }\n        RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };\n        return RouterStateSnapshot;\n    }(Tree));\n    function setRouterStateSnapshot(state, node) {\n        node.value._routerState = state;\n        node.children.forEach(function (c) { return setRouterStateSnapshot(state, c); });\n    }\n    function serializeNode(node) {\n        var c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(\", \") + \" } \" : '';\n        return \"\" + node.value + c;\n    }\n    /**\n     * The expectation is that the activate route is created with the right set of parameters.\n     * So we push new values into the observables only when they are not the initial values.\n     * And we detect that by checking if the snapshot field is set.\n     */\n    function advanceActivatedRoute(route) {\n        if (route.snapshot) {\n            if (!shallowEqual(route.snapshot.queryParams, route._futureSnapshot.queryParams)) {\n                route.queryParams.next(route._futureSnapshot.queryParams);\n            }\n            if (route.snapshot.fragment !== route._futureSnapshot.fragment) {\n                route.fragment.next(route._futureSnapshot.fragment);\n            }\n            if (!shallowEqual(route.snapshot.params, route._futureSnapshot.params)) {\n                route.params.next(route._futureSnapshot.params);\n                route.data.next(route._futureSnapshot.data);\n            }\n            if (!shallowEqualArrays(route.snapshot.url, route._futureSnapshot.url)) {\n                route.url.next(route._futureSnapshot.url);\n            }\n            route.snapshot = route._futureSnapshot;\n        }\n        else {\n            route.snapshot = route._futureSnapshot;\n            // this is for resolved data\n            route.data.next(route._futureSnapshot.data);\n        }\n    }\n\n    function createRouterState(curr, prevState) {\n        var root = createNode(curr._root, prevState ? prevState._root : undefined);\n        return new RouterState(root, curr);\n    }\n    function createNode(curr, prevState) {\n        if (prevState && equalRouteSnapshots(prevState.value.snapshot, curr.value)) {\n            var value = prevState.value;\n            value._futureSnapshot = curr.value;\n            var children = createOrReuseChildren(curr, prevState);\n            return new TreeNode(value, children);\n        }\n        else {\n            var value = createActivatedRoute(curr.value);\n            var children = curr.children.map(function (c) { return createNode(c); });\n            return new TreeNode(value, children);\n        }\n    }\n    function createOrReuseChildren(curr, prevState) {\n        return curr.children.map(function (child) {\n            for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {\n                var p = _a[_i];\n                if (equalRouteSnapshots(p.value.snapshot, child.value)) {\n                    return createNode(child, p);\n                }\n            }\n            return createNode(child);\n        });\n    }\n    function createActivatedRoute(c) {\n        return new ActivatedRoute(new rxjs_BehaviorSubject.BehaviorSubject(c.url), new rxjs_BehaviorSubject.BehaviorSubject(c.params), new rxjs_BehaviorSubject.BehaviorSubject(c.queryParams), new rxjs_BehaviorSubject.BehaviorSubject(c.fragment), new rxjs_BehaviorSubject.BehaviorSubject(c.data), c.outlet, c.component, c);\n    }\n    function equalRouteSnapshots(a, b) {\n        return a._routeConfig === b._routeConfig;\n    }\n\n    function createUrlTree(route, urlTree, commands, queryParams, fragment) {\n        if (commands.length === 0) {\n            return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n        }\n        var normalizedCommands = normalizeCommands(commands);\n        validateCommands(normalizedCommands);\n        if (navigateToRoot(normalizedCommands)) {\n            return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n        }\n        var startingPosition = findStartingPosition(normalizedCommands, urlTree, route);\n        var segmentGroup = startingPosition.processChildren ?\n            updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, normalizedCommands.commands) :\n            updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, normalizedCommands.commands);\n        return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n    }\n    function validateCommands(n) {\n        if (n.isAbsolute && n.commands.length > 0 && isMatrixParams(n.commands[0])) {\n            throw new Error('Root segment cannot have matrix parameters');\n        }\n        var c = n.commands.filter(function (c) { return typeof c === 'object' && c.outlets !== undefined; });\n        if (c.length > 0 && c[0] !== n.commands[n.commands.length - 1]) {\n            throw new Error('{outlets:{}} has to be the last command');\n        }\n    }\n    function isMatrixParams(command) {\n        return typeof command === 'object' && command.outlets === undefined &&\n            command.segmentPath === undefined;\n    }\n    function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n        if (urlTree.root === oldSegmentGroup) {\n            return new UrlTree(newSegmentGroup, stringify(queryParams), fragment);\n        }\n        else {\n            return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), stringify(queryParams), fragment);\n        }\n    }\n    function replaceSegment(current, oldSegment, newSegment) {\n        var children = {};\n        forEach(current.children, function (c, outletName) {\n            if (c === oldSegment) {\n                children[outletName] = newSegment;\n            }\n            else {\n                children[outletName] = replaceSegment(c, oldSegment, newSegment);\n            }\n        });\n        return new UrlSegmentGroup(current.segments, children);\n    }\n    function navigateToRoot(normalizedChange) {\n        return normalizedChange.isAbsolute && normalizedChange.commands.length === 1 &&\n            normalizedChange.commands[0] == '/';\n    }\n    var NormalizedNavigationCommands = (function () {\n        function NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, commands) {\n            this.isAbsolute = isAbsolute;\n            this.numberOfDoubleDots = numberOfDoubleDots;\n            this.commands = commands;\n        }\n        return NormalizedNavigationCommands;\n    }());\n    function normalizeCommands(commands) {\n        if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] == '/') {\n            return new NormalizedNavigationCommands(true, 0, commands);\n        }\n        var numberOfDoubleDots = 0;\n        var isAbsolute = false;\n        var res = [];\n        var _loop_1 = function(i) {\n            var c = commands[i];\n            if (typeof c === 'object' && c.outlets !== undefined) {\n                var r_1 = {};\n                forEach(c.outlets, function (commands, name) {\n                    if (typeof commands === 'string') {\n                        r_1[name] = commands.split('/');\n                    }\n                    else {\n                        r_1[name] = commands;\n                    }\n                });\n                res.push({ outlets: r_1 });\n                return \"continue\";\n            }\n            if (typeof c === 'object' && c.segmentPath !== undefined) {\n                res.push(c.segmentPath);\n                return \"continue\";\n            }\n            if (!(typeof c === 'string')) {\n                res.push(c);\n                return \"continue\";\n            }\n            if (i === 0) {\n                var parts = c.split('/');\n                for (var j = 0; j < parts.length; ++j) {\n                    var cc = parts[j];\n                    if (j == 0 && cc == '.') {\n                    }\n                    else if (j == 0 && cc == '') {\n                        isAbsolute = true;\n                    }\n                    else if (cc == '..') {\n                        numberOfDoubleDots++;\n                    }\n                    else if (cc != '') {\n                        res.push(cc);\n                    }\n                }\n            }\n            else {\n                res.push(c);\n            }\n        };\n        for (var i = 0; i < commands.length; ++i) {\n            _loop_1(i);\n        }\n        return new NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, res);\n    }\n    var Position = (function () {\n        function Position(segmentGroup, processChildren, index) {\n            this.segmentGroup = segmentGroup;\n            this.processChildren = processChildren;\n            this.index = index;\n        }\n        return Position;\n    }());\n    function findStartingPosition(normalizedChange, urlTree, route) {\n        if (normalizedChange.isAbsolute) {\n            return new Position(urlTree.root, true, 0);\n        }\n        else if (route.snapshot._lastPathIndex === -1) {\n            return new Position(route.snapshot._urlSegment, true, 0);\n        }\n        else {\n            var modifier = isMatrixParams(normalizedChange.commands[0]) ? 0 : 1;\n            var index = route.snapshot._lastPathIndex + modifier;\n            return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, normalizedChange.numberOfDoubleDots);\n        }\n    }\n    function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n        var g = group;\n        var ci = index;\n        var dd = numberOfDoubleDots;\n        while (dd > ci) {\n            dd -= ci;\n            g = g.parent;\n            if (!g) {\n                throw new Error('Invalid number of \\'../\\'');\n            }\n            ci = g.segments.length;\n        }\n        return new Position(g, false, ci - dd);\n    }\n    function getPath(command) {\n        if (typeof command === 'object' && command.outlets)\n            return command.outlets[PRIMARY_OUTLET];\n        return \"\" + command;\n    }\n    function getOutlets(commands) {\n        if (!(typeof commands[0] === 'object'))\n            return (_a = {}, _a[PRIMARY_OUTLET] = commands, _a);\n        if (commands[0].outlets === undefined)\n            return (_b = {}, _b[PRIMARY_OUTLET] = commands, _b);\n        return commands[0].outlets;\n        var _a, _b;\n    }\n    function updateSegmentGroup(segmentGroup, startIndex, commands) {\n        if (!segmentGroup) {\n            segmentGroup = new UrlSegmentGroup([], {});\n        }\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n        }\n        var m = prefixedWith(segmentGroup, startIndex, commands);\n        var slicedCommands = commands.slice(m.commandIndex);\n        if (m.match && m.pathIndex < segmentGroup.segments.length) {\n            var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n            g.children[PRIMARY_OUTLET] =\n                new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n            return updateSegmentGroupChildren(g, 0, slicedCommands);\n        }\n        else if (m.match && slicedCommands.length === 0) {\n            return new UrlSegmentGroup(segmentGroup.segments, {});\n        }\n        else if (m.match && !segmentGroup.hasChildren()) {\n            return createNewSegmentGroup(segmentGroup, startIndex, commands);\n        }\n        else if (m.match) {\n            return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n        }\n        else {\n            return createNewSegmentGroup(segmentGroup, startIndex, commands);\n        }\n    }\n    function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n        if (commands.length === 0) {\n            return new UrlSegmentGroup(segmentGroup.segments, {});\n        }\n        else {\n            var outlets_1 = getOutlets(commands);\n            var children_1 = {};\n            forEach(outlets_1, function (commands, outlet) {\n                if (commands !== null) {\n                    children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n                }\n            });\n            forEach(segmentGroup.children, function (child, childOutlet) {\n                if (outlets_1[childOutlet] === undefined) {\n                    children_1[childOutlet] = child;\n                }\n            });\n            return new UrlSegmentGroup(segmentGroup.segments, children_1);\n        }\n    }\n    function prefixedWith(segmentGroup, startIndex, commands) {\n        var currentCommandIndex = 0;\n        var currentPathIndex = startIndex;\n        var noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n        while (currentPathIndex < segmentGroup.segments.length) {\n            if (currentCommandIndex >= commands.length)\n                return noMatch;\n            var path = segmentGroup.segments[currentPathIndex];\n            var curr = getPath(commands[currentCommandIndex]);\n            var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n            if (currentPathIndex > 0 && curr === undefined)\n                break;\n            if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n                if (!compare(curr, next, path))\n                    return noMatch;\n                currentCommandIndex += 2;\n            }\n            else {\n                if (!compare(curr, {}, path))\n                    return noMatch;\n                currentCommandIndex++;\n            }\n            currentPathIndex++;\n        }\n        return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n    }\n    function createNewSegmentGroup(segmentGroup, startIndex, commands) {\n        var paths = segmentGroup.segments.slice(0, startIndex);\n        var i = 0;\n        while (i < commands.length) {\n            if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n                var children = createNewSegmentChldren(commands[i].outlets);\n                return new UrlSegmentGroup(paths, children);\n            }\n            // if we start with an object literal, we need to reuse the path part from the segment\n            if (i === 0 && isMatrixParams(commands[0])) {\n                var p = segmentGroup.segments[startIndex];\n                paths.push(new UrlSegment(p.path, commands[0]));\n                i++;\n                continue;\n            }\n            var curr = getPath(commands[i]);\n            var next = (i < commands.length - 1) ? commands[i + 1] : null;\n            if (curr && next && isMatrixParams(next)) {\n                paths.push(new UrlSegment(curr, stringify(next)));\n                i += 2;\n            }\n            else {\n                paths.push(new UrlSegment(curr, {}));\n                i++;\n            }\n        }\n        return new UrlSegmentGroup(paths, {});\n    }\n    function createNewSegmentChldren(outlets) {\n        var children = {};\n        forEach(outlets, function (commands, outlet) {\n            if (commands !== null) {\n                children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n            }\n        });\n        return children;\n    }\n    function stringify(params) {\n        var res = {};\n        forEach(params, function (v, k) { return res[k] = \"\" + v; });\n        return res;\n    }\n    function compare(path, params, segment) {\n        return path == segment.path && shallowEqual(params, segment.parameters);\n    }\n\n    var NoMatch$1 = (function () {\n        function NoMatch() {\n        }\n        return NoMatch;\n    }());\n    function recognize(rootComponentType, config, urlTree, url) {\n        return new Recognizer(rootComponentType, config, urlTree, url).recognize();\n    }\n    var Recognizer = (function () {\n        function Recognizer(rootComponentType, config, urlTree, url) {\n            this.rootComponentType = rootComponentType;\n            this.config = config;\n            this.urlTree = urlTree;\n            this.url = url;\n        }\n        Recognizer.prototype.recognize = function () {\n            try {\n                var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;\n                var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n                var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n                var rootNode = new TreeNode(root, children);\n                var routeState = new RouterStateSnapshot(this.url, rootNode);\n                this.inheriteParamsAndData(routeState._root);\n                return rxjs_observable_of.of(routeState);\n            }\n            catch (e) {\n                return new rxjs_Observable.Observable(function (obs) { return obs.error(e); });\n            }\n        };\n        Recognizer.prototype.inheriteParamsAndData = function (routeNode) {\n            var _this = this;\n            var route = routeNode.value;\n            var i = inheritedParamsDataResolve(route);\n            route.params = Object.freeze(i.params);\n            route.data = Object.freeze(i.data);\n            routeNode.children.forEach(function (n) { return _this.inheriteParamsAndData(n); });\n        };\n        Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {\n            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n                return this.processChildren(config, segmentGroup);\n            }\n            else {\n                return this.processSegment(config, segmentGroup, 0, segmentGroup.segments, outlet);\n            }\n        };\n        Recognizer.prototype.processChildren = function (config, segmentGroup) {\n            var _this = this;\n            var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\n            checkOutletNameUniqueness(children);\n            sortActivatedRouteSnapshots(children);\n            return children;\n        };\n        Recognizer.prototype.processSegment = function (config, segmentGroup, pathIndex, segments, outlet) {\n            for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {\n                var r = config_1[_i];\n                try {\n                    return this.processSegmentAgainstRoute(r, segmentGroup, pathIndex, segments, outlet);\n                }\n                catch (e) {\n                    if (!(e instanceof NoMatch$1))\n                        throw e;\n                }\n            }\n            throw new NoMatch$1();\n        };\n        Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, pathIndex, segments, outlet) {\n            if (route.redirectTo)\n                throw new NoMatch$1();\n            if ((route.outlet ? route.outlet : PRIMARY_OUTLET) !== outlet)\n                throw new NoMatch$1();\n            if (route.path === '**') {\n                var params = segments.length > 0 ? last(segments).parameters : {};\n                var snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n                return [new TreeNode(snapshot_1, [])];\n            }\n            var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;\n            var rawSlicedSegments = segments.slice(lastChild);\n            var childConfig = getChildConfig(route);\n            var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;\n            var snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                var children = this.processChildren(childConfig, segmentGroup);\n                return [new TreeNode(snapshot, children)];\n            }\n            else if (childConfig.length === 0 && slicedSegments.length === 0) {\n                return [new TreeNode(snapshot, [])];\n            }\n            else {\n                var children = this.processSegment(childConfig, segmentGroup, pathIndex + lastChild, slicedSegments, PRIMARY_OUTLET);\n                return [new TreeNode(snapshot, children)];\n            }\n        };\n        return Recognizer;\n    }());\n    function sortActivatedRouteSnapshots(nodes) {\n        nodes.sort(function (a, b) {\n            if (a.value.outlet === PRIMARY_OUTLET)\n                return -1;\n            if (b.value.outlet === PRIMARY_OUTLET)\n                return 1;\n            return a.value.outlet.localeCompare(b.value.outlet);\n        });\n    }\n    function getChildConfig(route) {\n        if (route.children) {\n            return route.children;\n        }\n        else if (route.loadChildren) {\n            return route._loadedConfig.routes;\n        }\n        else {\n            return [];\n        }\n    }\n    function match$1(segmentGroup, route, segments) {\n        if (route.path === '') {\n            if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n                throw new NoMatch$1();\n            }\n            else {\n                return { consumedSegments: [], lastChild: 0, parameters: {} };\n            }\n        }\n        var path = route.path;\n        var parts = path.split('/');\n        var posParameters = {};\n        var consumedSegments = [];\n        var currentIndex = 0;\n        for (var i = 0; i < parts.length; ++i) {\n            if (currentIndex >= segments.length)\n                throw new NoMatch$1();\n            var current = segments[currentIndex];\n            var p = parts[i];\n            var isPosParam = p.startsWith(':');\n            if (!isPosParam && p !== current.path)\n                throw new NoMatch$1();\n            if (isPosParam) {\n                posParameters[p.substring(1)] = current.path;\n            }\n            consumedSegments.push(current);\n            currentIndex++;\n        }\n        if (route.pathMatch === 'full' &&\n            (segmentGroup.hasChildren() || currentIndex < segments.length)) {\n            throw new NoMatch$1();\n        }\n        var parameters = merge(posParameters, consumedSegments[consumedSegments.length - 1].parameters);\n        return { consumedSegments: consumedSegments, lastChild: currentIndex, parameters: parameters };\n    }\n    function checkOutletNameUniqueness(nodes) {\n        var names = {};\n        nodes.forEach(function (n) {\n            var routeWithSameOutletName = names[n.value.outlet];\n            if (routeWithSameOutletName) {\n                var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');\n                var c = n.value.url.map(function (s) { return s.toString(); }).join('/');\n                throw new Error(\"Two segments cannot have the same outlet name: '\" + p + \"' and '\" + c + \"'.\");\n            }\n            names[n.value.outlet] = n.value;\n        });\n    }\n    function getSourceSegmentGroup(segmentGroup) {\n        var s = segmentGroup;\n        while (s._sourceSegment) {\n            s = s._sourceSegment;\n        }\n        return s;\n    }\n    function getPathIndexShift(segmentGroup) {\n        var s = segmentGroup;\n        var res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n        while (s._sourceSegment) {\n            s = s._sourceSegment;\n            res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n        }\n        return res - 1;\n    }\n    function split$1(segmentGroup, consumedSegments, slicedSegments, config) {\n        if (slicedSegments.length > 0 &&\n            containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = consumedSegments.length;\n            return { segmentGroup: s, slicedSegments: [] };\n        }\n        else if (slicedSegments.length === 0 &&\n            containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = consumedSegments.length;\n            return { segmentGroup: s, slicedSegments: slicedSegments };\n        }\n        else {\n            var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = consumedSegments.length;\n            return { segmentGroup: s, slicedSegments: slicedSegments };\n        }\n    }\n    function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n        var res = {};\n        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n            var r = routes_1[_i];\n            if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$2(r)]) {\n                var s = new UrlSegmentGroup([], {});\n                s._sourceSegment = segmentGroup;\n                s._segmentIndexShift = segmentGroup.segments.length;\n                res[getOutlet$2(r)] = s;\n            }\n        }\n        return merge(children, res);\n    }\n    function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n        var res = {};\n        res[PRIMARY_OUTLET] = primarySegment;\n        primarySegment._sourceSegment = segmentGroup;\n        primarySegment._segmentIndexShift = consumedSegments.length;\n        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n            var r = routes_2[_i];\n            if (r.path === '' && getOutlet$2(r) !== PRIMARY_OUTLET) {\n                var s = new UrlSegmentGroup([], {});\n                s._sourceSegment = segmentGroup;\n                s._segmentIndexShift = consumedSegments.length;\n                res[getOutlet$2(r)] = s;\n            }\n        }\n        return res;\n    }\n    function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n        return routes\n            .filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) &&\n            getOutlet$2(r) !== PRIMARY_OUTLET; })\n            .length > 0;\n    }\n    function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n        return routes.filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); }).length > 0;\n    }\n    function emptyPathMatch(segmentGroup, slicedSegments, r) {\n        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n            return false;\n        return r.path === '' && r.redirectTo === undefined;\n    }\n    function getOutlet$2(route) {\n        return route.outlet ? route.outlet : PRIMARY_OUTLET;\n    }\n    function getData(route) {\n        return route.data ? route.data : {};\n    }\n    function getResolve(route) {\n        return route.resolve ? route.resolve : {};\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @whatItDoes Contains all the router outlets created in a component.\n     *\n     * @stable\n     */\n    var RouterOutletMap = (function () {\n        function RouterOutletMap() {\n            /** @internal */\n            this._outlets = {};\n        }\n        /**\n         * Adds an outlet to this map.\n         */\n        RouterOutletMap.prototype.registerOutlet = function (name, outlet) { this._outlets[name] = outlet; };\n        /**\n         * Removes an outlet from this map.\n         */\n        RouterOutletMap.prototype.removeOutlet = function (name) { this._outlets[name] = undefined; };\n        return RouterOutletMap;\n    }());\n\n    /**\n     * @whatItDoes Represents an event triggered when a navigation starts.\n     *\n     * @stable\n     */\n    var NavigationStart = (function () {\n        // TODO: vsavkin: make internal\n        function NavigationStart(\n            /** @docsNotRequired */\n            id,\n            /** @docsNotRequired */\n            url) {\n            this.id = id;\n            this.url = url;\n        }\n        /** @docsNotRequired */\n        NavigationStart.prototype.toString = function () { return \"NavigationStart(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n        return NavigationStart;\n    }());\n    /**\n     * @whatItDoes Represents an event triggered when a navigation ends successfully.\n     *\n     * @stable\n     */\n    var NavigationEnd = (function () {\n        // TODO: vsavkin: make internal\n        function NavigationEnd(\n            /** @docsNotRequired */\n            id,\n            /** @docsNotRequired */\n            url,\n            /** @docsNotRequired */\n            urlAfterRedirects) {\n            this.id = id;\n            this.url = url;\n            this.urlAfterRedirects = urlAfterRedirects;\n        }\n        /** @docsNotRequired */\n        NavigationEnd.prototype.toString = function () {\n            return \"NavigationEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"')\";\n        };\n        return NavigationEnd;\n    }());\n    /**\n     * @whatItDoes Represents an event triggered when a navigation is canceled.\n     *\n     * @stable\n     */\n    var NavigationCancel = (function () {\n        // TODO: vsavkin: make internal\n        function NavigationCancel(\n            /** @docsNotRequired */\n            id,\n            /** @docsNotRequired */\n            url,\n            /** @docsNotRequired */\n            reason) {\n            this.id = id;\n            this.url = url;\n            this.reason = reason;\n        }\n        /** @docsNotRequired */\n        NavigationCancel.prototype.toString = function () { return \"NavigationCancel(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n        return NavigationCancel;\n    }());\n    /**\n     * @whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.\n     *\n     * @stable\n     */\n    var NavigationError = (function () {\n        // TODO: vsavkin: make internal\n        function NavigationError(\n            /** @docsNotRequired */\n            id,\n            /** @docsNotRequired */\n            url,\n            /** @docsNotRequired */\n            error) {\n            this.id = id;\n            this.url = url;\n            this.error = error;\n        }\n        /** @docsNotRequired */\n        NavigationError.prototype.toString = function () {\n            return \"NavigationError(id: \" + this.id + \", url: '\" + this.url + \"', error: \" + this.error + \")\";\n        };\n        return NavigationError;\n    }());\n    /**\n     * @whatItDoes Represents an event triggered when routes are recognized.\n     *\n     * @stable\n     */\n    var RoutesRecognized = (function () {\n        // TODO: vsavkin: make internal\n        function RoutesRecognized(\n            /** @docsNotRequired */\n            id,\n            /** @docsNotRequired */\n            url,\n            /** @docsNotRequired */\n            urlAfterRedirects,\n            /** @docsNotRequired */\n            state) {\n            this.id = id;\n            this.url = url;\n            this.urlAfterRedirects = urlAfterRedirects;\n            this.state = state;\n        }\n        /** @docsNotRequired */\n        RoutesRecognized.prototype.toString = function () {\n            return \"RoutesRecognized(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n        };\n        return RoutesRecognized;\n    }());\n    function defaultErrorHandler(error) {\n        throw error;\n    }\n    /**\n     * @whatItDoes Provides the navigation and url manipulation capabilities.\n     *\n     * See {@link Routes} for more details and examples.\n     *\n     * @ngModule RouterModule\n     *\n     * @stable\n     */\n    var Router = (function () {\n        /**\n         * Creates the router service.\n         */\n        // TODO: vsavkin make internal after the final is out.\n        function Router(rootComponentType, urlSerializer, outletMap, location, injector, loader, compiler, config) {\n            this.rootComponentType = rootComponentType;\n            this.urlSerializer = urlSerializer;\n            this.outletMap = outletMap;\n            this.location = location;\n            this.injector = injector;\n            this.config = config;\n            this.navigationId = 0;\n            /**\n             * Error handler that is invoked when a navigation errors.\n             *\n             * See {@link ErrorHandler} for more information.\n             */\n            this.errorHandler = defaultErrorHandler;\n            /**\n             * Indicates if at least one navigation happened.\n             */\n            this.navigated = false;\n            this.resetConfig(config);\n            this.routerEvents = new rxjs_Subject.Subject();\n            this.currentUrlTree = createEmptyUrlTree();\n            this.configLoader = new RouterConfigLoader(loader, compiler);\n            this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n        }\n        /**\n         * @internal\n         * TODO: this should be removed once the constructor of the router made internal\n         */\n        Router.prototype.resetRootComponentType = function (rootComponentType) {\n            this.rootComponentType = rootComponentType;\n            // TODO: vsavkin router 4.0 should make the root component set to null\n            // this will simplify the lifecycle of the router.\n            this.currentRouterState.root.component = this.rootComponentType;\n        };\n        /**\n         * Sets up the location change listener and performs the initial navigation.\n         */\n        Router.prototype.initialNavigation = function () {\n            this.setUpLocationChangeListener();\n            this.navigateByUrl(this.location.path(true), { replaceUrl: true });\n        };\n        /**\n         * Sets up the location change listener.\n         */\n        Router.prototype.setUpLocationChangeListener = function () {\n            var _this = this;\n            // Zone.current.wrap is needed because of the issue with RxJS scheduler,\n            // which does not work properly with zone.js in IE and Safari\n            this.locationSubscription = this.location.subscribe(Zone.current.wrap(function (change) {\n                var tree = _this.urlSerializer.parse(change['url']);\n                // we fire multiple events for a single URL change\n                // we should navigate only once\n                return _this.currentUrlTree.toString() !== tree.toString() ?\n                    _this.scheduleNavigation(tree, { skipLocationChange: change['pop'], replaceUrl: true }) :\n                    null;\n            }));\n        };\n        Object.defineProperty(Router.prototype, \"routerState\", {\n            /**\n             * Returns the current route state.\n             */\n            get: function () { return this.currentRouterState; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Router.prototype, \"url\", {\n            /**\n             * Returns the current url.\n             */\n            get: function () { return this.serializeUrl(this.currentUrlTree); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Router.prototype, \"events\", {\n            /**\n             * Returns an observable of route events\n             */\n            get: function () { return this.routerEvents; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Resets the configuration used for navigation and generating links.\n         *\n         * ### Usage\n         *\n         * ```\n         * router.resetConfig([\n         *  { path: 'team/:id', component: TeamCmp, children: [\n         *    { path: 'simple', component: SimpleCmp },\n         *    { path: 'user/:name', component: UserCmp }\n         *  ] }\n         * ]);\n         * ```\n         */\n        Router.prototype.resetConfig = function (config) {\n            validateConfig(config);\n            this.config = config;\n        };\n        /**\n         * @docsNotRequired\n         */\n        Router.prototype.ngOnDestroy = function () { this.dispose(); };\n        /**\n         * Disposes of the router.\n         */\n        Router.prototype.dispose = function () { this.locationSubscription.unsubscribe(); };\n        /**\n         * Applies an array of commands to the current url tree and creates a new url tree.\n         *\n         * When given an activate route, applies the given commands starting from the route.\n         * When not given a route, applies the given command starting from the root.\n         *\n         * ### Usage\n         *\n         * ```\n         * // create /team/33/user/11\n         * router.createUrlTree(['/team', 33, 'user', 11]);\n         *\n         * // create /team/33;expand=true/user/11\n         * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n         *\n         * // you can collapse static segments like this (this works only with the first passed-in value):\n         * router.createUrlTree(['/team/33/user', userId]);\n         *\n         * // If the first segment can contain slashes, and you do not want the router to split it, you\n         * // can do the following:\n         *\n         * router.createUrlTree([{segmentPath: '/one/two'}]);\n         *\n         * // create /team/33/(user/11//right:chat)\n         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n         *\n         * // remove the right secondary node\n         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n         *\n         * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n         *\n         * // navigate to /team/33/user/11/details\n         * router.createUrlTree(['details'], {relativeTo: route});\n         *\n         * // navigate to /team/33/user/22\n         * router.createUrlTree(['../22'], {relativeTo: route});\n         *\n         * // navigate to /team/44/user/22\n         * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n         * ```\n         */\n        Router.prototype.createUrlTree = function (commands, _a) {\n            var _b = _a === void 0 ? {} : _a, relativeTo = _b.relativeTo, queryParams = _b.queryParams, fragment = _b.fragment, preserveQueryParams = _b.preserveQueryParams, preserveFragment = _b.preserveFragment;\n            var a = relativeTo ? relativeTo : this.routerState.root;\n            var q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams;\n            var f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n            return createUrlTree(a, this.currentUrlTree, commands, q, f);\n        };\n        /**\n         * Navigate based on the provided url. This navigation is always absolute.\n         *\n         * Returns a promise that:\n         * - is resolved with 'true' when navigation succeeds\n         * - is resolved with 'false' when navigation fails\n         * - is rejected when an error happens\n         *\n         * ### Usage\n         *\n         * ```\n         * router.navigateByUrl(\"/team/33/user/11\");\n         *\n         * // Navigate without updating the URL\n         * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n         * ```\n         *\n         * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n         * and does not apply any delta to the current one.\n         */\n        Router.prototype.navigateByUrl = function (url, extras) {\n            if (extras === void 0) { extras = { skipLocationChange: false }; }\n            if (url instanceof UrlTree) {\n                return this.scheduleNavigation(url, extras);\n            }\n            else {\n                var urlTree = this.urlSerializer.parse(url);\n                return this.scheduleNavigation(urlTree, extras);\n            }\n        };\n        /**\n         * Navigate based on the provided array of commands and a starting point.\n         * If no starting route is provided, the navigation is absolute.\n         *\n         * Returns a promise that:\n         * - is resolved with 'true' when navigation succeeds\n         * - is resolved with 'false' when navigation fails\n         * - is rejected when an error happens\n         *\n         * ### Usage\n         *\n         * ```\n         * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n         *\n         * // Navigate without updating the URL\n         * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true });\n         * ```\n         *\n         * In opposite to `navigateByUrl`, `navigate` always takes a delta\n         * that is applied to the current URL.\n         */\n        Router.prototype.navigate = function (commands, extras) {\n            if (extras === void 0) { extras = { skipLocationChange: false }; }\n            return this.scheduleNavigation(this.createUrlTree(commands, extras), extras);\n        };\n        /**\n         * Serializes a {@link UrlTree} into a string.\n         */\n        Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };\n        /**\n         * Parses a string into a {@link UrlTree}.\n         */\n        Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };\n        /**\n         * Returns if the url is activated or not.\n         */\n        Router.prototype.isActive = function (url, exact) {\n            if (url instanceof UrlTree) {\n                return containsTree(this.currentUrlTree, url, exact);\n            }\n            else {\n                var urlTree = this.urlSerializer.parse(url);\n                return containsTree(this.currentUrlTree, urlTree, exact);\n            }\n        };\n        Router.prototype.scheduleNavigation = function (url, extras) {\n            var _this = this;\n            var id = ++this.navigationId;\n            this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n            return Promise.resolve().then(function (_) { return _this.runNavigate(url, extras.skipLocationChange, extras.replaceUrl, id); });\n        };\n        Router.prototype.runNavigate = function (url, shouldPreventPushState, shouldReplaceUrl, id) {\n            var _this = this;\n            if (id !== this.navigationId) {\n                this.location.go(this.urlSerializer.serialize(this.currentUrlTree));\n                this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \" + id + \" is not equal to the current navigation id \" + this.navigationId));\n                return Promise.resolve(false);\n            }\n            return new Promise(function (resolvePromise, rejectPromise) {\n                var state;\n                var navigationIsSuccessful;\n                var preActivation;\n                var appliedUrl;\n                var storedState = _this.currentRouterState;\n                var storedUrl = _this.currentUrlTree;\n                var redirectsApplied$ = applyRedirects(_this.injector, _this.configLoader, url, _this.config);\n                var snapshot$ = rxjs_operator_mergeMap.mergeMap.call(redirectsApplied$, function (u) {\n                    appliedUrl = u;\n                    return recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl));\n                });\n                var emitRecognzied$ = rxjs_operator_map.map.call(snapshot$, function (newRouterStateSnapshot) {\n                    _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), newRouterStateSnapshot));\n                    return newRouterStateSnapshot;\n                });\n                var routerState$ = rxjs_operator_map.map.call(emitRecognzied$, function (routerStateSnapshot) {\n                    return createRouterState(routerStateSnapshot, _this.currentRouterState);\n                });\n                var preactivation$ = rxjs_operator_map.map.call(routerState$, function (newState) {\n                    state = newState;\n                    preActivation =\n                        new PreActivation(state.snapshot, _this.currentRouterState.snapshot, _this.injector);\n                    preActivation.traverse(_this.outletMap);\n                });\n                var preactivation2$ = rxjs_operator_mergeMap.mergeMap.call(preactivation$, function () { return preActivation.checkGuards(); });\n                var resolveData$ = rxjs_operator_mergeMap.mergeMap.call(preactivation2$, function (shouldActivate) {\n                    if (shouldActivate) {\n                        return rxjs_operator_map.map.call(preActivation.resolveData(), function () { return shouldActivate; });\n                    }\n                    else {\n                        return rxjs_observable_of.of(shouldActivate);\n                    }\n                });\n                resolveData$\n                    .forEach(function (shouldActivate) {\n                    if (!shouldActivate || id !== _this.navigationId) {\n                        navigationIsSuccessful = false;\n                        return;\n                    }\n                    _this.currentUrlTree = appliedUrl;\n                    _this.currentRouterState = state;\n                    if (!shouldPreventPushState) {\n                        var path = _this.urlSerializer.serialize(appliedUrl);\n                        if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {\n                            _this.location.replaceState(path);\n                        }\n                        else {\n                            _this.location.go(path);\n                        }\n                    }\n                    new ActivateRoutes(state, storedState).activate(_this.outletMap);\n                    navigationIsSuccessful = true;\n                })\n                    .then(function () {\n                    _this.navigated = true;\n                    if (navigationIsSuccessful) {\n                        _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl)));\n                        resolvePromise(true);\n                    }\n                    else {\n                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));\n                        resolvePromise(false);\n                    }\n                }, function (e) {\n                    if (e instanceof NavigationCancelingError) {\n                        _this.navigated = true;\n                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));\n                        resolvePromise(false);\n                    }\n                    else {\n                        _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));\n                        try {\n                            resolvePromise(_this.errorHandler(e));\n                        }\n                        catch (ee) {\n                            rejectPromise(ee);\n                        }\n                    }\n                    if (id === _this.navigationId) {\n                        _this.currentRouterState = storedState;\n                        _this.currentUrlTree = storedUrl;\n                        _this.location.replaceState(_this.serializeUrl(storedUrl));\n                    }\n                });\n            });\n        };\n        return Router;\n    }());\n    var CanActivate = (function () {\n        function CanActivate(path) {\n            this.path = path;\n        }\n        Object.defineProperty(CanActivate.prototype, \"route\", {\n            get: function () { return this.path[this.path.length - 1]; },\n            enumerable: true,\n            configurable: true\n        });\n        return CanActivate;\n    }());\n    var CanDeactivate = (function () {\n        function CanDeactivate(component, route) {\n            this.component = component;\n            this.route = route;\n        }\n        return CanDeactivate;\n    }());\n    var PreActivation = (function () {\n        function PreActivation(future, curr, injector) {\n            this.future = future;\n            this.curr = curr;\n            this.injector = injector;\n            this.checks = [];\n        }\n        PreActivation.prototype.traverse = function (parentOutletMap) {\n            var futureRoot = this.future._root;\n            var currRoot = this.curr ? this.curr._root : null;\n            this.traverseChildRoutes(futureRoot, currRoot, parentOutletMap, [futureRoot.value]);\n        };\n        PreActivation.prototype.checkGuards = function () {\n            var _this = this;\n            if (this.checks.length === 0)\n                return rxjs_observable_of.of(true);\n            var checks$ = rxjs_observable_from.from(this.checks);\n            var runningChecks$ = rxjs_operator_map.map.call(checks$, function (s) {\n                if (s instanceof CanActivate) {\n                    return andObservables(rxjs_observable_from.from([_this.runCanActivateChild(s.path), _this.runCanActivate(s.route)]));\n                }\n                else if (s instanceof CanDeactivate) {\n                    // workaround https://github.com/Microsoft/TypeScript/issues/7271\n                    var s2 = s;\n                    return _this.runCanDeactivate(s2.component, s2.route);\n                }\n                else {\n                    throw new Error('Cannot be reached');\n                }\n            });\n            var mergedChecks$ = rxjs_operator_mergeAll.mergeAll.call(runningChecks$);\n            return rxjs_operator_every.every.call(mergedChecks$, function (result) { return result === true; });\n        };\n        PreActivation.prototype.resolveData = function () {\n            var _this = this;\n            if (this.checks.length === 0)\n                return rxjs_observable_of.of(null);\n            var checks$ = rxjs_observable_from.from(this.checks);\n            var runningChecks$ = rxjs_operator_concatMap.concatMap.call(checks$, function (s) {\n                if (s instanceof CanActivate) {\n                    return _this.runResolve(s.route);\n                }\n                else {\n                    return rxjs_observable_of.of(null);\n                }\n            });\n            return rxjs_operator_reduce.reduce.call(runningChecks$, function (_, __) { return _; });\n        };\n        PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, outletMap, futurePath) {\n            var _this = this;\n            var prevChildren = nodeChildrenAsMap(currNode);\n            futureNode.children.forEach(function (c) {\n                _this.traverseRoutes(c, prevChildren[c.value.outlet], outletMap, futurePath.concat([c.value]));\n                delete prevChildren[c.value.outlet];\n            });\n            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap._outlets[k]); });\n        };\n        PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentOutletMap, futurePath) {\n            var future = futureNode.value;\n            var curr = currNode ? currNode.value : null;\n            var outlet = parentOutletMap ? parentOutletMap._outlets[futureNode.value.outlet] : null;\n            // reusing the node\n            if (curr && future._routeConfig === curr._routeConfig) {\n                if (!shallowEqual(future.params, curr.params)) {\n                    this.checks.push(new CanDeactivate(outlet.component, curr), new CanActivate(futurePath));\n                }\n                else {\n                    // we need to set the data\n                    future.data = curr.data;\n                    future._resolvedData = curr._resolvedData;\n                }\n                // If we have a component, we need to go through an outlet.\n                if (future.component) {\n                    this.traverseChildRoutes(futureNode, currNode, outlet ? outlet.outletMap : null, futurePath);\n                }\n                else {\n                    this.traverseChildRoutes(futureNode, currNode, parentOutletMap, futurePath);\n                }\n            }\n            else {\n                if (curr) {\n                    this.deactiveRouteAndItsChildren(currNode, outlet);\n                }\n                this.checks.push(new CanActivate(futurePath));\n                // If we have a component, we need to go through an outlet.\n                if (future.component) {\n                    this.traverseChildRoutes(futureNode, null, outlet ? outlet.outletMap : null, futurePath);\n                }\n                else {\n                    this.traverseChildRoutes(futureNode, null, parentOutletMap, futurePath);\n                }\n            }\n        };\n        PreActivation.prototype.deactiveRouteAndItsChildren = function (route, outlet) {\n            var _this = this;\n            var prevChildren = nodeChildrenAsMap(route);\n            forEach(prevChildren, function (v, k) {\n                var childOutlet = outlet ? outlet.outletMap._outlets[k] : null;\n                _this.deactiveRouteAndItsChildren(v, childOutlet);\n            });\n            var component = outlet && outlet.isActivated ? outlet.component : null;\n            this.checks.push(new CanDeactivate(component, route.value));\n        };\n        PreActivation.prototype.runCanActivate = function (future) {\n            var _this = this;\n            var canActivate = future._routeConfig ? future._routeConfig.canActivate : null;\n            if (!canActivate || canActivate.length === 0)\n                return rxjs_observable_of.of(true);\n            var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canActivate), function (c) {\n                var guard = _this.getToken(c, future);\n                if (guard.canActivate) {\n                    return wrapIntoObservable(guard.canActivate(future, _this.future));\n                }\n                else {\n                    return wrapIntoObservable(guard(future, _this.future));\n                }\n            });\n            return andObservables(obs);\n        };\n        PreActivation.prototype.runCanActivateChild = function (path) {\n            var _this = this;\n            var future = path[path.length - 1];\n            var canActivateChildGuards = path.slice(0, path.length - 1)\n                .reverse()\n                .map(function (p) { return _this.extractCanActivateChild(p); })\n                .filter(function (_) { return _ !== null; });\n            return andObservables(rxjs_operator_map.map.call(rxjs_observable_from.from(canActivateChildGuards), function (d) {\n                var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(d.guards), function (c) {\n                    var guard = _this.getToken(c, c.node);\n                    if (guard.canActivateChild) {\n                        return wrapIntoObservable(guard.canActivateChild(future, _this.future));\n                    }\n                    else {\n                        return wrapIntoObservable(guard(future, _this.future));\n                    }\n                });\n                return andObservables(obs);\n            }));\n        };\n        PreActivation.prototype.extractCanActivateChild = function (p) {\n            var canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;\n            if (!canActivateChild || canActivateChild.length === 0)\n                return null;\n            return { node: p, guards: canActivateChild };\n        };\n        PreActivation.prototype.runCanDeactivate = function (component, curr) {\n            var _this = this;\n            var canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;\n            if (!canDeactivate || canDeactivate.length === 0)\n                return rxjs_observable_of.of(true);\n            var canDeactivate$ = rxjs_operator_map.map.call(rxjs_observable_from.from(canDeactivate), function (c) {\n                var guard = _this.getToken(c, curr);\n                if (guard.canDeactivate) {\n                    return wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr));\n                }\n                else {\n                    return wrapIntoObservable(guard(component, curr, _this.curr));\n                }\n            });\n            var merged$ = rxjs_operator_mergeAll.mergeAll.call(canDeactivate$);\n            return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });\n        };\n        PreActivation.prototype.runResolve = function (future) {\n            var resolve = future._resolve;\n            return rxjs_operator_map.map.call(this.resolveNode(resolve, future), function (resolvedData) {\n                future._resolvedData = resolvedData;\n                future.data = merge(future.data, inheritedParamsDataResolve(future).resolve);\n                return null;\n            });\n        };\n        PreActivation.prototype.resolveNode = function (resolve, future) {\n            var _this = this;\n            return waitForMap(resolve, function (k, v) {\n                var resolver = _this.getToken(v, future);\n                return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, _this.future)) :\n                    wrapIntoObservable(resolver(future, _this.future));\n            });\n        };\n        PreActivation.prototype.getToken = function (token, snapshot) {\n            var config = closestLoadedConfig(snapshot);\n            var injector = config ? config.injector : this.injector;\n            return injector.get(token);\n        };\n        return PreActivation;\n    }());\n    var ActivateRoutes = (function () {\n        function ActivateRoutes(futureState, currState) {\n            this.futureState = futureState;\n            this.currState = currState;\n        }\n        ActivateRoutes.prototype.activate = function (parentOutletMap) {\n            var futureRoot = this.futureState._root;\n            var currRoot = this.currState ? this.currState._root : null;\n            advanceActivatedRoute(this.futureState.root);\n            this.activateChildRoutes(futureRoot, currRoot, parentOutletMap);\n        };\n        ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, outletMap) {\n            var _this = this;\n            var prevChildren = nodeChildrenAsMap(currNode);\n            futureNode.children.forEach(function (c) {\n                _this.activateRoutes(c, prevChildren[c.value.outlet], outletMap);\n                delete prevChildren[c.value.outlet];\n            });\n            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap); });\n        };\n        ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentOutletMap) {\n            var future = futureNode.value;\n            var curr = currNode ? currNode.value : null;\n            // reusing the node\n            if (future === curr) {\n                // advance the route to push the parameters\n                advanceActivatedRoute(future);\n                // If we have a normal route, we need to go through an outlet.\n                if (future.component) {\n                    var outlet = getOutlet(parentOutletMap, future);\n                    this.activateChildRoutes(futureNode, currNode, outlet.outletMap);\n                }\n                else {\n                    this.activateChildRoutes(futureNode, currNode, parentOutletMap);\n                }\n            }\n            else {\n                if (curr) {\n                    this.deactiveRouteAndItsChildren(currNode, parentOutletMap);\n                }\n                // if we have a normal route, we need to advance the route\n                // and place the component into the outlet. After that recurse.\n                if (future.component) {\n                    advanceActivatedRoute(future);\n                    var outlet = getOutlet(parentOutletMap, futureNode.value);\n                    var outletMap = new RouterOutletMap();\n                    this.placeComponentIntoOutlet(outletMap, future, outlet);\n                    this.activateChildRoutes(futureNode, null, outletMap);\n                }\n                else {\n                    advanceActivatedRoute(future);\n                    this.activateChildRoutes(futureNode, null, parentOutletMap);\n                }\n            }\n        };\n        ActivateRoutes.prototype.placeComponentIntoOutlet = function (outletMap, future, outlet) {\n            var resolved = [{ provide: ActivatedRoute, useValue: future }, {\n                    provide: RouterOutletMap,\n                    useValue: outletMap\n                }];\n            var config = parentLoadedConfig(future.snapshot);\n            var loadedFactoryResolver = null;\n            var loadedInjector = null;\n            if (config) {\n                loadedFactoryResolver = config.factoryResolver;\n                loadedInjector = config.injector;\n                resolved.push({ provide: _angular_core.ComponentFactoryResolver, useValue: loadedFactoryResolver });\n            }\n            outlet.activate(future, loadedFactoryResolver, loadedInjector, _angular_core.ReflectiveInjector.resolve(resolved), outletMap);\n        };\n        ActivateRoutes.prototype.deactiveRouteAndItsChildren = function (route, parentOutletMap) {\n            var _this = this;\n            var prevChildren = nodeChildrenAsMap(route);\n            var outlet = null;\n            // getOutlet throws when cannot find the right outlet,\n            // which can happen if an outlet was in an NgIf and was removed\n            try {\n                outlet = getOutlet(parentOutletMap, route.value);\n            }\n            catch (e) {\n                return;\n            }\n            var childOutletMap = outlet.outletMap;\n            forEach(prevChildren, function (v, k) {\n                if (route.value.component) {\n                    _this.deactiveRouteAndItsChildren(v, childOutletMap);\n                }\n                else {\n                    _this.deactiveRouteAndItsChildren(v, parentOutletMap);\n                }\n            });\n            if (outlet && outlet.isActivated) {\n                outlet.deactivate();\n            }\n        };\n        return ActivateRoutes;\n    }());\n    function parentLoadedConfig(snapshot) {\n        var s = snapshot.parent;\n        while (s) {\n            var c = s._routeConfig;\n            if (c && c._loadedConfig)\n                return c._loadedConfig;\n            if (c && c.component)\n                return null;\n            s = s.parent;\n        }\n        return null;\n    }\n    function closestLoadedConfig(snapshot) {\n        if (!snapshot)\n            return null;\n        var s = snapshot.parent;\n        while (s) {\n            var c = s._routeConfig;\n            if (c && c._loadedConfig)\n                return c._loadedConfig;\n            s = s.parent;\n        }\n        return null;\n    }\n    function nodeChildrenAsMap(node) {\n        return node ? node.children.reduce(function (m, c) {\n            m[c.value.outlet] = c;\n            return m;\n        }, {}) : {};\n    }\n    function getOutlet(outletMap, route) {\n        var outlet = outletMap._outlets[route.outlet];\n        if (!outlet) {\n            var componentName = route.component.name;\n            if (route.outlet === PRIMARY_OUTLET) {\n                throw new Error(\"Cannot find primary outlet to load '\" + componentName + \"'\");\n            }\n            else {\n                throw new Error(\"Cannot find the outlet \" + route.outlet + \" to load '\" + componentName + \"'\");\n            }\n        }\n        return outlet;\n    }\n\n    /**\n     * @whatItDoes Lets you link to specific parts of your app.\n     *\n     * @howToUse\n     *\n     * Consider the following route configuration:\n\n     * ```\n     * [{ path: 'user/:name', component: UserCmp }]\n     * ```\n     *\n     * When linking to this `user/:name` route, you can write:\n     *\n     * ```\n     * <a routerLink='/user/bob'>link to user component</a>\n     * ```\n     *\n     * @description\n     *\n     * The RouterLink directives let you link to specific parts of your app.\n     *\n     * Whe the link is static, you can use the directive as follows:\n     *\n     * ```\n     * <a routerLink=\"/user/bob\">link to user component</a>\n     * ```\n     *\n     * If you use dynamic values to generate the link, you can pass an array of path\n     * segments, followed by the params for each segment.\n     *\n     * For instance `['/team', teamId, 'user', userName, {details: true}]`\n     * means that we want to generate a link to `/team/11/user/bob;details=true`.\n     *\n     * Multiple static segments can be merged into one (e.g., `['/team/11/user', userName, {details:\n     true}]`).\n     *\n     * The first segment name can be prepended with `/`, `./`, or `../`:\n     * * If the first segment begins with `/`, the router will look up the route from the root of the\n     app.\n     * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n     * instead look in the children of the current activated route.\n     * * And if the first segment begins with `../`, the router will go up one level.\n     *\n     * You can set query params and fragment as follows:\n     *\n     * ```\n     * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">link to user\n     component</a>\n     * ```\n     * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n     *\n     * You can also tell the directive to preserve the current query params and fragment:\n     *\n     * ```\n     * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>link to user\n     component</a>\n     * ```\n     *\n     * The router link directive always treats the provided input as a delta to the current url.\n     *\n     * For instance, if the current url is `/user/(box//aux:team)`.\n     *\n     * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n     * `/user/(jim//aux:team)`.\n     *\n     * @selector ':not(a)[routerLink]'\n     * @ngModule RouterModule\n     *\n     * See {@link Router.createUrlTree} for more information.\n     *\n     * @stable\n     */\n    var RouterLink = (function () {\n        function RouterLink(router, route, locationStrategy) {\n            this.router = router;\n            this.route = route;\n            this.locationStrategy = locationStrategy;\n            this.commands = [];\n        }\n        Object.defineProperty(RouterLink.prototype, \"routerLink\", {\n            set: function (data) {\n                if (Array.isArray(data)) {\n                    this.commands = data;\n                }\n                else {\n                    this.commands = [data];\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLink.prototype.onClick = function (button, ctrlKey, metaKey) {\n            if (button !== 0 || ctrlKey || metaKey) {\n                return true;\n            }\n            this.router.navigateByUrl(this.urlTree);\n            return false;\n        };\n        Object.defineProperty(RouterLink.prototype, \"urlTree\", {\n            get: function () {\n                return this.router.createUrlTree(this.commands, {\n                    relativeTo: this.route,\n                    queryParams: this.queryParams,\n                    fragment: this.fragment,\n                    preserveQueryParams: toBool(this.preserveQueryParams),\n                    preserveFragment: toBool(this.preserveFragment)\n                });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLink.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: ':not(a)[routerLink]' },] },\n        ];\n        /** @nocollapse */\n        RouterLink.ctorParameters = [\n            { type: Router, },\n            { type: ActivatedRoute, },\n            { type: _angular_common.LocationStrategy, },\n        ];\n        RouterLink.propDecorators = {\n            'queryParams': [{ type: _angular_core.Input },],\n            'fragment': [{ type: _angular_core.Input },],\n            'preserveQueryParams': [{ type: _angular_core.Input },],\n            'preserveFragment': [{ type: _angular_core.Input },],\n            'routerLink': [{ type: _angular_core.Input },],\n            'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey'],] },],\n        };\n        return RouterLink;\n    }());\n    /**\n     * @whatItDoes Lets you link to specific parts of your app.\n     *\n     * See {@link RouterLink} for more information.\n     *\n     * @selector 'a[routerLink]'\n     * @ngModule RouterModule\n     *\n     * @stable\n     */\n    var RouterLinkWithHref = (function () {\n        function RouterLinkWithHref(router, route, locationStrategy) {\n            var _this = this;\n            this.router = router;\n            this.route = route;\n            this.locationStrategy = locationStrategy;\n            this.commands = [];\n            this.subscription = router.events.subscribe(function (s) {\n                if (s instanceof NavigationEnd) {\n                    _this.updateTargetUrlAndHref();\n                }\n            });\n        }\n        Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\n            set: function (data) {\n                if (Array.isArray(data)) {\n                    this.commands = data;\n                }\n                else {\n                    this.commands = [data];\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };\n        RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n        RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey) {\n            if (button !== 0 || ctrlKey || metaKey) {\n                return true;\n            }\n            if (typeof this.target === 'string' && this.target != '_self') {\n                return true;\n            }\n            this.router.navigateByUrl(this.urlTree);\n            return false;\n        };\n        RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {\n            this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n        };\n        Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\n            get: function () {\n                return this.router.createUrlTree(this.commands, {\n                    relativeTo: this.route,\n                    queryParams: this.queryParams,\n                    fragment: this.fragment,\n                    preserveQueryParams: toBool(this.preserveQueryParams),\n                    preserveFragment: toBool(this.preserveFragment)\n                });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLinkWithHref.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: 'a[routerLink]' },] },\n        ];\n        /** @nocollapse */\n        RouterLinkWithHref.ctorParameters = [\n            { type: Router, },\n            { type: ActivatedRoute, },\n            { type: _angular_common.LocationStrategy, },\n        ];\n        RouterLinkWithHref.propDecorators = {\n            'target': [{ type: _angular_core.Input },],\n            'queryParams': [{ type: _angular_core.Input },],\n            'fragment': [{ type: _angular_core.Input },],\n            'routerLinkOptions': [{ type: _angular_core.Input },],\n            'preserveQueryParams': [{ type: _angular_core.Input },],\n            'preserveFragment': [{ type: _angular_core.Input },],\n            'href': [{ type: _angular_core.HostBinding },],\n            'routerLink': [{ type: _angular_core.Input },],\n            'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey'],] },],\n        };\n        return RouterLinkWithHref;\n    }());\n    function toBool(s) {\n        if (s === '')\n            return true;\n        return !!s;\n    }\n\n    /**\n     * @whatItDoes Lets you add a CSS class to an element when the link's route becomes active.\n     *\n     * @howToUse\n     *\n     * ```\n     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n     * ```\n     *\n     * @description\n     *\n     * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n     * becomes active.\n     *\n     * Consider the following example:\n     *\n     * ```\n     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n     * ```\n     *\n     * When the url is either '/user' or '/user/bob', the active-link class will\n     * be added to the `a` tag. If the url changes, the class will be removed.\n     *\n     * You can set more than one class, as follows:\n     *\n     * ```\n     * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n     * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n     * ```\n     *\n     * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n     * only when the url matches the link exactly.\n     *\n     * ```\n     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n     * true}\">Bob</a>\n     * ```\n     *\n     * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n     *\n     * ```\n     * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n     *   <a routerLink=\"/user/jim\">Jim</a>\n     *   <a routerLink=\"/user/bob\">Bob</a>\n     * </div>\n     * ```\n     *\n     * This will set the active-link class on the div tag if the url is either '/user/jim' or\n     * '/user/bob'.\n     *\n     * @selector ':not(a)[routerLink]'\n     * @ngModule RouterModule\n     *\n     * @stable\n     */\n    var RouterLinkActive = (function () {\n        function RouterLinkActive(router, element, renderer) {\n            var _this = this;\n            this.router = router;\n            this.element = element;\n            this.renderer = renderer;\n            this.classes = [];\n            this.routerLinkActiveOptions = { exact: false };\n            this.subscription = router.events.subscribe(function (s) {\n                if (s instanceof NavigationEnd) {\n                    _this.update();\n                }\n            });\n        }\n        RouterLinkActive.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this.links.changes.subscribe(function (s) { return _this.update(); });\n            this.linksWithHrefs.changes.subscribe(function (s) { return _this.update(); });\n            this.update();\n        };\n        Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\n            set: function (data) {\n                if (Array.isArray(data)) {\n                    this.classes = data;\n                }\n                else {\n                    this.classes = data.split(' ');\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };\n        RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n        RouterLinkActive.prototype.update = function () {\n            var _this = this;\n            if (!this.links || !this.linksWithHrefs || !this.router.navigated)\n                return;\n            var isActive = this.hasActiveLink();\n            this.classes.forEach(function (c) { return _this.renderer.setElementClass(_this.element.nativeElement, c, isActive); });\n        };\n        RouterLinkActive.prototype.isLinkActive = function (router) {\n            var _this = this;\n            return function (link) {\n                return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\n            };\n        };\n        RouterLinkActive.prototype.hasActiveLink = function () {\n            return this.links.some(this.isLinkActive(this.router)) ||\n                this.linksWithHrefs.some(this.isLinkActive(this.router));\n        };\n        RouterLinkActive.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[routerLinkActive]' },] },\n        ];\n        /** @nocollapse */\n        RouterLinkActive.ctorParameters = [\n            { type: Router, },\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n        ];\n        RouterLinkActive.propDecorators = {\n            'links': [{ type: _angular_core.ContentChildren, args: [RouterLink, { descendants: true },] },],\n            'linksWithHrefs': [{ type: _angular_core.ContentChildren, args: [RouterLinkWithHref, { descendants: true },] },],\n            'routerLinkActiveOptions': [{ type: _angular_core.Input },],\n            'routerLinkActive': [{ type: _angular_core.Input },],\n        };\n        return RouterLinkActive;\n    }());\n\n    /**\n     * @whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router\n     * state.\n     *\n     * @howToUse\n     *\n     * ```\n     * <router-outlet></router-outlet>\n     * <router-outlet name='left'></router-outlet>\n     * <router-outlet name='right'></router-outlet>\n     * ```\n     *\n     * A router outlet will emit an activate event any time a new component is being instantiated,\n     * and a deactivate event when it is being destroyed.\n     *\n     * ```\n     * <router-outlet\n     *   (activate)='onActivate($event)'\n     *   (deactivate)='onDeactivate($event)'></router-outlet>\n     * ```\n     * @selector 'a[routerLink]'\n     * @ngModule RouterModule\n     *\n     * @stable\n     */\n    var RouterOutlet = (function () {\n        function RouterOutlet(parentOutletMap, location, resolver, name) {\n            this.parentOutletMap = parentOutletMap;\n            this.location = location;\n            this.resolver = resolver;\n            this.name = name;\n            this.activateEvents = new _angular_core.EventEmitter();\n            this.deactivateEvents = new _angular_core.EventEmitter();\n            parentOutletMap.registerOutlet(name ? name : PRIMARY_OUTLET, this);\n        }\n        RouterOutlet.prototype.ngOnDestroy = function () { this.parentOutletMap.removeOutlet(this.name ? this.name : PRIMARY_OUTLET); };\n        Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\n            get: function () { return !!this.activated; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RouterOutlet.prototype, \"component\", {\n            get: function () {\n                if (!this.activated)\n                    throw new Error('Outlet is not activated');\n                return this.activated.instance;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\n            get: function () {\n                if (!this.activated)\n                    throw new Error('Outlet is not activated');\n                return this._activatedRoute;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterOutlet.prototype.deactivate = function () {\n            if (this.activated) {\n                var c = this.component;\n                this.activated.destroy();\n                this.activated = null;\n                this.deactivateEvents.emit(c);\n            }\n        };\n        RouterOutlet.prototype.activate = function (activatedRoute, loadedResolver, loadedInjector, providers, outletMap) {\n            if (this.isActivated) {\n                throw new Error('Cannot activate an already activated outlet');\n            }\n            this.outletMap = outletMap;\n            this._activatedRoute = activatedRoute;\n            var snapshot = activatedRoute._futureSnapshot;\n            var component = snapshot._routeConfig.component;\n            var factory;\n            if (loadedResolver) {\n                factory = loadedResolver.resolveComponentFactory(component);\n            }\n            else {\n                factory = this.resolver.resolveComponentFactory(component);\n            }\n            var injector = loadedInjector ? loadedInjector : this.location.parentInjector;\n            var inj = _angular_core.ReflectiveInjector.fromResolvedProviders(providers, injector);\n            this.activated = this.location.createComponent(factory, this.location.length, inj, []);\n            this.activated.changeDetectorRef.detectChanges();\n            this.activateEvents.emit(this.activated.instance);\n        };\n        RouterOutlet.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: 'router-outlet' },] },\n        ];\n        /** @nocollapse */\n        RouterOutlet.ctorParameters = [\n            { type: RouterOutletMap, },\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.ComponentFactoryResolver, },\n            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['name',] },] },\n        ];\n        RouterOutlet.propDecorators = {\n            'activateEvents': [{ type: _angular_core.Output, args: ['activate',] },],\n            'deactivateEvents': [{ type: _angular_core.Output, args: ['deactivate',] },],\n        };\n        return RouterOutlet;\n    }());\n\n    /**\n     * @whatItDoes Provides a preloading strategy.\n     *\n     * @experimental\n     */\n    var PreloadingStrategy = (function () {\n        function PreloadingStrategy() {\n        }\n        return PreloadingStrategy;\n    }());\n    /**\n     * @whatItDoes Provides a preloading strategy that preloads all modules as quicky as possible.\n     *\n     * @howToUse\n     *\n     * ```\n     * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n     * ```\n     *\n     * @experimental\n     */\n    var PreloadAllModules = (function () {\n        function PreloadAllModules() {\n        }\n        PreloadAllModules.prototype.preload = function (route, fn) {\n            return rxjs_operator_catch._catch.call(fn(), function () { return rxjs_observable_of.of(null); });\n        };\n        return PreloadAllModules;\n    }());\n    /**\n     * @whatItDoes Provides a preloading strategy that does not preload any modules.\n     *\n     * @description\n     *\n     * This strategy is enabled by default.\n     *\n     * @experimental\n     */\n    var NoPreloading = (function () {\n        function NoPreloading() {\n        }\n        NoPreloading.prototype.preload = function (route, fn) { return rxjs_observable_of.of(null); };\n        return NoPreloading;\n    }());\n    /**\n     * The preloader optimistically loads all router configurations to\n     * make navigations into lazily-loaded sections of the application faster.\n     *\n     * The preloader runs in the background. When the router bootstraps, the preloader\n     * starts listening to all navigation events. After every such event, the preloader\n     * will check if any configurations can be loaded lazily.\n     *\n     * If a route is protected by `canLoad` guards, the preloaded will not load it.\n     */\n    var RouterPreloader = (function () {\n        function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n            this.router = router;\n            this.injector = injector;\n            this.preloadingStrategy = preloadingStrategy;\n            this.loader = new RouterConfigLoader(moduleLoader, compiler);\n        }\n        ;\n        RouterPreloader.prototype.setUpPreloading = function () {\n            var _this = this;\n            var navigations = rxjs_operator_filter.filter.call(this.router.events, function (e) { return e instanceof NavigationEnd; });\n            this.subscription = rxjs_operator_concatMap.concatMap.call(navigations, function () { return _this.preload(); }).subscribe(function (v) { });\n        };\n        RouterPreloader.prototype.preload = function () { return this.processRoutes(this.injector, this.router.config); };\n        RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n        RouterPreloader.prototype.processRoutes = function (injector, routes) {\n            var res = [];\n            for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n                var c = routes_1[_i];\n                // we already have the config loaded, just recurce\n                if (c.loadChildren && !c.canLoad && c._loadedConfig) {\n                    var childConfig = c._loadedConfig;\n                    res.push(this.processRoutes(childConfig.injector, childConfig.routes));\n                }\n                else if (c.loadChildren && !c.canLoad) {\n                    res.push(this.preloadConfig(injector, c));\n                }\n                else if (c.children) {\n                    res.push(this.processRoutes(injector, c.children));\n                }\n            }\n            return rxjs_operator_mergeAll.mergeAll.call(rxjs_observable_from.from(res));\n        };\n        RouterPreloader.prototype.preloadConfig = function (injector, route) {\n            var _this = this;\n            return this.preloadingStrategy.preload(route, function () {\n                var loaded = _this.loader.load(injector, route.loadChildren);\n                return rxjs_operator_mergeMap.mergeMap.call(loaded, function (config) {\n                    var c = route;\n                    c._loadedConfig = config;\n                    return _this.processRoutes(config.injector, config.routes);\n                });\n            });\n        };\n        RouterPreloader.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        RouterPreloader.ctorParameters = [\n            { type: Router, },\n            { type: _angular_core.NgModuleFactoryLoader, },\n            { type: _angular_core.Compiler, },\n            { type: _angular_core.Injector, },\n            { type: PreloadingStrategy, },\n        ];\n        return RouterPreloader;\n    }());\n\n    /**\n     * @whatItDoes Contains a list of directives\n     * @stable\n     */\n    var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n    /**\n     * @whatItDoes Is used in DI to configure the router.\n     * @stable\n     */\n    var ROUTER_CONFIGURATION = new _angular_core.OpaqueToken('ROUTER_CONFIGURATION');\n    /**\n     * @docsNotRequired\n     */\n    var ROUTER_FORROOT_GUARD = new _angular_core.OpaqueToken('ROUTER_FORROOT_GUARD');\n    var ROUTER_PROVIDERS = [\n        _angular_common.Location, { provide: UrlSerializer, useClass: DefaultUrlSerializer }, {\n            provide: Router,\n            useFactory: setupRouter,\n            deps: [\n                _angular_core.ApplicationRef, UrlSerializer, RouterOutletMap, _angular_common.Location, _angular_core.Injector, _angular_core.NgModuleFactoryLoader,\n                _angular_core.Compiler, ROUTES, ROUTER_CONFIGURATION\n            ]\n        },\n        RouterOutletMap, { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n        { provide: _angular_core.NgModuleFactoryLoader, useClass: _angular_core.SystemJsNgModuleLoader }, RouterPreloader, NoPreloading,\n        PreloadAllModules, { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } }\n    ];\n    /**\n     * @whatItDoes Adds router directives and providers.\n     *\n     * @howToUse\n     *\n     * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n     * Since the router deals with a global shared resource--location, we cannot have\n     * more than one router service active.\n     *\n     * That is why there are two ways to create the module: `RouterModule.forRoot` and\n     * `RouterModule.forChild`.\n     *\n     * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n     * service itself.\n     * * `forChild` creates a module that contains all the directives and the given routes, but does not\n     * include\n     * the router service.\n     *\n     * When registered at the root, the module should be used as follows\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forRoot(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * For submodules and lazy loaded submodules the module should be used as follows:\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forChild(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @description\n     *\n     * Managing state transitions is one of the hardest parts of building applications. This is\n     * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n     * In addition, we often want to split applications into multiple bundles and load them on demand.\n     * Doing this transparently is not trivial.\n     *\n     * The Angular 2 router solves these problems. Using the router, you can declaratively specify\n     * application states, manage state transitions while taking care of the URL, and load bundles on\n     * demand.\n     *\n     * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n     * overview of how the router should be used.\n     *\n     * @stable\n     */\n    var RouterModule = (function () {\n        function RouterModule(guard) {\n        }\n        /**\n         * Creates a module with all the router providers and directives. It also optionally sets up an\n         * application listener to perform an initial navigation.\n         *\n         * Options:\n         * * `enableTracing` makes the router log all its internal events to the console.\n         * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n         * API.\n         * * `initialNavigation` disables the initial navigation.\n         * * `errorHandler` provides a custom error handler.\n         */\n        RouterModule.forRoot = function (routes, config) {\n            return {\n                ngModule: RouterModule,\n                providers: [\n                    ROUTER_PROVIDERS, provideRoutes(routes), {\n                        provide: ROUTER_FORROOT_GUARD,\n                        useFactory: provideForRootGuard,\n                        deps: [[Router, new _angular_core.Optional(), new _angular_core.SkipSelf()]]\n                    },\n                    { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} }, {\n                        provide: _angular_common.LocationStrategy,\n                        useFactory: provideLocationStrategy,\n                        deps: [\n                            _angular_common.PlatformLocation, [new _angular_core.Inject(_angular_common.APP_BASE_HREF), new _angular_core.Optional()], ROUTER_CONFIGURATION\n                        ]\n                    },\n                    {\n                        provide: PreloadingStrategy,\n                        useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n                            NoPreloading\n                    },\n                    provideRouterInitializer()\n                ]\n            };\n        };\n        /**\n         * Creates a module with all the router directives and a provider registering routes.\n         */\n        RouterModule.forChild = function (routes) {\n            return { ngModule: RouterModule, providers: [provideRoutes(routes)] };\n        };\n        RouterModule.decorators = [\n            { type: _angular_core.NgModule, args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },\n        ];\n        /** @nocollapse */\n        RouterModule.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [ROUTER_FORROOT_GUARD,] },] },\n        ];\n        return RouterModule;\n    }());\n    function provideLocationStrategy(platformLocationStrategy, baseHref, options) {\n        if (options === void 0) { options = {}; }\n        return options.useHash ? new _angular_common.HashLocationStrategy(platformLocationStrategy, baseHref) :\n            new _angular_common.PathLocationStrategy(platformLocationStrategy, baseHref);\n    }\n    function provideForRootGuard(router) {\n        if (router) {\n            throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n        }\n        return 'guarded';\n    }\n    /**\n     * @whatItDoes Registers routes.\n     *\n     * @howToUse\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forChild(ROUTES)],\n     *   providers: [provideRoutes(EXTRA_ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @stable\n     */\n    function provideRoutes(routes) {\n        return [\n            { provide: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },\n            { provide: ROUTES, multi: true, useValue: routes }\n        ];\n    }\n    function setupRouter(ref, urlSerializer, outletMap, location, injector, loader, compiler, config, opts) {\n        if (opts === void 0) { opts = {}; }\n        var r = new Router(null, urlSerializer, outletMap, location, injector, loader, compiler, flatten(config));\n        if (opts.errorHandler) {\n            r.errorHandler = opts.errorHandler;\n        }\n        if (opts.enableTracing) {\n            r.events.subscribe(function (e) {\n                console.group(\"Router Event: \" + e.constructor.name);\n                console.log(e.toString());\n                console.log(e);\n                console.groupEnd();\n            });\n        }\n        return r;\n    }\n    function rootRoute(router) {\n        return router.routerState.root;\n    }\n    function initialRouterNavigation(router, ref, preloader, opts) {\n        return function () {\n            router.resetRootComponentType(ref.componentTypes[0]);\n            preloader.setUpPreloading();\n            if (opts.initialNavigation === false) {\n                router.setUpLocationChangeListener();\n            }\n            else {\n                router.initialNavigation();\n            }\n        };\n    }\n    function provideRouterInitializer() {\n        return {\n            provide: _angular_core.APP_BOOTSTRAP_LISTENER,\n            multi: true,\n            useFactory: initialRouterNavigation,\n            deps: [Router, _angular_core.ApplicationRef, RouterPreloader, ROUTER_CONFIGURATION]\n        };\n    }\n\n    var __router_private__ = {\n        ROUTER_PROVIDERS: ROUTER_PROVIDERS,\n        ROUTES: ROUTES,\n        flatten: flatten\n    };\n\n    exports.RouterLink = RouterLink;\n    exports.RouterLinkWithHref = RouterLinkWithHref;\n    exports.RouterLinkActive = RouterLinkActive;\n    exports.RouterOutlet = RouterOutlet;\n    exports.NavigationCancel = NavigationCancel;\n    exports.NavigationEnd = NavigationEnd;\n    exports.NavigationError = NavigationError;\n    exports.NavigationStart = NavigationStart;\n    exports.Router = Router;\n    exports.RoutesRecognized = RoutesRecognized;\n    exports.RouterModule = RouterModule;\n    exports.provideRoutes = provideRoutes;\n    exports.RouterOutletMap = RouterOutletMap;\n    exports.NoPreloading = NoPreloading;\n    exports.PreloadAllModules = PreloadAllModules;\n    exports.PreloadingStrategy = PreloadingStrategy;\n    exports.ActivatedRoute = ActivatedRoute;\n    exports.ActivatedRouteSnapshot = ActivatedRouteSnapshot;\n    exports.RouterState = RouterState;\n    exports.RouterStateSnapshot = RouterStateSnapshot;\n    exports.PRIMARY_OUTLET = PRIMARY_OUTLET;\n    exports.DefaultUrlSerializer = DefaultUrlSerializer;\n    exports.UrlSegment = UrlSegment;\n    exports.UrlSerializer = UrlSerializer;\n    exports.UrlTree = UrlTree;\n    exports.__router_private__ = __router_private__;\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/@angular/router/bundles/router.umd.js\n ** module id = 137\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/BehaviorSubject.js\n ** module id = 144\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/InnerSubscriber.js\n ** module id = 145\n ** module chunks = 1\n **/","\"use strict\";\nvar Observable_1 = require('./Observable');\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = (function () {\n    function Notification(kind, value, exception) {\n        this.kind = kind;\n        this.value = value;\n        this.exception = exception;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.exception);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.exception);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return Observable_1.Observable.of(this.value);\n            case 'E':\n                return Observable_1.Observable.throw(this.exception);\n            case 'C':\n                return Observable_1.Observable.empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return this.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` exception.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     */\n    Notification.createComplete = function () {\n        return this.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexports.Notification = Notification;\n//# sourceMappingURL=Notification.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Notification.js\n ** module id = 146\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/OuterSubscriber.js\n ** module id = 57\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayLikeObservable = (function (_super) {\n    __extends(ArrayLikeObservable, _super);\n    function ArrayLikeObservable(arrayLike, scheduler) {\n        _super.call(this);\n        this.arrayLike = arrayLike;\n        this.scheduler = scheduler;\n        if (!scheduler && arrayLike.length === 1) {\n            this._isScalar = true;\n            this.value = arrayLike[0];\n        }\n    }\n    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n        var length = arrayLike.length;\n        if (length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (length === 1) {\n            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n        }\n        else {\n            return new ArrayLikeObservable(arrayLike, scheduler);\n        }\n    };\n    ArrayLikeObservable.dispatch = function (state) {\n        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n        if (subscriber.closed) {\n            return;\n        }\n        if (index >= length) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(arrayLike[index]);\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n        var length = arrayLike.length;\n        if (scheduler) {\n            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < length && !subscriber.closed; i++) {\n                subscriber.next(arrayLike[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayLikeObservable;\n}(Observable_1.Observable));\nexports.ArrayLikeObservable = ArrayLikeObservable;\n//# sourceMappingURL=ArrayLikeObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ArrayLikeObservable.js\n ** module id = 149\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isScheduler_1 = require('../util/isScheduler');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = (function (_super) {\n    __extends(ArrayObservable, _super);\n    function ArrayObservable(array, scheduler) {\n        _super.call(this);\n        this.array = array;\n        this.scheduler = scheduler;\n        if (!scheduler && array.length === 1) {\n            this._isScalar = true;\n            this.value = array[0];\n        }\n    }\n    ArrayObservable.create = function (array, scheduler) {\n        return new ArrayObservable(array, scheduler);\n    };\n    /**\n     * Creates an Observable that emits some values you specify as arguments,\n     * immediately one after the other, and then emits a complete notification.\n     *\n     * <span class=\"informal\">Emits the arguments you provide, then completes.\n     * </span>\n     *\n     * <img src=\"./img/of.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the arguments given, and the complete notification thereafter. It can\n     * be used for composing with other Observables, such as with {@link concat}.\n     * By default, it uses a `null` Scheduler, which means the `next`\n     * notifications are sent synchronously, although with a different Scheduler\n     * it is possible to determine when those notifications will be delivered.\n     *\n     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n     * var numbers = Rx.Observable.of(10, 20, 30);\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = numbers.concat(letters).concat(interval);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link throw}\n     *\n     * @param {...T} values Arguments that represent `next` values to be emitted.\n     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable<T>} An Observable that emits each given input value.\n     * @static true\n     * @name of\n     * @owner Observable\n     */\n    ArrayObservable.of = function () {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i - 0] = arguments[_i];\n        }\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len > 1) {\n            return new ArrayObservable(array, scheduler);\n        }\n        else if (len === 1) {\n            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n        }\n        else {\n            return new EmptyObservable_1.EmptyObservable(scheduler);\n        }\n    };\n    ArrayObservable.dispatch = function (state) {\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(array[index]);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var array = this.array;\n        var count = array.length;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                array: array, index: index, count: count, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < count && !subscriber.closed; i++) {\n                subscriber.next(array[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayObservable;\n}(Observable_1.Observable));\nexports.ArrayObservable = ArrayObservable;\n//# sourceMappingURL=ArrayObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ArrayObservable.js\n ** module id = 86\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar EmptyObservable = (function (_super) {\n    __extends(EmptyObservable, _super);\n    function EmptyObservable(scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits a complete notification.\n     *\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/empty.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the complete notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then complete.</caption>\n     * var result = Rx.Observable.empty().startWith(7);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n     * the emission of the complete notification.\n     * @return {Observable} An \"empty\" Observable: emits only the complete\n     * notification.\n     * @static true\n     * @name empty\n     * @owner Observable\n     */\n    EmptyObservable.create = function (scheduler) {\n        return new EmptyObservable(scheduler);\n    };\n    EmptyObservable.dispatch = function (arg) {\n        var subscriber = arg.subscriber;\n        subscriber.complete();\n    };\n    EmptyObservable.prototype._subscribe = function (subscriber) {\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n        }\n        else {\n            subscriber.complete();\n        }\n    };\n    return EmptyObservable;\n}(Observable_1.Observable));\nexports.EmptyObservable = EmptyObservable;\n//# sourceMappingURL=EmptyObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/EmptyObservable.js\n ** module id = 87\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = require('../util/isArray');\nvar isPromise_1 = require('../util/isPromise');\nvar PromiseObservable_1 = require('./PromiseObservable');\nvar IteratorObservable_1 = require('./IteratorObservable');\nvar ArrayObservable_1 = require('./ArrayObservable');\nvar ArrayLikeObservable_1 = require('./ArrayLikeObservable');\nvar iterator_1 = require('../symbol/iterator');\nvar Observable_1 = require('../Observable');\nvar observeOn_1 = require('../operator/observeOn');\nvar observable_1 = require('../symbol/observable');\nvar isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromObservable = (function (_super) {\n    __extends(FromObservable, _super);\n    function FromObservable(ish, scheduler) {\n        _super.call(this, null);\n        this.ish = ish;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable from an Array, an array-like object, a Promise, an\n     * iterable object, or an Observable-like object.\n     *\n     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n     *\n     * <img src=\"./img/from.png\" width=\"100%\">\n     *\n     * Convert various other objects and data types into Observables. `from`\n     * converts a Promise or an array-like or an\n     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n     * object into an Observable that emits the items in that promise or array or\n     * iterable. A String, in this context, is treated as an array of characters.\n     * Observable-like objects (contains a function named with the ES2015 Symbol\n     * for Observable) can also be converted through this operator.\n     *\n     * @example <caption>Converts an array to an Observable</caption>\n     * var array = [10, 20, 30];\n     * var result = Rx.Observable.from(array);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n     * function* generateDoubles(seed) {\n     *   var i = seed;\n     *   while (true) {\n     *     yield i;\n     *     i = 2 * i; // double it\n     *   }\n     * }\n     *\n     * var iterator = generateDoubles(3);\n     * var result = Rx.Observable.from(iterator).take(10);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link fromEvent}\n     * @see {@link fromEventPattern}\n     * @see {@link fromPromise}\n     *\n     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n     * Observable-like, an Array, an iterable or an array-like object to be\n     * converted.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * emissions of values.\n     * @return {Observable<T>} The Observable whose values are originally from the\n     * input object that was converted.\n     * @static true\n     * @name from\n     * @owner Observable\n     */\n    FromObservable.create = function (ish, scheduler) {\n        if (ish != null) {\n            if (typeof ish[observable_1.$$observable] === 'function') {\n                if (ish instanceof Observable_1.Observable && !scheduler) {\n                    return ish;\n                }\n                return new FromObservable(ish, scheduler);\n            }\n            else if (isArray_1.isArray(ish)) {\n                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n            }\n            else if (isPromise_1.isPromise(ish)) {\n                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n            }\n            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {\n                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n            }\n            else if (isArrayLike(ish)) {\n                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n            }\n        }\n        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n    };\n    FromObservable.prototype._subscribe = function (subscriber) {\n        var ish = this.ish;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            return ish[observable_1.$$observable]().subscribe(subscriber);\n        }\n        else {\n            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n        }\n    };\n    return FromObservable;\n}(Observable_1.Observable));\nexports.FromObservable = FromObservable;\n//# sourceMappingURL=FromObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/FromObservable.js\n ** module id = 150\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IteratorObservable = (function (_super) {\n    __extends(IteratorObservable, _super);\n    function IteratorObservable(iterator, scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n        if (iterator == null) {\n            throw new Error('iterator cannot be null.');\n        }\n        this.iterator = getIterator(iterator);\n    }\n    IteratorObservable.create = function (iterator, scheduler) {\n        return new IteratorObservable(iterator, scheduler);\n    };\n    IteratorObservable.dispatch = function (state) {\n        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n        if (hasError) {\n            subscriber.error(state.error);\n            return;\n        }\n        var result = iterator.next();\n        if (result.done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(result.value);\n        state.index = index + 1;\n        if (subscriber.closed) {\n            return;\n        }\n        this.schedule(state);\n    };\n    IteratorObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                index: index, iterator: iterator, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                var result = iterator.next();\n                if (result.done) {\n                    subscriber.complete();\n                    break;\n                }\n                else {\n                    subscriber.next(result.value);\n                }\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return IteratorObservable;\n}(Observable_1.Observable));\nexports.IteratorObservable = IteratorObservable;\nvar StringIterator = (function () {\n    function StringIterator(str, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = str.length; }\n        this.str = str;\n        this.idx = idx;\n        this.len = len;\n    }\n    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };\n    StringIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.str.charAt(this.idx++)\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return StringIterator;\n}());\nvar ArrayIterator = (function () {\n    function ArrayIterator(arr, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = toLength(arr); }\n        this.arr = arr;\n        this.idx = idx;\n        this.len = len;\n    }\n    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };\n    ArrayIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return ArrayIterator;\n}());\nfunction getIterator(obj) {\n    var i = obj[iterator_1.$$iterator];\n    if (!i && typeof obj === 'string') {\n        return new StringIterator(obj);\n    }\n    if (!i && obj.length !== undefined) {\n        return new ArrayIterator(obj);\n    }\n    if (!i) {\n        throw new TypeError('object is not iterable');\n    }\n    return obj[iterator_1.$$iterator]();\n}\nvar maxSafeInteger = Math.pow(2, 53) - 1;\nfunction toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) {\n        return 0;\n    }\n    if (len === 0 || !numberIsFinite(len)) {\n        return len;\n    }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) {\n        return 0;\n    }\n    if (len > maxSafeInteger) {\n        return maxSafeInteger;\n    }\n    return len;\n}\nfunction numberIsFinite(value) {\n    return typeof value === 'number' && root_1.root.isFinite(value);\n}\nfunction sign(value) {\n    var valueAsNumber = +value;\n    if (valueAsNumber === 0) {\n        return valueAsNumber;\n    }\n    if (isNaN(valueAsNumber)) {\n        return valueAsNumber;\n    }\n    return valueAsNumber < 0 ? -1 : 1;\n}\n//# sourceMappingURL=IteratorObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/IteratorObservable.js\n ** module id = 151\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ScalarObservable = (function (_super) {\n    __extends(ScalarObservable, _super);\n    function ScalarObservable(value, scheduler) {\n        _super.call(this);\n        this.value = value;\n        this.scheduler = scheduler;\n        this._isScalar = true;\n        if (scheduler) {\n            this._isScalar = false;\n        }\n    }\n    ScalarObservable.create = function (value, scheduler) {\n        return new ScalarObservable(value, scheduler);\n    };\n    ScalarObservable.dispatch = function (state) {\n        var done = state.done, value = state.value, subscriber = state.subscriber;\n        if (done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        state.done = true;\n        this.schedule(state);\n    };\n    ScalarObservable.prototype._subscribe = function (subscriber) {\n        var value = this.value;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                done: false, value: value, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.next(value);\n            if (!subscriber.closed) {\n                subscriber.complete();\n            }\n        }\n    };\n    return ScalarObservable;\n}(Observable_1.Observable));\nexports.ScalarObservable = ScalarObservable;\n//# sourceMappingURL=ScalarObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ScalarObservable.js\n ** module id = 89\n ** module chunks = 1\n **/","\"use strict\";\nvar FromObservable_1 = require('./FromObservable');\nexports.from = FromObservable_1.FromObservable.create;\n//# sourceMappingURL=from.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/from.js\n ** module id = 152\n ** module chunks = 1\n **/","\"use strict\";\nvar ArrayObservable_1 = require('./ArrayObservable');\nexports.of = ArrayObservable_1.ArrayObservable.of;\n//# sourceMappingURL=of.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/of.js\n ** module id = 153\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} an observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    var operator = new CatchOperator(selector);\n    var caught = this.lift(operator);\n    return (operator.caught = caught);\n}\nexports._catch = _catch;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.unsubscribe();\n            this.destination.remove(this);\n            subscribeToResult_1.subscribeToResult(this, result);\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catch.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/catch.js\n ** module id = 154\n ** module chunks = 1\n **/","\"use strict\";\nvar mergeAll_1 = require('./mergeAll');\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return this.lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/concatAll.js\n ** module id = 155\n ** module chunks = 1\n **/","\"use strict\";\nvar mergeMap_1 = require('./mergeMap');\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} an observable of values merged from the projected\n * Observables as they were subscribed to, one at a time. Optionally, these\n * values may have been projected from a passed `projectResult` argument.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/concatMap.js\n ** module id = 156\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n * @param {function} predicate a function for determining if an item meets a specified condition.\n * @param {any} [thisArg] optional object to use for `this` in the callback\n * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return this.lift(new EveryOperator(predicate, thisArg, this));\n}\nexports.every = every;\nvar EveryOperator = (function () {\n    function EveryOperator(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    EveryOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    };\n    return EveryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar EverySubscriber = (function (_super) {\n    __extends(EverySubscriber, _super);\n    function EverySubscriber(destination, predicate, thisArg, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n        this.index = 0;\n        this.thisArg = thisArg || this;\n    }\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    };\n    EverySubscriber.prototype._next = function (value) {\n        var result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    };\n    EverySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return EverySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=every.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/every.js\n ** module id = 157\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctKey}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return this.lift(new FilterOperator(predicate, thisArg));\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n        this.predicate = predicate;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/filter.js\n ** module id = 158\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} an Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.first = first;\nvar FirstOperator = (function () {\n    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    FirstOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return FirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FirstSubscriber = (function (_super) {\n    __extends(FirstSubscriber, _super);\n    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.index = 0;\n        this.hasCompleted = false;\n    }\n    FirstSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._emit = function (value, index) {\n        if (this.resultSelector) {\n            this._tryResultSelector(value, index);\n            return;\n        }\n        this._emitFinal(value);\n    };\n    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this._emitFinal(result);\n    };\n    FirstSubscriber.prototype._emitFinal = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n        this.hasCompleted = true;\n    };\n    FirstSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n            destination.next(this.defaultValue);\n            destination.complete();\n        }\n        else if (!this.hasCompleted) {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return FirstSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=first.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/first.js\n ** module id = 159\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - the condition any source emitted item has to satisfy.\n * @return {Observable} an Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.last = last;\nvar LastOperator = (function () {\n    function LastOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    LastOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return LastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar LastSubscriber = (function (_super) {\n    __extends(LastSubscriber, _super);\n    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.hasValue = false;\n        this.index = 0;\n        if (typeof defaultValue !== 'undefined') {\n            this.lastValue = defaultValue;\n            this.hasValue = true;\n        }\n    }\n    LastSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.lastValue = result;\n        this.hasValue = true;\n    };\n    LastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.hasValue) {\n            destination.next(this.lastValue);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return LastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=last.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/last.js\n ** module id = 160\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/map.js\n ** module id = 161\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return this.lift(new MergeAllOperator(concurrent));\n}\nexports.mergeAll = mergeAll;\nvar MergeAllOperator = (function () {\n    function MergeAllOperator(concurrent) {\n        this.concurrent = concurrent;\n    }\n    MergeAllOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new MergeAllSubscriber(observer, this.concurrent));\n    };\n    return MergeAllOperator;\n}());\nexports.MergeAllOperator = MergeAllOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeAllSubscriber = (function (_super) {\n    __extends(MergeAllSubscriber, _super);\n    function MergeAllSubscriber(destination, concurrent) {\n        _super.call(this, destination);\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n    }\n    MergeAllSubscriber.prototype._next = function (observable) {\n        if (this.active < this.concurrent) {\n            this.active++;\n            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n        }\n        else {\n            this.buffer.push(observable);\n        }\n    };\n    MergeAllSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeAllSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeAllSubscriber = MergeAllSubscriber;\n//# sourceMappingURL=mergeAll.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/mergeAll.js\n ** module id = 91\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n}\nexports.mergeMap = mergeMap;\nvar MergeMapOperator = (function () {\n    function MergeMapOperator(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = (function (_super) {\n    __extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapSubscriber = MergeMapSubscriber;\n//# sourceMappingURL=mergeMap.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/mergeMap.js\n ** module id = 92\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * @see {@link Notification}\n *\n * @param scheduler\n * @param delay\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return this.lift(new ObserveOnOperator(scheduler, delay));\n}\nexports.observeOn = observeOn;\nvar ObserveOnOperator = (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification_1.Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification_1.Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification_1.Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\nvar ObserveOnMessage = (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexports.ObserveOnMessage = ObserveOnMessage;\n//# sourceMappingURL=observeOn.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/observeOn.js\n ** module id = 162\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    return this.lift(new ReduceOperator(accumulator, seed));\n}\nexports.reduce = reduce;\nvar ReduceOperator = (function () {\n    function ReduceOperator(accumulator, seed) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n    }\n    ReduceOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed));\n    };\n    return ReduceOperator;\n}());\nexports.ReduceOperator = ReduceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ReduceSubscriber = (function (_super) {\n    __extends(ReduceSubscriber, _super);\n    function ReduceSubscriber(destination, accumulator, seed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.hasValue = false;\n        this.acc = seed;\n        this.accumulator = accumulator;\n        this.hasSeed = typeof seed !== 'undefined';\n    }\n    ReduceSubscriber.prototype._next = function (value) {\n        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n            this._tryReduce(value);\n        }\n        else {\n            this.acc = value;\n            this.hasValue = true;\n        }\n    };\n    ReduceSubscriber.prototype._tryReduce = function (value) {\n        var result;\n        try {\n            result = this.accumulator(this.acc, value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.acc = result;\n    };\n    ReduceSubscriber.prototype._complete = function () {\n        if (this.hasValue || this.hasSeed) {\n            this.destination.next(this.acc);\n        }\n        this.destination.complete();\n    };\n    return ReduceSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ReduceSubscriber = ReduceSubscriber;\n//# sourceMappingURL=reduce.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/reduce.js\n ** module id = 163\n ** module chunks = 1\n **/","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nif (typeof Symbol === 'function') {\n    if (Symbol.iterator) {\n        exports.$$iterator = Symbol.iterator;\n    }\n    else if (typeof Symbol.for === 'function') {\n        exports.$$iterator = Symbol.for('iterator');\n    }\n}\nelse {\n    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {\n        // Bug for mozilla version\n        exports.$$iterator = '@@iterator';\n    }\n    else if (root_1.root.Map) {\n        // es6-shim specific logic\n        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {\n                exports.$$iterator = key;\n                break;\n            }\n        }\n    }\n    else {\n        exports.$$iterator = '@@iterator';\n    }\n}\n//# sourceMappingURL=iterator.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/iterator.js\n ** module id = 59\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nvar EmptyError = (function (_super) {\n    __extends(EmptyError, _super);\n    function EmptyError() {\n        var err = _super.call(this, 'no elements in sequence');\n        this.name = err.name = 'EmptyError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return EmptyError;\n}(Error));\nexports.EmptyError = EmptyError;\n//# sourceMappingURL=EmptyError.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/EmptyError.js\n ** module id = 62\n ** module chunks = 1\n **/","\"use strict\";\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isPromise.js\n ** module id = 96\n ** module chunks = 1\n **/","\"use strict\";\nfunction isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\nexports.isScheduler = isScheduler;\n//# sourceMappingURL=isScheduler.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isScheduler.js\n ** module id = 167\n ** module chunks = 1\n **/","\"use strict\";\nvar root_1 = require('./root');\nvar isArray_1 = require('./isArray');\nvar isPromise_1 = require('./isPromise');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\nvar InnerSubscriber_1 = require('../InnerSubscriber');\nvar observable_1 = require('../symbol/observable');\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            return result.subscribe(destination);\n        }\n    }\n    if (isArray_1.isArray(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (typeof result[iterator_1.$$iterator] === 'function') {\n        var iterator = result[iterator_1.$$iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (typeof result[observable_1.$$observable] === 'function') {\n        var obs = result[observable_1.$$observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new Error('invalid observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        destination.error(new TypeError('unknown type returned'));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/subscribeToResult.js\n ** module id = 64\n ** module chunks = 1\n **/"],"sourceRoot":""}