{"version":3,"sources":["webpack:///main.3779b4e91740181a7157.bundle.js","webpack:///./components/index.ts","webpack:///./components/network/index.ts","webpack:///./components/network/vis-network.directive.ts","webpack:///./components/network/vis-network.service.ts","webpack:///./components/timeline/index.ts","webpack:///./components/timeline/vis-timeline.directive.ts","webpack:///./components/timeline/vis-timeline.service.ts","webpack:///./demo/demo.component.html","webpack:///./demo/demo.component.ts","webpack:///./demo/demo.module.ts","webpack:///./demo/home/home.component.html","webpack:///./demo/home/home.component.ts","webpack:///./demo/index.ts","webpack:///./demo/network/network-example.component.css","webpack:///./demo/network/network-example.component.html","webpack:///./demo/network/network-example.component.ts","webpack:///./demo/timeline/timeline-example.component.css","webpack:///./demo/timeline/timeline-example.component.html","webpack:///./demo/timeline/timeline-example.component.ts","webpack:///./ng2-vis.ts","webpack:///./~/@angular/router/bundles/router.umd.js","webpack:///./~/rxjs/BehaviorSubject.js","webpack:///./~/rxjs/InnerSubscriber.js","webpack:///./~/rxjs/Notification.js","webpack:///./~/rxjs/OuterSubscriber.js","webpack:///./~/rxjs/observable/ArrayLikeObservable.js","webpack:///./~/rxjs/observable/ArrayObservable.js","webpack:///./~/rxjs/observable/EmptyObservable.js","webpack:///./~/rxjs/observable/FromObservable.js","webpack:///./~/rxjs/observable/IteratorObservable.js","webpack:///./~/rxjs/observable/ScalarObservable.js","webpack:///./~/rxjs/observable/from.js","webpack:///./~/rxjs/observable/of.js","webpack:///./~/rxjs/operator/catch.js","webpack:///./~/rxjs/operator/concatAll.js","webpack:///./~/rxjs/operator/concatMap.js","webpack:///./~/rxjs/operator/every.js","webpack:///./~/rxjs/operator/filter.js","webpack:///./~/rxjs/operator/first.js","webpack:///./~/rxjs/operator/last.js","webpack:///./~/rxjs/operator/map.js","webpack:///./~/rxjs/operator/mergeAll.js","webpack:///./~/rxjs/operator/mergeMap.js","webpack:///./~/rxjs/operator/observeOn.js","webpack:///./~/rxjs/operator/reduce.js","webpack:///./~/rxjs/symbol/iterator.js","webpack:///./~/rxjs/util/EmptyError.js","webpack:///./~/rxjs/util/isPromise.js","webpack:///./~/rxjs/util/isScheduler.js","webpack:///./~/rxjs/util/subscribeToResult.js"],"names":["webpackJsonp","322","module","exports","__webpack_require__","__export","m","p","hasOwnProperty","56","Vis","VisNetwork","_super","apply","this","arguments","__extends","Network","VisNodes","data","options","call","prototype","getLength","length","add","senderId","clear","distinct","field","flush","forEach","callback","getAll","get","getById","id","getByIds","ids","getDataSet","getIds","map","max","min","on","event","off","removeItems","remove","setOptions","update","DataSet","VisEdges","323","core_1","vis_network_service_1","VisNetworkDirective","elementRef","visNetworkService","initialized","EventEmitter","isInitialized","visNetworkContainer","nativeElement","ngOnInit","visNetwork","visNetworkData","createNetwork","ngOnChanges","changes","propertyName","change","isFirstChange","setData","currentValue","ngOnDestroy","destroy","create","visNetworkOptions","emit","__decorate","Input","__metadata","String","Object","Output","Directive","selector","ElementRef","VisNetworkService","134","index_1","click","doubleClick","oncontext","hold","release","select","selectNode","selectEdge","deselectNode","deselectEdge","dragStart","dragging","dragEnd","hoverNode","blurNode","hoverEdge","blurEdge","zoom","showPopup","hidePopup","startStabilizing","stabilizationProgress","stabilizationIterationsDone","stabilized","resize","initRedraw","beforeDrawing","afterDrawing","animationFinished","configChange","networks","container","Error","eventName","preventDefault","that_1","params","emitter","concat","once","_this","that_2","selectNodes","nodeIds","highlightEdges","getSelection","getSelectedNodes","getSelectedEdges","unselectAll","fit","redraw","enableEditMode","addEdgeMode","disableEditMode","deleteSelected","cluster","clusterByConnection","nodeId","clusterByHubsize","hubsize","clusterOutliers","findNode","getClusteredEdges","baseEdgeId","getBaseEdge","clusteredEdgeId","updateEdge","startEdgeId","updateClusteredNode","clusteredNodeId","getNodesInCluster","clusterNodeId","openCluster","isCluster","getSeed","Injectable","43","VisTimelineItems","VisTimelineGroups","VisTimeline","Timeline","324","vis_timeline_service_1","VisTimelineDirective","visTimelineService","visTimelineContainer","visTimeline","visTimelineItems","createTimeline","setItems","setGroups","visTimelineGroups","createWithItemsAndGroups","visTimelineOptions","createWithItems","VisTimelineService","135","currentTimeTick","contextmenu","groupDragged","changed","rangechange","rangechanged","itemover","itemout","timechange","timechanged","timelines","items","alreadyExistsError","groups","addCustomTime","time","doesNotExistError","focusOnId","focus","focusOnIds","getCurrentTime","getCustomTime","getEventProperties","getItemRange","getVisibleItems","getWindow","moveTo","removeCustomTime","setCurrentTime","setCustomTime","setCustomTimeTitle","title","setSelectionToId","setSelection","setSelectionToIds","setWindow","start","end","undefined","138","325","DemoComponent","Component","template","326","forms_1","platform_browser_1","common_1","router_1","network_example_component_1","timeline_example_component_1","ng2_vis_1","demo_component_1","home_component_1","VisDemoModule","NgModule","declarations","HomeComponent","VisNetworkExampleComponent","VisTimelineExampleComponent","imports","BrowserModule","FormsModule","VisModule","CommonModule","RouterModule","forRoot","path","component","redirectTo","pathMatch","providers","bootstrap","139","327","0","platform_browser_dynamic_1","demo_module_1","platformBrowserDynamic","bootstrapModule","140","141","328","network_1","ExampleNetworkData","addNode","newId","nodes","toString","label","networkInitialized","subscribe","eventData","console","log","edges","from","to","styles","142","143","329","timeline_1","timelineInitialized","addItem","newLength","content","Date","now","type","330","index_2","137","global","factory","_angular_common","_angular_core","rxjs_BehaviorSubject","rxjs_Subject","rxjs_observable_from","rxjs_observable_of","rxjs_operator_concatMap","rxjs_operator_every","rxjs_operator_first","rxjs_operator_map","rxjs_operator_mergeMap","rxjs_operator_reduce","rxjs_Observable","rxjs_operator_catch","rxjs_operator_concatAll","rxjs_util_EmptyError","rxjs_observable_fromPromise","l","rxjs_operator_mergeAll","_angular_platformBrowser","rxjs_operator_filter","defaultUrlMatcher","segments","segmentGroup","route","parts","split","posParams","consumed","currentIndex","i","current","isPosParam","startsWith","substring","push","hasChildren","shallowEqualArrays","a","b","shallowEqual","k1","keys","k2","key","flatten","target","j","last","merge","m1","m2","attr","prop","waitForMap","obj","fn","waitFor","res","k","PRIMARY_OUTLET","_","concatted$","concatAll","of","last$","andObservables","observables","merged$","mergeAll","every","result","wrapIntoObservable","value","Observable","Promise","fromPromise","createEmptyUrlTree","UrlTree","UrlSegmentGroup","containsTree","containee","exact","equalQueryParams","queryParams","equalSegmentGroups","root","containsQueryParams","containsSegmentGroup","equalPath","numberOfChildren","c","children","containsSegmentGroupHelper","containeePaths","slice","next","equalSegments","parameters","mapChildrenIntoArray","segment","child","childOutlet","serializePaths","serializePath","join","serializeSegment","primary","children_1","v","encode","s","encodeURIComponent","decode","decodeURIComponent","serializeParams","pairs","first","second","serializeQueryParams","strs","Pair","matchSegments","str","SEGMENT_RE","lastIndex","match","matchQueryParams","QUERY_PARAM_RE","matchUrlQueryParamValue","QUERY_PARAM_VALUE_RE","noMatch","obs","error","NoMatch","absoluteRedirect","newTree","AbsoluteRedirect","namedOutletsRedirect","canLoadFails","NavigationCancelingError","applyRedirects","injector","configLoader","urlSerializer","urlTree","config","ApplyRedirects","runGuards","canLoad","guard","matched","consumedSegments","lastChild","positionalParamSegments","matcher","slicedSegments","containsEmptyPathRedirectsWithNamedOutlets","createChildrenForEmptySegments","mergeTrivialChildren","containsEmptyPathRedirects","addEmptySegmentsToChildrenIfNeeded","routes","_i","routes_1","r","emptyPathRedirect","getOutlet$1","primarySegmentGroup","routes_2","filter","outlet","validateConfig","validateNode","Array","isArray","loadChildren","exp","expected","_a","cc","findPath","collected","cloned","createEmptyState","rootComponent","snapshot","createEmptyStateSnapshot","emptyUrl","BehaviorSubject","UrlSegment","emptyParams","emptyData","emptyQueryParams","fragment","activated","ActivatedRoute","RouterState","TreeNode","ActivatedRouteSnapshot","RouterStateSnapshot","inheritedParamsDataResolve","pathToRoot","pathFromRoot","inhertingStartingFrom","parent_1","routeConfig","reduce","curr","resolve","_resolvedData","setRouterStateSnapshot","state","node","_routerState","serializeNode","advanceActivatedRoute","_futureSnapshot","url","equalParamsAndUrlSegments","createRouterState","prevState","createNode","_root","equalRouteSnapshots","createOrReuseChildren","createActivatedRoute","_routeConfig","createUrlTree","commands","tree","normalizedCommands","normalizeCommands","validateCommands","navigateToRoot","startingPosition","findStartingPosition","processChildren","updateSegmentGroupChildren","index","updateSegmentGroup","n","isAbsolute","isMatrixParams","outlets","command","segmentPath","oldSegmentGroup","newSegmentGroup","stringify","replaceSegment","oldSegment","newSegment","outletName","normalizedChange","NormalizedNavigationCommands","numberOfDoubleDots","_loop_1","r_1","name","Position","_lastPathIndex","_urlSegment","modifier","createPositionApplyingDoubleDots","group","g","ci","dd","parent","getPath","getOutlets","_b","startIndex","prefixedWith","slicedCommands","commandIndex","pathIndex","createNewSegmentGroup","outlets_1","currentCommandIndex","currentPathIndex","compare","paths","createNewSegmentChldren","recognize","rootComponentType","Recognizer","sortActivatedRouteSnapshots","sort","localeCompare","getChildConfig","_loadedConfig","match$1","NoMatch$1","checkOutletNameUniqueness","names","routeWithSameOutletName","getSourceSegmentGroup","_sourceSegment","getPathIndexShift","_segmentIndexShift","split$1","containsEmptyPathMatchesWithNamedOutlets","createChildrenForEmptyPaths","containsEmptyPathMatches","addEmptyPathsToChildrenIfNeeded","emptyPathMatch","getOutlet$2","primarySegment","getData","getResolve","defaultErrorHandler","parentLoadedConfig","closestLoadedConfig","nodeChildrenAsMap","getOutlet","outletMap","_outlets","componentName","toBool","provideLocationStrategy","platformLocationStrategy","baseHref","useHash","HashLocationStrategy","PathLocationStrategy","provideForRootGuard","router","provideRoutes","provide","ANALYZE_FOR_ENTRY_COMPONENTS","multi","useValue","ROUTES","setupRouter","ref","location","loader","compiler","opts","urlHandlingStrategy","Router","errorHandler","enableTracing","dom_1","getDOM","events","e","logGroup","constructor","logGroupEnd","rootRoute","routerState","initialRouterNavigation","preloader","bootstrappedComponentRef","components","resetRootComponentType","componentTypes","setUpPreloading","initialNavigation","setUpLocationChangeListener","provideRouterInitializer","ROUTER_INITIALIZER","useFactory","deps","ApplicationRef","RouterPreloader","ROUTER_CONFIGURATION","APP_BOOTSTRAP_LISTENER","useExisting","d","__","message","stack","OpaqueToken","LoadedRouterConfig","factoryResolver","injectorFactory","RouterConfigLoader","load","parentInjector","loadModuleFactory","componentFactoryResolver","offlineMode_1","Compiler","mergeMap","t","compileModuleAsync","DefaultUrlSerializer","serialize","defineProperty","enumerable","configurable","UrlSerializer","parse","UrlParser","parseRootSegment","parseQueryParams","parseFragment","query","encodeURI","remaining","peekStartsWith","capture","parseChildren","parseSegments","parseParens","matrixParams","parseMatrixParams","parseQueryParam","decodeURI","parseParam","valueMatch","allowPrimary","indexOf","substr","allowRedirects","expanded$","expandSegmentGroup","urlTrees$","rootSegmentGroup","_catch","noMatchError","mapped$","rootCandidate","expandChildren","expandSegment","routes$","processedRoutes$","expandSegmentAgainstRoute","concattedProcessedRoutes$","first$","EmptyError","noLeftoversInUrl","matchSegmentAgainstRoute","expandSegmentAgainstRouteUsingRedirect","expandWildCardWithParamsAgainstRouteUsingRedirect","expandRegularSegmentAgainstRouteUsingRedirect","applyRedirectCommands","lineralizeSegments","newSegments","rawSegmentGroup","consumedSegments_1","rawSlicedSegments_1","childConfig$","routerConfig","childInjector","childConfig","cs","shouldLoad","applyRedirectCreatreUrlTree","newRoot","createSegmentGroup","createQueryParams","redirectToParams","actualParams","updatedSegments","createSegments","redirectToSegments","actualSegments","findPosParam","findOrReturn","redirectToUrlSegment","pos","idx","actualSegments_1","splice","Tree","firstChild","siblings","__extends$1","futureSnapshot","urlSegment","lastPathIndex","_resolve","processSegmentGroup","freeze","rootNode","routeState","inheriteParamsAndData","routeNode","processSegment","config_1","processSegmentAgainstRoute","rawSegment","snapshot_1","rawSlicedSegments","RouterOutletMap","registerOutlet","removeOutlet","UrlHandlingStrategy","DefaultUrlHandlingStrategy","shouldProcessUrl","extract","newUrlPart","wholeUrl","NavigationStart","NavigationEnd","urlAfterRedirects","NavigationCancel","reason","NavigationError","RoutesRecognized","navigations","routerEvents","Subject","navigationId","navigated","resetConfig","currentUrlTree","rawUrlTree","currentRouterState","processNavigations","navigateByUrl","replaceUrl","locationSubscription","Zone","wrap","setTimeout","scheduleNavigation","skipLocationChange","serializeUrl","dispose","unsubscribe","relativeTo","preserveQueryParams","preserveFragment","q","f","extras","navigate","removeEmptyProps","parseUrl","isActive","concatMap","nav","executeScheduledNavigation","promise","catch","rawUrl","prevRawUrl","reject","rej","prevUrl","urlTransition","then","runNavigate","shouldPreventPushState","shouldReplaceUrl","precreatedState","go","resolvePromise","rejectPromise","urlAndSnapshot$","appliedUrl","redirectsApplied$","preActivation","navigationIsSuccessful","preactivationTraverse$","PreActivation","traverse","preactivationCheckGuards","checkGuards","shouldActivate","preactivationResolveData$","resolveData","routerState$","storedState","storedUrl","isCurrentPathEqualTo","replaceState","ActivateRoutes","activate","resetUrlToCurrentUrlTree","ee","CanActivate","CanDeactivate","future","checks","parentOutletMap","futureRoot","currRoot","traverseChildRoutes","checks$","runningChecks$","runCanActivateChild","runCanActivate","s2","runCanDeactivate","runResolve","futureNode","currNode","futurePath","prevChildren","traverseRoutes","deactiveRouteAndItsChildren","isActivated","canActivate","observable","getToken","canActivateChildGuards","reverse","extractCanActivateChild","guards","canActivateChild","canDeactivate","canDeactivate$","resolveNode","resolvedData","resolver","token","futureState","currState","deactivateChildRoutes","activateChildRoutes","deactivateRoutes","activateRoutes","placeComponentIntoOutlet","resolved","locationInjector","ComponentFactoryResolver","locationFactoryResolver","ReflectiveInjector","childOutletMap","deactivate","RouterLink","locationStrategy","set","onClick","decorators","args","ctorParameters","LocationStrategy","propDecorators","routerLink","HostListener","RouterLinkWithHref","subscription","updateTargetUrlAndHref","button","ctrlKey","metaKey","href","prepareExternalUrl","routerLinkOptions","HostBinding","RouterLinkActive","element","renderer","classes","routerLinkActiveOptions","hasActiveLink","ngAfterContentInit","links","linksWithHrefs","setElementClass","isLinkActive","link","some","exportAs","Renderer","ContentChildren","descendants","routerLinkActive","RouterOutlet","activateEvents","deactivateEvents","instance","_activatedRoute","activatedRoute","resolveComponentFactory","inj","fromResolvedProviders","createComponent","changeDetectorRef","detectChanges","ViewContainerRef","Attribute","__platform_browser_private__","PreloadingStrategy","PreloadAllModules","preload","NoPreloading","moduleLoader","preloadingStrategy","processRoutes","preloadConfig","loaded","NgModuleFactoryLoader","Injector","ROUTER_DIRECTIVES","ROUTER_FORROOT_GUARD","ROUTER_PROVIDERS","Location","useClass","Optional","SystemJsNgModuleLoader","ngModule","SkipSelf","PlatformLocation","Inject","APP_BASE_HREF","forChild","__router_private__","144","Subject_1","ObjectUnsubscribedError_1","_value","getValue","_subscribe","subscriber","closed","hasError","thrownError","ObjectUnsubscribedError","145","Subscriber_1","InnerSubscriber","outerValue","outerIndex","_next","notifyNext","_error","notifyError","_complete","notifyComplete","Subscriber","146","Observable_1","Notification","kind","exception","hasValue","observe","observer","complete","do","accept","nextOrObserver","toObservable","throw","empty","createNext","undefinedValueNotification","createError","err","createComplete","completeNotification","57","OuterSubscriber","innerValue","innerIndex","innerSub","destination","149","ScalarObservable_1","EmptyObservable_1","ArrayLikeObservable","arrayLike","scheduler","_isScalar","EmptyObservable","ScalarObservable","dispatch","schedule","86","isScheduler_1","ArrayObservable","array","isScheduler","pop","len","count","87","arg","150","isArray_1","isPromise_1","PromiseObservable_1","IteratorObservable_1","ArrayObservable_1","ArrayLikeObservable_1","iterator_1","observeOn_1","observable_1","isArrayLike","x","FromObservable","ish","$$observable","isPromise","PromiseObservable","$$iterator","IteratorObservable","TypeError","ObserveOnSubscriber","151","getIterator","StringIterator","ArrayIterator","toLength","o","isNaN","numberIsFinite","sign","Math","floor","abs","maxSafeInteger","root_1","isFinite","valueAsNumber","iterator","done","charAt","arr","pow","89","152","FromObservable_1","153","154","operator","CatchOperator","caught","lift","OuterSubscriber_1","subscribeToResult_1","source","CatchSubscriber","isStopped","subscribeToResult","155","mergeAll_1","MergeAllOperator","156","project","resultSelector","mergeMap_1","MergeMapOperator","157","predicate","thisArg","EveryOperator","EverySubscriber","everyValueMatch","158","FilterOperator","FilterSubscriber","159","defaultValue","FirstOperator","EmptyError_1","FirstSubscriber","hasCompleted","_tryPredicate","_emit","_tryResultSelector","_emitFinal","160","LastOperator","LastSubscriber","lastValue","161","MapOperator","MapSubscriber","91","concurrent","Number","POSITIVE_INFINITY","MergeAllSubscriber","buffer","active","shift","92","MergeMapSubscriber","_tryNext","_innerSub","_notifyResultSelector","162","observeOn","delay","ObserveOnOperator","Notification_1","notification","scheduleMessage","ObserveOnMessage","163","accumulator","seed","ReduceOperator","ReduceSubscriber","acc","hasSeed","_tryReduce","59","Symbol","for","Set","Map","getOwnPropertyNames","62","96","167","64","outerSubscriber","InnerSubscriber_1","item"],"mappings":"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","file":"main.3779b4e91740181a7157.bundle.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 322:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t/// <reference path=\"../lib/vs/index.d.ts\" />\r\n\t__export(__webpack_require__(43));\r\n\t__export(__webpack_require__(56));\r\n\n\n/***/ },\n\n/***/ 56:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\tvar Vis = __webpack_require__(83);\r\n\tvar VisNetwork = (function (_super) {\r\n\t    __extends(VisNetwork, _super);\r\n\t    function VisNetwork() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    return VisNetwork;\r\n\t}(Vis.Network));\r\n\texports.VisNetwork = VisNetwork;\r\n\tvar VisNodes = (function (_super) {\r\n\t    __extends(VisNodes, _super);\r\n\t    function VisNodes(data, options) {\r\n\t        _super.call(this, data, options);\r\n\t    }\r\n\t    VisNodes.prototype.getLength = function () {\r\n\t        return this.length;\r\n\t    };\r\n\t    VisNodes.prototype.add = function (data, senderId) {\r\n\t        return _super.prototype.add.call(this, data, senderId);\r\n\t    };\r\n\t    VisNodes.prototype.clear = function (senderId) {\r\n\t        return _super.prototype.clear.call(this, senderId);\r\n\t    };\r\n\t    VisNodes.prototype.distinct = function (field) {\r\n\t        return _super.prototype.distinct.call(this, field);\r\n\t    };\r\n\t    VisNodes.prototype.flush = function () {\r\n\t        _super.prototype.flush.call(this);\r\n\t    };\r\n\t    VisNodes.prototype.forEach = function (callback, options) {\r\n\t        _super.prototype.forEach.call(this, callback, options);\r\n\t    };\r\n\t    VisNodes.prototype.getAll = function (options) {\r\n\t        return _super.prototype.get.call(this, options);\r\n\t    };\r\n\t    VisNodes.prototype.getById = function (id, options) {\r\n\t        return _super.prototype.get.call(this, id, options);\r\n\t    };\r\n\t    VisNodes.prototype.getByIds = function (ids, options) {\r\n\t        return _super.prototype.get.call(this, ids, options);\r\n\t    };\r\n\t    VisNodes.prototype.getDataSet = function () {\r\n\t        return _super.prototype.getDataSet.call(this);\r\n\t    };\r\n\t    VisNodes.prototype.getIds = function (options) {\r\n\t        return _super.prototype.getIds.call(this, options);\r\n\t    };\r\n\t    VisNodes.prototype.map = function (callback, options) {\r\n\t        return _super.prototype.map.call(this, callback, options);\r\n\t    };\r\n\t    VisNodes.prototype.max = function (field) {\r\n\t        return _super.prototype.max.call(this, field);\r\n\t    };\r\n\t    VisNodes.prototype.min = function (field) {\r\n\t        return _super.prototype.min.call(this, field);\r\n\t    };\r\n\t    VisNodes.prototype.on = function (event, callback) {\r\n\t        _super.prototype.on.call(this, event, callback);\r\n\t    };\r\n\t    VisNodes.prototype.off = function (event, callback) {\r\n\t        _super.prototype.off.call(this, event, callback);\r\n\t    };\r\n\t    VisNodes.prototype.removeItems = function (ids, senderId) {\r\n\t        return _super.prototype.remove.call(this, ids, senderId);\r\n\t    };\r\n\t    VisNodes.prototype.setOptions = function (options) {\r\n\t        _super.prototype.setOptions.call(this, options);\r\n\t    };\r\n\t    VisNodes.prototype.update = function (data, senderId) {\r\n\t        return _super.prototype.update.call(this, data, senderId);\r\n\t    };\r\n\t    return VisNodes;\r\n\t}(Vis.DataSet));\r\n\texports.VisNodes = VisNodes;\r\n\tvar VisEdges = (function (_super) {\r\n\t    __extends(VisEdges, _super);\r\n\t    function VisEdges(data, options) {\r\n\t        _super.call(this, data, options);\r\n\t    }\r\n\t    VisEdges.prototype.getLength = function () {\r\n\t        return this.length;\r\n\t    };\r\n\t    VisEdges.prototype.add = function (data, senderId) {\r\n\t        return _super.prototype.add.call(this, data, senderId);\r\n\t    };\r\n\t    VisEdges.prototype.clear = function (senderId) {\r\n\t        return _super.prototype.clear.call(this, senderId);\r\n\t    };\r\n\t    VisEdges.prototype.distinct = function (field) {\r\n\t        return _super.prototype.distinct.call(this, field);\r\n\t    };\r\n\t    VisEdges.prototype.flush = function () {\r\n\t        _super.prototype.flush.call(this);\r\n\t    };\r\n\t    VisEdges.prototype.forEach = function (callback, options) {\r\n\t        _super.prototype.forEach.call(this, callback, options);\r\n\t    };\r\n\t    VisEdges.prototype.getAll = function (options) {\r\n\t        return _super.prototype.get.call(this, options);\r\n\t    };\r\n\t    VisEdges.prototype.getById = function (id, options) {\r\n\t        return _super.prototype.get.call(this, id, options);\r\n\t    };\r\n\t    VisEdges.prototype.getByIds = function (ids, options) {\r\n\t        return _super.prototype.get.call(this, ids, options);\r\n\t    };\r\n\t    VisEdges.prototype.getDataSet = function () {\r\n\t        return _super.prototype.getDataSet.call(this);\r\n\t    };\r\n\t    VisEdges.prototype.getIds = function (options) {\r\n\t        return _super.prototype.getIds.call(this, options);\r\n\t    };\r\n\t    VisEdges.prototype.map = function (callback, options) {\r\n\t        return _super.prototype.map.call(this, callback, options);\r\n\t    };\r\n\t    VisEdges.prototype.max = function (field) {\r\n\t        return _super.prototype.max.call(this, field);\r\n\t    };\r\n\t    VisEdges.prototype.min = function (field) {\r\n\t        return _super.prototype.min.call(this, field);\r\n\t    };\r\n\t    VisEdges.prototype.on = function (event, callback) {\r\n\t        _super.prototype.on.call(this, event, callback);\r\n\t    };\r\n\t    VisEdges.prototype.off = function (event, callback) {\r\n\t        _super.prototype.off.call(this, event, callback);\r\n\t    };\r\n\t    VisEdges.prototype.removeItems = function (ids, senderId) {\r\n\t        return _super.prototype.remove.call(this, ids, senderId);\r\n\t    };\r\n\t    VisEdges.prototype.setOptions = function (options) {\r\n\t        _super.prototype.setOptions.call(this, options);\r\n\t    };\r\n\t    VisEdges.prototype.update = function (data, senderId) {\r\n\t        return _super.prototype.update.call(this, data, senderId);\r\n\t    };\r\n\t    return VisEdges;\r\n\t}(Vis.DataSet));\r\n\texports.VisEdges = VisEdges;\r\n\t__export(__webpack_require__(323));\r\n\t__export(__webpack_require__(134));\r\n\n\n/***/ },\n\n/***/ 323:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar vis_network_service_1 = __webpack_require__(134);\r\n\t/**\r\n\t * Use this directive with a div container to show network data.\r\n\t *\r\n\t * @export\r\n\t * @class VisNetworkDirective\r\n\t * @implements {OnInit}\r\n\t * @implements {OnDestroy}\r\n\t * @implements {OnChanges}\r\n\t */\r\n\tvar VisNetworkDirective = (function () {\r\n\t    /**\r\n\t     * Creates an instance of VisNetworkDirective.\r\n\t     *\r\n\t     * @param {ElementRef} elementRef The HTML element reference.\r\n\t     * @param {VisNetworkService} visNetworkService The VisNetworkService.\r\n\t     *\r\n\t     * @memberOf VisNetworkDirective\r\n\t     */\r\n\t    function VisNetworkDirective(elementRef, visNetworkService) {\r\n\t        this.elementRef = elementRef;\r\n\t        this.visNetworkService = visNetworkService;\r\n\t        /**\r\n\t         * This event will be raised when the network is initialized.\r\n\t         * At this point of time the network is successfully registered\r\n\t         * with the VisNetworkService and you can register to events.\r\n\t         * The event data is the name of the network as a string.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkDirective\r\n\t         */\r\n\t        this.initialized = new core_1.EventEmitter();\r\n\t        this.isInitialized = false;\r\n\t        this.visNetworkContainer = elementRef.nativeElement;\r\n\t    }\r\n\t    /**\r\n\t     * Create the network when at least visNetwork and visNetworkData\r\n\t     * are defined.\r\n\t     *\r\n\t     * @memberOf VisNetworkDirective\r\n\t     */\r\n\t    VisNetworkDirective.prototype.ngOnInit = function () {\r\n\t        if (!this.isInitialized && this.visNetwork && this.visNetworkData) {\r\n\t            this.createNetwork();\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Update the network data or options on reference changes to\r\n\t     * the visNetworkData or visNetworkOptions properties.\r\n\t     *\r\n\t     * @param {{[propName: string]: SimpleChange}} changes\r\n\t     *\r\n\t     * @memberOf VisNetworkDirective\r\n\t     */\r\n\t    VisNetworkDirective.prototype.ngOnChanges = function (changes) {\r\n\t        if (!this.isInitialized && this.visNetwork && this.visNetworkData) {\r\n\t            this.createNetwork();\r\n\t        }\r\n\t        for (var propertyName in changes) {\r\n\t            if (changes.hasOwnProperty(propertyName)) {\r\n\t                var change = changes[propertyName];\r\n\t                if (!change.isFirstChange()) {\r\n\t                    if (propertyName === 'visNetworkData') {\r\n\t                        this.visNetworkService.setData(this.visNetwork, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                    if (propertyName === 'visNetworkOptions') {\r\n\t                        this.visNetworkService.setOptions(this.visNetwork, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Calls the destroy function for this network instance.\r\n\t     *\r\n\t     *\r\n\t     * @memberOf VisNetworkDirective\r\n\t     */\r\n\t    VisNetworkDirective.prototype.ngOnDestroy = function () {\r\n\t        this.isInitialized = false;\r\n\t        this.visNetworkService.destroy(this.visNetwork);\r\n\t    };\r\n\t    VisNetworkDirective.prototype.createNetwork = function () {\r\n\t        this.visNetworkService.create(this.visNetwork, this.visNetworkContainer, this.visNetworkData, this.visNetworkOptions);\r\n\t        this.isInitialized = true;\r\n\t        this.initialized.emit(this.visNetwork);\r\n\t    };\r\n\t    __decorate([\r\n\t        core_1.Input('visNetwork'), \r\n\t        __metadata('design:type', String)\r\n\t    ], VisNetworkDirective.prototype, \"visNetwork\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', Object)\r\n\t    ], VisNetworkDirective.prototype, \"visNetworkData\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', Object)\r\n\t    ], VisNetworkDirective.prototype, \"visNetworkOptions\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Output(), \r\n\t        __metadata('design:type', core_1.EventEmitter)\r\n\t    ], VisNetworkDirective.prototype, \"initialized\", void 0);\r\n\t    VisNetworkDirective = __decorate([\r\n\t        core_1.Directive({\r\n\t            selector: '[visNetwork]',\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [core_1.ElementRef, vis_network_service_1.VisNetworkService])\r\n\t    ], VisNetworkDirective);\r\n\t    return VisNetworkDirective;\r\n\t}());\r\n\texports.VisNetworkDirective = VisNetworkDirective;\r\n\n\n/***/ },\n\n/***/ 134:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar index_1 = __webpack_require__(56);\r\n\t/**\r\n\t * A service to create, manage and control VisNetwork instances.\r\n\t *\r\n\t * @export\r\n\t * @class VisNetworkService\r\n\t */\r\n\tvar VisNetworkService = (function () {\r\n\t    function VisNetworkService() {\r\n\t        /**\r\n\t         * Fired when the user clicks the mouse or taps on a touchscreen device.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.click = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user double clicks the mouse or double taps on a touchscreen device.\r\n\t         * Since a double click is in fact 2 clicks, 2 click events are fired, followed by a double click event.\r\n\t         * If you do not want to use the click events if a double click event is fired,\r\n\t         * just check the time between click events before processing them.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.doubleClick = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user click on the canvas with the right mouse button.\r\n\t         * The right mouse button does not select by default.\r\n\t         * You can use the method getNodeAt to select the node if you want.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.oncontext = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user clicks and holds the mouse or taps and holds on a touchscreen device.\r\n\t         * A click event is also fired in this case.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.hold = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired after drawing on the canvas has been completed.\r\n\t         * Can be used to draw on top of the network.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.release = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the selection has changed by user action.\r\n\t         * This means a node or edge has been selected, added to the selection or deselected.\r\n\t         * All select events are only triggered on click and hold.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.select = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a node has been selected by the user.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.selectNode = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a edge has been selected by the user.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.selectEdge = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a node (or nodes) has (or have) been deselected by the user.\r\n\t         * The previous selection is the list of nodes and edges that were selected before the last user event.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.deselectNode = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a edge (or edges) has (or have) been deselected by the user.\r\n\t         * The previous selection is the list of nodes and edges that were selected before the last user event.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.deselectEdge = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when starting a drag.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.dragStart = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when dragging node(s) or the view.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.dragging = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the drag has finished.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.dragEnd = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over a node.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.hoverNode = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired if the option interaction:{hover:true} is enabled and\r\n\t         * the mouse moved away from a node it was hovering over before.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.blurNode = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over an edge.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.hoverEdge = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired if the option interaction:{hover:true} is enabled and\r\n\t         * the mouse moved away from an edge it was hovering over before.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.blurEdge = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user zooms in or out.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.zoom = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the popup (tooltip) is shown.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.showPopup = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the popup (tooltip) is hidden.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.hidePopup = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when stabilization starts.\r\n\t         * This is also the case when you drag a node and the physics\r\n\t         * simulation restarts to stabilize again.\r\n\t         * Stabilization does not neccesarily imply 'without showing'.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.startStabilizing = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a multiple of the updateInterval number of iterations is reached.\r\n\t         * This only occurs in the 'hidden' stabilization.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.stabilizationProgress = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the 'hidden' stabilization finishes.\r\n\t         * This does not necessarily mean the network is stabilized;\r\n\t         * it could also mean that the amount of iterations defined in the options has been reached.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.stabilizationIterationsDone = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the 'hidden' stabilization finishes.\r\n\t         * This does not necessarily mean the network is stabilized;\r\n\t         * it could also mean that the amount of iterations defined in the options has been reached.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.stabilized = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the size of the canvas has been resized,\r\n\t         * either by a redraw call when the container div has changed in size,\r\n\t         * a setSize() call with new values or a setOptions() with new width and/or height values.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.resize = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired before the redrawing begins.\r\n\t         * The simulation step has completed at this point.\r\n\t         * Can be used to move custom elements before starting drawing the new frame.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.initRedraw = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired after the canvas has been cleared, scaled and translated to\r\n\t         * the viewing position but before all edges and nodes are drawn.\r\n\t         * Can be used to draw behind the network.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.beforeDrawing = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired after drawing on the canvas has been completed.\r\n\t         * Can be used to draw on top of the network.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.afterDrawing = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when an animation is finished.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.animationFinished = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when a user changes any option in the configurator.\r\n\t         * The options object can be used with the setOptions method or stringified using JSON.stringify().\r\n\t         * You do not have to manually put the options into the network: this is done automatically.\r\n\t         * You can use the event to store user options in the database.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisNetworkService\r\n\t         */\r\n\t        this.configChange = new core_1.EventEmitter();\r\n\t        this.networks = {};\r\n\t    }\r\n\t    /**\r\n\t     * Creates a new network instance.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {HTMLElement} container The HTML element that contains the network view.\r\n\t     * @param {VisNetworkData} data The initial network nodes and edges.\r\n\t     * @param {VisNetworkOptions} [options] The network options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when a network with the same name already exists.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.create = function (visNetwork, container, data, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" already exists.\");\r\n\t        }\r\n\t        this.networks[visNetwork] = new index_1.VisNetwork(container, data, options);\r\n\t    };\r\n\t    /**\r\n\t     * Remove the network from the DOM and remove all Hammer bindings and references.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.destroy = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].destroy();\r\n\t            delete this.networks[visNetwork];\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Activates an event.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisNetworkEvents} eventName The event name.\r\n\t     * @param {boolean} preventDefault Stops the default behavior of the event.\r\n\t     * @returns {boolean} Returns true when the event was activated.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.on = function (visNetwork, eventName, preventDefault) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            var that_1 = this;\r\n\t            this.networks[visNetwork].on(eventName, function (params) {\r\n\t                var emitter = that_1[eventName];\r\n\t                if (emitter) {\r\n\t                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\r\n\t                }\r\n\t                if (preventDefault && params.event) {\r\n\t                    params.event.preventDefault();\r\n\t                }\r\n\t            });\r\n\t            return true;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * Deactivates an event.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisNetworkEvents} eventName The event name.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.off = function (visNetwork, eventName) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].off(eventName);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Activates an event listener only once.\r\n\t     * After it has taken place, the event listener will be removed.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisNetworkEvents} eventName The event name.\r\n\t     * @returns {boolean} Returns true when the event was activated.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.once = function (visNetwork, eventName) {\r\n\t        var _this = this;\r\n\t        if (this.networks[visNetwork]) {\r\n\t            var that_2 = this;\r\n\t            this.networks[visNetwork].on(eventName, function (params) {\r\n\t                var emitter = that_2[eventName];\r\n\t                if (emitter) {\r\n\t                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\r\n\t                    _this.off(visNetwork, eventName);\r\n\t                }\r\n\t            });\r\n\t            return true;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * Override all the data in the network.\r\n\t     * If stabilization is enabled in the physics module,\r\n\t     * the network will stabilize again.\r\n\t     * This method is also performed when first initializing the network.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisNetworkData} data The network data.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.setData = function (visNetwork, data) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].setData(data);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set the options.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisNetworkOptions} options The network options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.setOptions = function (visNetwork, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].setOptions(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Selects the nodes corresponding to the id's in the input array.\r\n\t     * This method unselects all other objects before selecting its own objects.\r\n\t     * Does not fire events.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId[]} nodeIds The node ids that should be selected.\r\n\t     * @param {boolean} [highlightEdges] If highlightEdges is true or undefined,\r\n\t     *                                   the neighbouring edges will also be selected.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.selectNodes = function (visNetwork, nodeIds, highlightEdges) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].selectNodes(nodeIds, highlightEdges);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns an object with selected nodes and edges ids.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @returns {{ nodes: VisId[], edges: VisId[] }}\r\n\t     * The selected node and edge ids or undefined when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getSelection = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            return this.networks[visNetwork].getSelection();\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array of selected node ids.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @returns {VisId[]} The selected node ids or undefined when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getSelectedNodes = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            return this.networks[visNetwork].getSelectedNodes();\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array of selected edge ids.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @returns {VisId[]} The selected edge ids or undefined when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getSelectedEdges = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            return this.networks[visNetwork].getSelectedEdges();\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Unselect all objects.\r\n\t     * Does not fire events.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.unselectAll = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].unselectAll();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Zooms out so all nodes fit on the canvas.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisFitOptions} [options] Options to customize.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.fit = function (visNetwork, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].fit(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Redraw the network.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.redraw = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].redraw();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Programatically enable the edit mode.\r\n\t     * Similar effect to pressing the edit button.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.enableEditMode = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].enableEditMode();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Go into addEdge mode.\r\n\t     * The explaination from addNodeMode applies here as well.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.addEdgeMode = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].addEdgeMode();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Programatically disable the edit mode.\r\n\t     * Similar effect to pressing the close icon\r\n\t     * (small cross in the corner of the toolbar).\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.disableEditMode = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].disableEditMode();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Delete selected.\r\n\t     * Having edit mode or manipulation enabled is not required.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.deleteSelected = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].deleteSelected();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Makes a cluster.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisClusterOptions} [options] The joinCondition function is presented with all nodes.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.cluster = function (visNetwork, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].cluster(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * This method looks at the provided node and makes a cluster of it and all it's connected nodes.\r\n\t     * The behaviour can be customized by proving the options object.\r\n\t     * All options of this object are explained below.\r\n\t     * The joinCondition is only presented with the connected nodes.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId} nodeId the id of the node\r\n\t     * @param {VisClusterOptions} [options] the cluster options\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.clusterByConnection = function (visNetwork, nodeId, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].clusterByConnection(nodeId, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * This method checks all nodes in the network and those with a equal or higher\r\n\t     * amount of edges than specified with the hubsize qualify.\r\n\t     * If a hubsize is not defined, the hubsize will be determined as the average\r\n\t     * value plus two standard deviations.\r\n\t     * For all qualifying nodes, clusterByConnection is performed on each of them.\r\n\t     * The options object is described for clusterByConnection and does the same here.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {number} [hubsize] optional hubsize\r\n\t     * @param {VisClusterOptions} [options] optional cluster options\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.clusterByHubsize = function (visNetwork, hubsize, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].clusterByHubsize(hubsize, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * This method will cluster all nodes with 1 edge with their respective connected node.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisClusterOptions} [options] optional cluster options\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.clusterOutliers = function (visNetwork, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].clusterOutliers(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Nodes can be in clusters.\r\n\t     * Clusters can also be in clusters.\r\n\t     * This function returns an array of nodeIds showing where the node is.\r\n\t     *\r\n\t     * Example:\r\n\t     * cluster 'A' contains cluster 'B', cluster 'B' contains cluster 'C',\r\n\t     * cluster 'C' contains node 'fred'.\r\n\t     *\r\n\t     * network.clustering.findNode('fred') will return ['A','B','C','fred'].\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId} nodeId the node id.\r\n\t     * @returns {VisId[]} an array of nodeIds showing where the node is\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.findNode = function (visNetwork, nodeId) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            return this.networks[visNetwork].findNode(nodeId);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Similar to findNode in that it returns all the edge ids that were\r\n\t     * created from the provided edge during clustering.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId} baseEdgeId the base edge id\r\n\t     * @returns {VisId[]} an array of edgeIds\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getClusteredEdges = function (visNetwork, baseEdgeId) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            return this.networks[visNetwork].getClusteredEdges(baseEdgeId);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * When a clusteredEdgeId is available, this method will return the original\r\n\t     * baseEdgeId provided in data.edges ie.\r\n\t     * After clustering the 'SelectEdge' event is fired but provides only the clustered edge.\r\n\t     * This method can then be used to return the baseEdgeId.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId} clusteredEdgeId\r\n\t     * @returns {VisId}\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     *\r\n\t     */\r\n\t    VisNetworkService.prototype.getBaseEdge = function (visNetwork, clusteredEdgeId) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            return this.networks[visNetwork].getBaseEdge(clusteredEdgeId);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Visible edges between clustered nodes are not the same edge as the ones provided\r\n\t     * in data.edges passed on network creation. With each layer of clustering, copies of\r\n\t     * the edges between clusters are created and the previous edges are hidden,\r\n\t     * until the cluster is opened. This method takes an edgeId (ie. a base edgeId from data.edges)\r\n\t     * and applys the options to it and any edges that were created from it while clustering.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId} startEdgeId\r\n\t     * @param {VisEdgeOptions} [options]\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     *\r\n\t     */\r\n\t    VisNetworkService.prototype.updateEdge = function (visNetwork, startEdgeId, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].updateEdge(startEdgeId, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Clustered Nodes when created are not contained in the original data.nodes\r\n\t     * passed on network creation. This method updates the cluster node.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId} clusteredNodeId\r\n\t     * @param {VisNodeOptions} options\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     *\r\n\t     */\r\n\t    VisNetworkService.prototype.updateClusteredNode = function (visNetwork, clusteredNodeId, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].updateClusteredNode(clusteredNodeId, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array of all nodeIds of the nodes that\r\n\t     * would be released if you open the cluster.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId} clusterNodeId the id of the cluster node\r\n\t     * @returns {VisId[]}\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getNodesInCluster = function (visNetwork, clusterNodeId) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            return this.networks[visNetwork].getNodesInCluster(clusterNodeId);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Opens the cluster, releases the contained nodes and edges,\r\n\t     * removing the cluster node and cluster edges.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId} nodeId The node id that represents the cluster.\r\n\t     * @param {VisOpenClusterOptions} [options] Cluster options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when the network does not exist.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.openCluster = function (visNetwork, nodeId, options) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            this.networks[visNetwork].openCluster(nodeId, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(\"Network with id \" + visNetwork + \" not found.\");\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if the node whose ID has been supplied is a cluster.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @param {VisId} nodeId The associated node id.\r\n\t     * @returns {boolean} True if the node whose ID has been supplied is a cluster.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.isCluster = function (visNetwork, nodeId) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            return this.networks[visNetwork].isCluster(nodeId);\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * If you like the layout of your network and would like it to start in the same way next time,\r\n\t     * ask for the seed using this method and put it in the layout.randomSeed option.\r\n\t     *\r\n\t     * @param {string} visNetwork The network name/identifier.\r\n\t     * @returns {number} The seed of the current network or -1 when the network is not defined.\r\n\t     *\r\n\t     * @memberOf VisNetworkService\r\n\t     */\r\n\t    VisNetworkService.prototype.getSeed = function (visNetwork) {\r\n\t        if (this.networks[visNetwork]) {\r\n\t            return this.networks[visNetwork].getSeed();\r\n\t        }\r\n\t        return -1;\r\n\t    };\r\n\t    VisNetworkService = __decorate([\r\n\t        core_1.Injectable(), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], VisNetworkService);\r\n\t    return VisNetworkService;\r\n\t}());\r\n\texports.VisNetworkService = VisNetworkService;\r\n\n\n/***/ },\n\n/***/ 43:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\tvar Vis = __webpack_require__(83);\r\n\tvar VisTimelineItems = (function (_super) {\r\n\t    __extends(VisTimelineItems, _super);\r\n\t    function VisTimelineItems(data, options) {\r\n\t        _super.call(this, data, options);\r\n\t    }\r\n\t    VisTimelineItems.prototype.getLength = function () {\r\n\t        return this.length;\r\n\t    };\r\n\t    VisTimelineItems.prototype.add = function (data, senderId) {\r\n\t        return _super.prototype.add.call(this, data, senderId);\r\n\t    };\r\n\t    VisTimelineItems.prototype.clear = function (senderId) {\r\n\t        return _super.prototype.clear.call(this, senderId);\r\n\t    };\r\n\t    VisTimelineItems.prototype.distinct = function (field) {\r\n\t        return _super.prototype.distinct.call(this, field);\r\n\t    };\r\n\t    VisTimelineItems.prototype.flush = function () {\r\n\t        _super.prototype.flush.call(this);\r\n\t    };\r\n\t    VisTimelineItems.prototype.forEach = function (callback, options) {\r\n\t        _super.prototype.forEach.call(this, callback, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getAll = function (options) {\r\n\t        return _super.prototype.get.call(this, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getById = function (id, options) {\r\n\t        return _super.prototype.get.call(this, id, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getByIds = function (ids, options) {\r\n\t        return _super.prototype.get.call(this, ids, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getDataSet = function () {\r\n\t        return _super.prototype.getDataSet.call(this);\r\n\t    };\r\n\t    VisTimelineItems.prototype.getIds = function (options) {\r\n\t        return _super.prototype.getIds.call(this, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.map = function (callback, options) {\r\n\t        return _super.prototype.map.call(this, callback, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.max = function (field) {\r\n\t        return _super.prototype.max.call(this, field);\r\n\t    };\r\n\t    VisTimelineItems.prototype.min = function (field) {\r\n\t        return _super.prototype.min.call(this, field);\r\n\t    };\r\n\t    VisTimelineItems.prototype.on = function (event, callback) {\r\n\t        _super.prototype.on.call(this, event, callback);\r\n\t    };\r\n\t    VisTimelineItems.prototype.off = function (event, callback) {\r\n\t        _super.prototype.off.call(this, event, callback);\r\n\t    };\r\n\t    VisTimelineItems.prototype.removeItems = function (ids, senderId) {\r\n\t        return _super.prototype.remove.call(this, ids, senderId);\r\n\t    };\r\n\t    VisTimelineItems.prototype.setOptions = function (options) {\r\n\t        _super.prototype.setOptions.call(this, options);\r\n\t    };\r\n\t    VisTimelineItems.prototype.update = function (data, senderId) {\r\n\t        return _super.prototype.update.call(this, data, senderId);\r\n\t    };\r\n\t    return VisTimelineItems;\r\n\t}(Vis.DataSet));\r\n\texports.VisTimelineItems = VisTimelineItems;\r\n\tvar VisTimelineGroups = (function (_super) {\r\n\t    __extends(VisTimelineGroups, _super);\r\n\t    function VisTimelineGroups(data, options) {\r\n\t        _super.call(this, data, options);\r\n\t    }\r\n\t    VisTimelineGroups.prototype.getLength = function () {\r\n\t        return this.length;\r\n\t    };\r\n\t    VisTimelineGroups.prototype.add = function (data, senderId) {\r\n\t        return _super.prototype.add.call(this, data, senderId);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.clear = function (senderId) {\r\n\t        return _super.prototype.clear.call(this, senderId);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.distinct = function (field) {\r\n\t        return _super.prototype.distinct.call(this, field);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.flush = function () {\r\n\t        _super.prototype.flush.call(this);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.forEach = function (callback, options) {\r\n\t        _super.prototype.forEach.call(this, callback, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getAll = function (options) {\r\n\t        return _super.prototype.get.call(this, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getById = function (id, options) {\r\n\t        return _super.prototype.get.call(this, id, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getByIds = function (ids, options) {\r\n\t        return _super.prototype.get.call(this, ids, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getDataSet = function () {\r\n\t        return _super.prototype.getDataSet.call(this);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.getIds = function (options) {\r\n\t        return _super.prototype.getIds.call(this, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.map = function (callback, options) {\r\n\t        return _super.prototype.map.call(this, callback, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.max = function (field) {\r\n\t        return _super.prototype.max.call(this, field);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.min = function (field) {\r\n\t        return _super.prototype.min.call(this, field);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.on = function (event, callback) {\r\n\t        _super.prototype.on.call(this, event, callback);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.off = function (event, callback) {\r\n\t        _super.prototype.off.call(this, event, callback);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.removeItems = function (ids, senderId) {\r\n\t        return _super.prototype.remove.call(this, ids, senderId);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.setOptions = function (options) {\r\n\t        _super.prototype.setOptions.call(this, options);\r\n\t    };\r\n\t    VisTimelineGroups.prototype.update = function (data, senderId) {\r\n\t        return _super.prototype.update.call(this, data, senderId);\r\n\t    };\r\n\t    return VisTimelineGroups;\r\n\t}(Vis.DataSet));\r\n\texports.VisTimelineGroups = VisTimelineGroups;\r\n\tvar VisTimeline = (function (_super) {\r\n\t    __extends(VisTimeline, _super);\r\n\t    function VisTimeline() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    return VisTimeline;\r\n\t}(Vis.Timeline));\r\n\texports.VisTimeline = VisTimeline;\r\n\t__export(__webpack_require__(135));\r\n\t__export(__webpack_require__(324));\r\n\n\n/***/ },\n\n/***/ 324:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar vis_timeline_service_1 = __webpack_require__(135);\r\n\tvar index_1 = __webpack_require__(43);\r\n\t/**\r\n\t * Use this directive with a div container to show timeline data.\r\n\t *\r\n\t * @export\r\n\t * @class VisTimelineDirective\r\n\t * @implements {OnInit}\r\n\t * @implements {OnDestroy}\r\n\t * @implements {OnChanges}\r\n\t */\r\n\tvar VisTimelineDirective = (function () {\r\n\t    /**\r\n\t     * Creates an instance of VisTimelineDirective.\r\n\t     *\r\n\t     * @param {ElementRef} elementRef The HTML element reference.\r\n\t     * @param {VisTimelineService} visTimelineService The VisTimelineService.\r\n\t     *\r\n\t     * @memberOf VisTimelineDirective\r\n\t     */\r\n\t    function VisTimelineDirective(elementRef, visTimelineService) {\r\n\t        this.elementRef = elementRef;\r\n\t        this.visTimelineService = visTimelineService;\r\n\t        /**\r\n\t         * This event will be raised when the timline is initialized.\r\n\t         * At this point of time the timeline is successfully registered\r\n\t         * with the VisNetworkService and you can register to events.\r\n\t         * The event data is the name of the timeline as a string.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineDirective\r\n\t         */\r\n\t        this.initialized = new core_1.EventEmitter();\r\n\t        this.isInitialized = false;\r\n\t        this.visTimelineContainer = elementRef.nativeElement;\r\n\t    }\r\n\t    /**\r\n\t     * Create the timeline when at least visNetwork and visNetworkData\r\n\t     * are defined.\r\n\t     *\r\n\t     * @memberOf VisTimelineDirective\r\n\t     */\r\n\t    VisTimelineDirective.prototype.ngOnInit = function () {\r\n\t        if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {\r\n\t            this.createTimeline();\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Update the timeline data, groups or options on reference changes to\r\n\t     * the visTimelineItems, visTimelineGroups or visTimelineOptions properties.\r\n\t     *\r\n\t     * @param {{[propName: string]: SimpleChange}} changes\r\n\t     *\r\n\t     * @memberOf VisTimelineDirective\r\n\t     */\r\n\t    VisTimelineDirective.prototype.ngOnChanges = function (changes) {\r\n\t        if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {\r\n\t            this.createTimeline();\r\n\t        }\r\n\t        for (var propertyName in changes) {\r\n\t            if (changes.hasOwnProperty(propertyName)) {\r\n\t                var change = changes[propertyName];\r\n\t                if (!change.isFirstChange()) {\r\n\t                    if (propertyName === 'visTimelineItems') {\r\n\t                        this.visTimelineService.setItems(this.visTimeline, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                    if (propertyName === 'visTimelineOptions') {\r\n\t                        this.visTimelineService.setOptions(this.visTimeline, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                    if (propertyName === 'visTimelineGroups') {\r\n\t                        this.visTimelineService.setGroups(this.visTimeline, changes[propertyName].currentValue);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Calls the destroy function for this timeline instance.\r\n\t     *\r\n\t     *\r\n\t     * @memberOf VisTimelineDirective\r\n\t     */\r\n\t    VisTimelineDirective.prototype.ngOnDestroy = function () {\r\n\t        this.isInitialized = false;\r\n\t        this.visTimelineService.destroy(this.visTimeline);\r\n\t    };\r\n\t    VisTimelineDirective.prototype.createTimeline = function () {\r\n\t        if (this.visTimelineGroups) {\r\n\t            this.visTimelineService.createWithItemsAndGroups(this.visTimeline, this.visTimelineContainer, this.visTimelineItems, this.visTimelineGroups, this.visTimelineOptions);\r\n\t        }\r\n\t        else {\r\n\t            this.visTimelineService.createWithItems(this.visTimeline, this.visTimelineContainer, this.visTimelineItems, this.visTimelineOptions);\r\n\t        }\r\n\t        this.isInitialized = true;\r\n\t        this.initialized.emit(this.visTimeline);\r\n\t    };\r\n\t    __decorate([\r\n\t        core_1.Input('visTimeline'), \r\n\t        __metadata('design:type', String)\r\n\t    ], VisTimelineDirective.prototype, \"visTimeline\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', index_1.VisTimelineItems)\r\n\t    ], VisTimelineDirective.prototype, \"visTimelineItems\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', index_1.VisTimelineGroups)\r\n\t    ], VisTimelineDirective.prototype, \"visTimelineGroups\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Input(), \r\n\t        __metadata('design:type', Object)\r\n\t    ], VisTimelineDirective.prototype, \"visTimelineOptions\", void 0);\r\n\t    __decorate([\r\n\t        core_1.Output(), \r\n\t        __metadata('design:type', core_1.EventEmitter)\r\n\t    ], VisTimelineDirective.prototype, \"initialized\", void 0);\r\n\t    VisTimelineDirective = __decorate([\r\n\t        core_1.Directive({\r\n\t            selector: '[visTimeline]',\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [core_1.ElementRef, vis_timeline_service_1.VisTimelineService])\r\n\t    ], VisTimelineDirective);\r\n\t    return VisTimelineDirective;\r\n\t}());\r\n\texports.VisTimelineDirective = VisTimelineDirective;\r\n\n\n/***/ },\n\n/***/ 135:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar index_1 = __webpack_require__(43);\r\n\t/**\r\n\t * A service to create, manage and control VisTimeline instances.\r\n\t *\r\n\t * @export\r\n\t * @class VisTimelineService\r\n\t */\r\n\tvar VisTimelineService = (function () {\r\n\t    function VisTimelineService() {\r\n\t        /**\r\n\t         * Fired when the current time bar redraws.\r\n\t         * The rate depends on the zoom level.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.currentTimeTick = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when clicked inside the Timeline.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.click = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when right-clicked inside the Timeline.\r\n\t         * Note that in order to prevent the context menu from showing up,\r\n\t         * default behavior of the event must be stopped.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.contextmenu = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when double clicked inside the Timeline.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.doubleClick = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * \tFired after the dragging of a group is finished.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.groupDragged = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired once after each graph redraw.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.changed = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired repeatedly when the timeline window is being changed.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.rangechange = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired once after the timeline window has been changed.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.rangechanged = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired after the user selects or deselects items by tapping or holding them.\r\n\t         * When a use taps an already selected item, the select event is fired again.\r\n\t         * Not fired when the method setSelectionis executed.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.select = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user moves the mouse over an item.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.itemover = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired when the user moves the mouse out of an item.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.itemout = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired repeatedly when the user is dragging the custom time bar.\r\n\t         * Only available when the custom time bar is enabled.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.timechange = new core_1.EventEmitter();\r\n\t        /**\r\n\t         * Fired once after the user has dragged the custom time bar.\r\n\t         * Only available when the custom time bar is enabled.\r\n\t         *\r\n\t         * @type {EventEmitter<any>}\r\n\t         * @memberOf VisTimelineService\r\n\t         */\r\n\t        this.timechanged = new core_1.EventEmitter();\r\n\t        this.timelines = {};\r\n\t    }\r\n\t    /**\r\n\t     * Creates a new timeline instance.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {HTMLElement} container The HTML element that contains the timeline view.\r\n\t     * @param {VisTimelineItems} items The initial timeline items.\r\n\t     * @param {VisTimelineOptions} [options] The timeline options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline already exists.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.createWithItems = function (visTimeline, container, items, options) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            throw new Error(this.alreadyExistsError(visTimeline));\r\n\t        }\r\n\t        this.timelines[visTimeline] = new index_1.VisTimeline(container, items, options);\r\n\t    };\r\n\t    /**\r\n\t     * Creates a new timeline instance.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {HTMLElement} container The HTML element that contains the timeline view.\r\n\t     * @param {VisTimelineItems} items The initial timeline items.\r\n\t     * @param {VisTimelineGroups} groups The initial timeline groups.\r\n\t     * @param {VisTimelineOptions} [options] The timeline options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline already exists.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.createWithItemsAndGroups = function (visTimeline, container, items, groups, options) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            throw new Error(this.alreadyExistsError(visTimeline));\r\n\t        }\r\n\t        this.timelines[visTimeline] = new index_1.VisTimeline(container, items, groups, options);\r\n\t    };\r\n\t    /**\r\n\t     * Add new vertical bar representing a custom time that can be dragged by the user.\r\n\t     * The id is added as CSS class name of the custom time bar,\r\n\t     * allowing to style multiple time bars differently.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} time Parameter time can be a Date, Number, or String, and is new Date() by default.\r\n\t     * @param {VisId} [id] Parameter id can be Number or String and is undefined by default.\r\n\t     * @returns {VisId} The method returns id of the created bar.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.addCustomTime = function (visTimeline, time, id) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            return this.timelines[visTimeline].addCustomTime(time, id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Adjust the visible window such that it fits all items.\r\n\t     * See also function focus(id).\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineFitOptions} [options] Optional options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.fit = function (visTimeline, options) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].fit(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Adjust the visible window such that the selected item is centered on screen.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId} id The id of the item.\r\n\t     * @param {VisTimelineFitOptions} [options] Options options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.focusOnId = function (visTimeline, id, options) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].focus(id, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Adjust the visible window such that the selected items are centered on screen.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId[]} ids The item ids.\r\n\t     * @param {VisTimelineFitOptions} [options] Optional options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.focusOnIds = function (visTimeline, ids, options) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].focus(ids, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get the current time.\r\n\t     * Only applicable when option showCurrentTime is true.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {Date} The current time.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getCurrentTime = function (visTimeline) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            return this.timelines[visTimeline].getCurrentTime();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Retrieve the custom time from the custom time bar with given id.\r\n\t     * Id is undefined by default.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId} [id] The time bar id.\r\n\t     * @returns {Date} The custom time.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getCustomTime = function (visTimeline, id) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            return this.timelines[visTimeline].getCustomTime(id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns an Object with relevant properties from an event.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {Event} event The event.\r\n\t     * @returns {VisTimelineEventPropertiesResult} Properties of an event\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getEventProperties = function (visTimeline, event) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            return this.timelines[visTimeline].getEventProperties(event);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get the range of all the items as an object containing min: Date and max: Date.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {{ min: Date, max: Date }} The min and max dates.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getItemRange = function (visTimeline) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            return this.timelines[visTimeline].getItemRange();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get an array with the ids of the currently selected items.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {VisId[]} The currently selected items.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getSelection = function (visTimeline) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            return this.timelines[visTimeline].getSelection();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get an array with the ids of the currently visible items.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {VisId[]} The currently visible items.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getVisibleItems = function (visTimeline) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            return this.timelines[visTimeline].getVisibleItems();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Get the current visible window.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @returns {{ start: Date, end: Date }} Returns an object with properties start: Date and end: Date.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.getWindow = function (visTimeline) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            return this.timelines[visTimeline].getWindow();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * \tMove the window such that given time is centered on screen.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} time Parameter time can be a Date, Number, or String.\r\n\t     * @param {VisTimelineFitOptions} [options] Optional options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.moveTo = function (visTimeline, time, options) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].moveTo(time, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Force a redraw of the Timeline.\r\n\t     * The size of all items will be recalculated.\r\n\t     * Can be useful to manually redraw when option autoResize=false and the window has been resized,\r\n\t     * or when the items CSS has been changed.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.redraw = function (visTimeline) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].redraw();\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Remove vertical bars previously added to the timeline via addCustomTime method.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId} id Parameter id is the ID of the custom vertical bar returned by addCustomTime method.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.removeCustomTime = function (visTimeline, id) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].removeCustomTime(id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set a current time.\r\n\t     * This can be used for example to ensure that a client's time is synchronized\r\n\t     * with a shared server time.\r\n\t     * Only applicable when option showCurrentTime is true.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} time time can be a Date object, numeric timestamp, or ISO date string.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setCurrentTime = function (visTimeline, time) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setCurrentTime(time);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * \tAdjust the time of a custom time bar.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} time Parameter time can be a Date object, numeric timestamp, or ISO date string.\r\n\t     * @param {VisId} [id] Parameter id is the id of the custom time bar, and is undefined by default.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setCustomTime = function (visTimeline, time, id) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setCustomTime(time, id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Adjust the title attribute of a custom time bar.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {string} title Parameter title is the string to be set as title.\r\n\t     *                       Use empty string to hide the title completely.\r\n\t     * @param {VisId} [id] Parameter id is the id of the custom time bar, and is undefined by default.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setCustomTimeTitle = function (visTimeline, title, id) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setCustomTimeTitle(title, id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set both groups and items at once.\r\n\t     * Both properties are optional.\r\n\t     * This is a convenience method for individually calling both setItems(items) and setGroups(groups).\r\n\t     * Both items and groups can be an Array with Objects, a DataSet (offering 2 way data binding),\r\n\t     * or a DataView (offering 1 way data binding).\r\n\t     * For each of the groups, the items of the timeline are filtered on the property group,\r\n\t     * which must correspond with the id of the group.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {{ groups?: VisTimelineGroups; items?: VisTimelineItems }} data The new timline data.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setData = function (visTimeline, data) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setData(data);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set a data set with groups for the Timeline.\r\n\t     * For each of the groups, the items of the timeline are filtered on the property group,\r\n\t     * which must correspond with the id of the group.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineGroups} groups a DataSet (offering 2 way data binding)\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setGroups = function (visTimeline, groups) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setGroups(groups);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set a data set with items for the Timeline.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineItems} items can be an Array with Objects, a DataSet (offering 2 way data binding)\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setItems = function (visTimeline, items) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setItems(items);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set or update options.\r\n\t     * It is possible to change any option of the timeline at any time.\r\n\t     * You can for example switch orientation on the fly.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineOptions} options The new options of the timeline.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setOptions = function (visTimeline, options) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setOptions(options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Select one item by its id.#\r\n\t     * The currently selected items will be unselected.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId} id The id of the item that should be selected.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setSelectionToId = function (visTimeline, id) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setSelection(id);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Select multiple items by their id.\r\n\t     * The currently selected items will be unselected.\r\n\t     * To unselect all selected items, call `setSelection([])`.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisId[]} ids The ids of the irems that should be selected.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setSelectionToIds = function (visTimeline, ids) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setSelection(ids);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Set the current visible window.\r\n\t     *\r\n\t     * If the parameter value of start or end is null, the parameter will be left unchanged.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisDate} start The parameters start can be a Date, Number, or String.\r\n\t     * @param {VisDate} end The parameters end can be a Date, Number, or String.\r\n\t     * @param {VisTimelineFitOptions} [options] Optional options.\r\n\t     *\r\n\t     * @throws {Error} Thrown when timeline does not exist.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.setWindow = function (visTimeline, start, end, options) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].setWindow(start, end, options);\r\n\t        }\r\n\t        else {\r\n\t            throw new Error(this.doesNotExistError(visTimeline));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Destroy the Timeline.\r\n\t     * The timeline is removed from memory.\r\n\t     * All DOM elements and event listeners are cleaned up.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.destroy = function (visTimeline) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].destroy();\r\n\t            delete this.timelines[visTimeline];\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Activates an event.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineEvents} eventName The event name.\r\n\t     * @param {boolean} preventDefault Stops the default behavior of the event.\r\n\t     * @returns {boolean} Returns true when the event was activated.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.on = function (visTimeline, eventName, preventDefault) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            var that_1 = this;\r\n\t            this.timelines[visTimeline].on(eventName, function (params) {\r\n\t                var emitter = that_1[eventName];\r\n\t                if (emitter) {\r\n\t                    emitter.emit(params ? [visTimeline].concat(params) : visTimeline);\r\n\t                }\r\n\t                if (preventDefault && params.event) {\r\n\t                    params.event.preventDefault();\r\n\t                }\r\n\t            });\r\n\t            return true;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * Deactivates an event.\r\n\t     *\r\n\t     * @param {string} visTimeline The timeline name/identifier.\r\n\t     * @param {VisTimelineEvents} eventName The event name.\r\n\t     *\r\n\t     * @memberOf VisTimelineService\r\n\t     */\r\n\t    VisTimelineService.prototype.off = function (visTimeline, eventName) {\r\n\t        if (this.timelines[visTimeline]) {\r\n\t            this.timelines[visTimeline].off(eventName, undefined);\r\n\t        }\r\n\t    };\r\n\t    VisTimelineService.prototype.doesNotExistError = function (visTimeline) {\r\n\t        return \"Timeline with id \" + visTimeline + \" does not exist.\";\r\n\t    };\r\n\t    VisTimelineService.prototype.alreadyExistsError = function (visTimeline) {\r\n\t        return \"Timeline with id \" + visTimeline + \" already exists.\";\r\n\t    };\r\n\t    VisTimelineService = __decorate([\r\n\t        core_1.Injectable(), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], VisTimelineService);\r\n\t    return VisTimelineService;\r\n\t}());\r\n\texports.VisTimelineService = VisTimelineService;\r\n\n\n/***/ },\n\n/***/ 138:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"container\\\">\\r\\n  <div class=\\\"header clearfix\\\">\\r\\n    <nav>\\r\\n      <ul class=\\\"nav nav-pills pull-right\\\">\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/home\\\">Home</a></li>\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/network\\\">Network</a></li>\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/timeline\\\">Timeline</a></li>\\r\\n      </ul>\\r\\n    </nav>\\r\\n    <h3 class=\\\"text-muted\\\">ng2-vis - an angular2 vis.js wrapper</h3>\\r\\n  </div>\\r\\n  <router-outlet></router-outlet>\\r\\n</div>\\r\\n\"\n\n/***/ },\n\n/***/ 325:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar DemoComponent = (function () {\r\n\t    function DemoComponent() {\r\n\t    }\r\n\t    DemoComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'example-app',\r\n\t            template: __webpack_require__(138),\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], DemoComponent);\r\n\t    return DemoComponent;\r\n\t}());\r\n\texports.DemoComponent = DemoComponent;\r\n\n\n/***/ },\n\n/***/ 326:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar forms_1 = __webpack_require__(84);\r\n\tvar platform_browser_1 = __webpack_require__(45);\r\n\tvar common_1 = __webpack_require__(44);\r\n\tvar router_1 = __webpack_require__(137);\r\n\tvar network_example_component_1 = __webpack_require__(328);\r\n\tvar timeline_example_component_1 = __webpack_require__(329);\r\n\tvar ng2_vis_1 = __webpack_require__(330);\r\n\tvar demo_component_1 = __webpack_require__(325);\r\n\tvar home_component_1 = __webpack_require__(327);\r\n\tvar VisDemoModule = (function () {\r\n\t    function VisDemoModule() {\r\n\t    }\r\n\t    VisDemoModule = __decorate([\r\n\t        core_1.NgModule({\r\n\t            declarations: [\r\n\t                demo_component_1.DemoComponent,\r\n\t                home_component_1.HomeComponent,\r\n\t                network_example_component_1.VisNetworkExampleComponent,\r\n\t                timeline_example_component_1.VisTimelineExampleComponent\r\n\t            ],\r\n\t            imports: [\r\n\t                platform_browser_1.BrowserModule,\r\n\t                forms_1.FormsModule,\r\n\t                ng2_vis_1.VisModule,\r\n\t                common_1.CommonModule,\r\n\t                router_1.RouterModule.forRoot([\r\n\t                    { path: 'timeline', component: timeline_example_component_1.VisTimelineExampleComponent },\r\n\t                    { path: '', redirectTo: '/home', pathMatch: 'full' },\r\n\t                    { path: 'home', component: home_component_1.HomeComponent },\r\n\t                    { path: 'network', component: network_example_component_1.VisNetworkExampleComponent },\r\n\t                    { path: '**', component: home_component_1.HomeComponent }\r\n\t                ])\r\n\t            ],\r\n\t            providers: [],\r\n\t            bootstrap: [demo_component_1.DemoComponent]\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], VisDemoModule);\r\n\t    return VisDemoModule;\r\n\t}());\r\n\texports.VisDemoModule = VisDemoModule;\r\n\n\n/***/ },\n\n/***/ 139:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"jumbotron\\\">\\r\\n  <h1>ng2-vis</h1>\\r\\n  <p class=\\\"lead\\\"><strong>Note:</strong> these examples mimic the ones for <code>vis</code>, but using <code>ng2-vis</code>.</p>\\r\\n  <p>\\r\\n    <a class=\\\"btn btn-lg btn-success\\\" href=\\\"https://github.com/seveves/ng2-vis\\\" role=\\\"button\\\">Get it on GitHub</a>\\r\\n    <a class=\\\"btn btn-lg btn-success\\\" href=\\\"http://visjs.org\\\" role=\\\"button\\\">Check out visjs.org</a>\\r\\n  </p>\\r\\n</div>\\r\\n<h2>Examples</h2>\\r\\n<div class=\\\"row\\\">\\r\\n  <div class=\\\"col-sm-6 col-md-4\\\">\\r\\n    <div class=\\\"thumbnail\\\">\\r\\n      <img src=\\\"http://visjs.org/images/network.png\\\" alt=\\\"Network Examples\\\">\\r\\n      <div class=\\\"caption\\\">\\r\\n        <h3>Network</h3>\\r\\n        <p>Display dynamic, automatically organised, customizable network views.</p>\\r\\n        <p><a routerLink=\\\"/network\\\" class=\\\"btn btn-primary\\\" role=\\\"button\\\">Examples</a></p>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n  <div class=\\\"col-sm-6 col-md-4\\\">\\r\\n    <div class=\\\"thumbnail\\\">\\r\\n      <img src=\\\"http://visjs.org/images/timeline.png\\\" alt=\\\"Timeline Examples\\\">\\r\\n      <div class=\\\"caption\\\">\\r\\n        <h3>Timeline</h3>\\r\\n        <p>Create a fully customizable, interactive timeline with items and ranges.</p>\\r\\n        <p><a routerLink=\\\"/timeline\\\" class=\\\"btn btn-primary\\\" role=\\\"button\\\">Examples</a></p>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n</div>\"\n\n/***/ },\n\n/***/ 327:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar HomeComponent = (function () {\r\n\t    function HomeComponent() {\r\n\t    }\r\n\t    HomeComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'home-example',\r\n\t            template: __webpack_require__(139),\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], HomeComponent);\r\n\t    return HomeComponent;\r\n\t}());\r\n\texports.HomeComponent = HomeComponent;\r\n\n\n/***/ },\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar platform_browser_dynamic_1 = __webpack_require__(85);\r\n\tvar demo_module_1 = __webpack_require__(326);\r\n\tplatform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(demo_module_1.VisDemoModule);\r\n\n\n/***/ },\n\n/***/ 140:\n/***/ function(module, exports) {\n\n\tmodule.exports = \".network-canvas {\\r\\n    width: 100%;\\r\\n    height: 400px;\\r\\n    border: 1px solid lightgray;\\r\\n}\"\n\n/***/ },\n\n/***/ 141:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<h2>Network</h2>\\r\\n<h3>Basic usage</h3>\\r\\n<div class=\\\"network-canvas\\\" [visNetwork]=\\\"visNetwork\\\" [visNetworkData]=\\\"visNetworkData\\\" [visNetworkOptions]=\\\"visNetworkOptions\\\" (initialized)=\\\"networkInitialized()\\\"></div>\\r\\n<button type=\\\"button\\\" class=\\\"btn btn-default\\\" (click)=\\\"addNode()\\\">Add node</button>\\r\\n<p><strong>Note:</strong> Open your dev tools to see the console output when the network receives click events.</p>\\r\\n\"\n\n/***/ },\n\n/***/ 328:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar network_1 = __webpack_require__(56);\r\n\tvar ExampleNetworkData = (function () {\r\n\t    function ExampleNetworkData() {\r\n\t    }\r\n\t    return ExampleNetworkData;\r\n\t}());\r\n\tvar VisNetworkExampleComponent = (function () {\r\n\t    function VisNetworkExampleComponent(visNetworkService) {\r\n\t        this.visNetworkService = visNetworkService;\r\n\t        this.visNetwork = 'networkId1';\r\n\t    }\r\n\t    VisNetworkExampleComponent.prototype.addNode = function () {\r\n\t        var newId = this.visNetworkData.nodes.getLength() + 1;\r\n\t        this.visNetworkData.nodes.add({ id: newId.toString(), label: 'Node ' + newId });\r\n\t        this.visNetworkService.fit(this.visNetwork);\r\n\t    };\r\n\t    VisNetworkExampleComponent.prototype.networkInitialized = function () {\r\n\t        var _this = this;\r\n\t        // now we can use the service to register on events\r\n\t        this.visNetworkService.on(this.visNetwork, 'click');\r\n\t        // open your console/dev tools to see the click params\r\n\t        this.visNetworkService.click\r\n\t            .subscribe(function (eventData) {\r\n\t            if (eventData[0] === _this.visNetwork) {\r\n\t                console.log(eventData[1]);\r\n\t            }\r\n\t        });\r\n\t    };\r\n\t    VisNetworkExampleComponent.prototype.ngOnInit = function () {\r\n\t        var nodes = new network_1.VisNodes([\r\n\t            { id: '1', label: 'Node 1' },\r\n\t            { id: '2', label: 'Node 2' },\r\n\t            { id: '3', label: 'Node 3' },\r\n\t            { id: '4', label: 'Node 4' },\r\n\t            { id: '5', label: 'Node 5', title: 'Title of Node 5' }]);\r\n\t        var edges = new network_1.VisEdges([\r\n\t            { from: '1', to: '3' },\r\n\t            { from: '1', to: '2' },\r\n\t            { from: '2', to: '4' },\r\n\t            { from: '2', to: '5' }]);\r\n\t        this.visNetworkData = {\r\n\t            nodes: nodes,\r\n\t            edges: edges\r\n\t        };\r\n\t        this.visNetworkOptions = {};\r\n\t    };\r\n\t    VisNetworkExampleComponent.prototype.ngOnDestroy = function () {\r\n\t        this.visNetworkService.off(this.visNetwork, 'click');\r\n\t    };\r\n\t    VisNetworkExampleComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'network-example',\r\n\t            template: __webpack_require__(141),\r\n\t            styles: [\r\n\t                __webpack_require__(140)\r\n\t            ]\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [network_1.VisNetworkService])\r\n\t    ], VisNetworkExampleComponent);\r\n\t    return VisNetworkExampleComponent;\r\n\t}());\r\n\texports.VisNetworkExampleComponent = VisNetworkExampleComponent;\r\n\n\n/***/ },\n\n/***/ 142:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"\"\n\n/***/ },\n\n/***/ 143:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<h2>Timeline</h2>\\r\\n<h3>Basic usage</h3>\\r\\n<div [visTimeline]=\\\"visTimeline\\\" [visTimelineItems]=\\\"visTimelineItems\\\" (initialized)=\\\"timelineInitialized()\\\"></div>\\r\\n<button type=\\\"button\\\" class=\\\"btn btn-default\\\" (click)=\\\"addItem()\\\">Add and focus</button>\\r\\n<p><strong>Note:</strong> Open your dev tools to see the console output when the timeline receives click events.</p>\"\n\n/***/ },\n\n/***/ 329:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar timeline_1 = __webpack_require__(43);\r\n\tvar VisTimelineExampleComponent = (function () {\r\n\t    function VisTimelineExampleComponent(visTimelineService) {\r\n\t        this.visTimelineService = visTimelineService;\r\n\t        this.visTimeline = 'timelineId1';\r\n\t    }\r\n\t    VisTimelineExampleComponent.prototype.timelineInitialized = function () {\r\n\t        var _this = this;\r\n\t        console.log('timeline initialized');\r\n\t        // now we can use the service to register on events\r\n\t        this.visTimelineService.on(this.visTimeline, 'click');\r\n\t        // open your console/dev tools to see the click params\r\n\t        this.visTimelineService.click\r\n\t            .subscribe(function (eventData) {\r\n\t            if (eventData[0] === _this.visTimeline) {\r\n\t                console.log(eventData[1]);\r\n\t            }\r\n\t        });\r\n\t    };\r\n\t    VisTimelineExampleComponent.prototype.addItem = function () {\r\n\t        var newLength = this.visTimelineItems.getLength() + 1;\r\n\t        this.visTimelineItems.add({ id: newLength, content: 'item ' + newLength, start: Date.now() });\r\n\t        this.visTimelineService.focusOnIds(this.visTimeline, [1, newLength]);\r\n\t    };\r\n\t    VisTimelineExampleComponent.prototype.ngOnInit = function () {\r\n\t        this.visTimelineItems = new timeline_1.VisTimelineItems([\r\n\t            { id: 1, content: 'item 1', start: '2016-04-20' },\r\n\t            { id: 2, content: 'item 2', start: '2016-04-14' },\r\n\t            { id: 3, content: 'item 3', start: '2016-04-18' },\r\n\t            { id: 4, content: 'item 4', start: '2016-04-16', end: '2016-04-19' },\r\n\t            { id: 5, content: 'item 5', start: '2016-04-25' },\r\n\t            { id: 6, content: 'item 6', start: '2016-04-27', type: 'point' }\r\n\t        ]);\r\n\t    };\r\n\t    VisTimelineExampleComponent.prototype.ngOnDestroy = function () {\r\n\t        this.visTimelineService.off(this.visTimeline, 'click');\r\n\t    };\r\n\t    VisTimelineExampleComponent = __decorate([\r\n\t        core_1.Component({\r\n\t            selector: 'timeline-example',\r\n\t            template: __webpack_require__(143),\r\n\t            styles: [\r\n\t                __webpack_require__(142)\r\n\t            ]\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [timeline_1.VisTimelineService])\r\n\t    ], VisTimelineExampleComponent);\r\n\t    return VisTimelineExampleComponent;\r\n\t}());\r\n\texports.VisTimelineExampleComponent = VisTimelineExampleComponent;\r\n\n\n/***/ },\n\n/***/ 330:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\tvar core_1 = __webpack_require__(8);\r\n\tvar index_1 = __webpack_require__(56);\r\n\tvar index_2 = __webpack_require__(43);\r\n\t__export(__webpack_require__(322));\r\n\tvar VisModule = (function () {\r\n\t    function VisModule() {\r\n\t    }\r\n\t    VisModule = __decorate([\r\n\t        core_1.NgModule({\r\n\t            declarations: [index_1.VisNetworkDirective, index_2.VisTimelineDirective],\r\n\t            exports: [index_1.VisNetworkDirective, index_2.VisTimelineDirective],\r\n\t            providers: [index_1.VisNetworkService, index_2.VisTimelineService],\r\n\t        }), \r\n\t        __metadata('design:paramtypes', [])\r\n\t    ], VisModule);\r\n\t    return VisModule;\r\n\t}());\r\n\texports.VisModule = VisModule;\r\n\n\n/***/ },\n\n/***/ 137:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @license Angular v3.2.4\n\t * (c) 2010-2016 Google, Inc. https://angular.io/\n\t * License: MIT\n\t */(function (global, factory) {\n\t     true ? factory(exports, __webpack_require__(44), __webpack_require__(8), __webpack_require__(144), __webpack_require__(46), __webpack_require__(152), __webpack_require__(153), __webpack_require__(156), __webpack_require__(157), __webpack_require__(159), __webpack_require__(161), __webpack_require__(92), __webpack_require__(163), __webpack_require__(11), __webpack_require__(154), __webpack_require__(155), __webpack_require__(62), __webpack_require__(90), __webpack_require__(160), __webpack_require__(91), __webpack_require__(45), __webpack_require__(158)) :\n\t    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', 'rxjs/BehaviorSubject', 'rxjs/Subject', 'rxjs/observable/from', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/every', 'rxjs/operator/first', 'rxjs/operator/map', 'rxjs/operator/mergeMap', 'rxjs/operator/reduce', 'rxjs/Observable', 'rxjs/operator/catch', 'rxjs/operator/concatAll', 'rxjs/util/EmptyError', 'rxjs/observable/fromPromise', 'rxjs/operator/last', 'rxjs/operator/mergeAll', '@angular/platform-browser', 'rxjs/operator/filter'], factory) :\n\t    (factory((global.ng = global.ng || {}, global.ng.router = global.ng.router || {}),global.ng.common,global.ng.core,global.Rx,global.Rx,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.platformBrowser,global.Rx.Observable.prototype));\n\t}(this, function (exports,_angular_common,_angular_core,rxjs_BehaviorSubject,rxjs_Subject,rxjs_observable_from,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_every,rxjs_operator_first,rxjs_operator_map,rxjs_operator_mergeMap,rxjs_operator_reduce,rxjs_Observable,rxjs_operator_catch,rxjs_operator_concatAll,rxjs_util_EmptyError,rxjs_observable_fromPromise,l,rxjs_operator_mergeAll,_angular_platformBrowser,rxjs_operator_filter) { 'use strict';\n\t\n\t    /**\n\t     * @license\n\t     * Copyright Google Inc. All Rights Reserved.\n\t     *\n\t     * Use of this source code is governed by an MIT-style license that can be\n\t     * found in the LICENSE file at https://angular.io/license\n\t     */\n\t    var __extends = (this && this.__extends) || function (d, b) {\n\t        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t    /**\n\t     * @whatItDoes Name of the primary outlet.\n\t     *\n\t     * @stable\n\t     */\n\t    var PRIMARY_OUTLET = 'primary';\n\t    var NavigationCancelingError = (function (_super) {\n\t        __extends(NavigationCancelingError, _super);\n\t        function NavigationCancelingError(message) {\n\t            _super.call(this, message);\n\t            this.message = message;\n\t            this.stack = (new Error(message)).stack;\n\t        }\n\t        NavigationCancelingError.prototype.toString = function () { return this.message; };\n\t        return NavigationCancelingError;\n\t    }(Error));\n\t    function defaultUrlMatcher(segments, segmentGroup, route) {\n\t        var path = route.path;\n\t        var parts = path.split('/');\n\t        var posParams = {};\n\t        var consumed = [];\n\t        var currentIndex = 0;\n\t        for (var i = 0; i < parts.length; ++i) {\n\t            if (currentIndex >= segments.length)\n\t                return null;\n\t            var current = segments[currentIndex];\n\t            var p = parts[i];\n\t            var isPosParam = p.startsWith(':');\n\t            if (!isPosParam && p !== current.path)\n\t                return null;\n\t            if (isPosParam) {\n\t                posParams[p.substring(1)] = current;\n\t            }\n\t            consumed.push(current);\n\t            currentIndex++;\n\t        }\n\t        if (route.pathMatch === 'full' &&\n\t            (segmentGroup.hasChildren() || currentIndex < segments.length)) {\n\t            return null;\n\t        }\n\t        else {\n\t            return { consumed: consumed, posParams: posParams };\n\t        }\n\t    }\n\t\n\t    function shallowEqualArrays(a, b) {\n\t        if (a.length !== b.length)\n\t            return false;\n\t        for (var i = 0; i < a.length; ++i) {\n\t            if (!shallowEqual(a[i], b[i]))\n\t                return false;\n\t        }\n\t        return true;\n\t    }\n\t    function shallowEqual(a, b) {\n\t        var k1 = Object.keys(a);\n\t        var k2 = Object.keys(b);\n\t        if (k1.length != k2.length) {\n\t            return false;\n\t        }\n\t        var key;\n\t        for (var i = 0; i < k1.length; i++) {\n\t            key = k1[i];\n\t            if (a[key] !== b[key]) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    function flatten(a) {\n\t        var target = [];\n\t        for (var i = 0; i < a.length; ++i) {\n\t            for (var j = 0; j < a[i].length; ++j) {\n\t                target.push(a[i][j]);\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    function last(a) {\n\t        return a.length > 0 ? a[a.length - 1] : null;\n\t    }\n\t    function merge(m1, m2) {\n\t        var m = {};\n\t        for (var attr in m1) {\n\t            if (m1.hasOwnProperty(attr)) {\n\t                m[attr] = m1[attr];\n\t            }\n\t        }\n\t        for (var attr in m2) {\n\t            if (m2.hasOwnProperty(attr)) {\n\t                m[attr] = m2[attr];\n\t            }\n\t        }\n\t        return m;\n\t    }\n\t    function forEach(map, callback) {\n\t        for (var prop in map) {\n\t            if (map.hasOwnProperty(prop)) {\n\t                callback(map[prop], prop);\n\t            }\n\t        }\n\t    }\n\t    function waitForMap(obj, fn) {\n\t        var waitFor = [];\n\t        var res = {};\n\t        forEach(obj, function (a, k) {\n\t            if (k === PRIMARY_OUTLET) {\n\t                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n\t                    res[k] = _;\n\t                    return _;\n\t                }));\n\t            }\n\t        });\n\t        forEach(obj, function (a, k) {\n\t            if (k !== PRIMARY_OUTLET) {\n\t                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n\t                    res[k] = _;\n\t                    return _;\n\t                }));\n\t            }\n\t        });\n\t        if (waitFor.length > 0) {\n\t            var concatted$ = rxjs_operator_concatAll.concatAll.call(rxjs_observable_of.of.apply(void 0, waitFor));\n\t            var last$ = l.last.call(concatted$);\n\t            return rxjs_operator_map.map.call(last$, function () { return res; });\n\t        }\n\t        else {\n\t            return rxjs_observable_of.of(res);\n\t        }\n\t    }\n\t    function andObservables(observables) {\n\t        var merged$ = rxjs_operator_mergeAll.mergeAll.call(observables);\n\t        return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });\n\t    }\n\t    function wrapIntoObservable(value) {\n\t        if (value instanceof rxjs_Observable.Observable) {\n\t            return value;\n\t        }\n\t        else if (value instanceof Promise) {\n\t            return rxjs_observable_fromPromise.fromPromise(value);\n\t        }\n\t        else {\n\t            return rxjs_observable_of.of(value);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @experimental\n\t     */\n\t    var ROUTES = new _angular_core.OpaqueToken('ROUTES');\n\t    var LoadedRouterConfig = (function () {\n\t        function LoadedRouterConfig(routes, injector, factoryResolver, injectorFactory) {\n\t            this.routes = routes;\n\t            this.injector = injector;\n\t            this.factoryResolver = factoryResolver;\n\t            this.injectorFactory = injectorFactory;\n\t        }\n\t        return LoadedRouterConfig;\n\t    }());\n\t    var RouterConfigLoader = (function () {\n\t        function RouterConfigLoader(loader, compiler) {\n\t            this.loader = loader;\n\t            this.compiler = compiler;\n\t        }\n\t        RouterConfigLoader.prototype.load = function (parentInjector, loadChildren) {\n\t            return rxjs_operator_map.map.call(this.loadModuleFactory(loadChildren), function (r) {\n\t                var ref = r.create(parentInjector);\n\t                var injectorFactory = function (parent) { return r.create(parent).injector; };\n\t                return new LoadedRouterConfig(flatten(ref.injector.get(ROUTES)), ref.injector, ref.componentFactoryResolver, injectorFactory);\n\t            });\n\t        };\n\t        RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {\n\t            var _this = this;\n\t            if (typeof loadChildren === 'string') {\n\t                return rxjs_observable_fromPromise.fromPromise(this.loader.load(loadChildren));\n\t            }\n\t            else {\n\t                var offlineMode_1 = this.compiler instanceof _angular_core.Compiler;\n\t                return rxjs_operator_mergeMap.mergeMap.call(wrapIntoObservable(loadChildren()), function (t) { return offlineMode_1 ? rxjs_observable_of.of(t) : rxjs_observable_fromPromise.fromPromise(_this.compiler.compileModuleAsync(t)); });\n\t            }\n\t        };\n\t        return RouterConfigLoader;\n\t    }());\n\t\n\t    function createEmptyUrlTree() {\n\t        return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n\t    }\n\t    function containsTree(container, containee, exact) {\n\t        if (exact) {\n\t            return equalQueryParams(container.queryParams, containee.queryParams) &&\n\t                equalSegmentGroups(container.root, containee.root);\n\t        }\n\t        else {\n\t            return containsQueryParams(container.queryParams, containee.queryParams) &&\n\t                containsSegmentGroup(container.root, containee.root);\n\t        }\n\t    }\n\t    function equalQueryParams(container, containee) {\n\t        return shallowEqual(container, containee);\n\t    }\n\t    function equalSegmentGroups(container, containee) {\n\t        if (!equalPath(container.segments, containee.segments))\n\t            return false;\n\t        if (container.numberOfChildren !== containee.numberOfChildren)\n\t            return false;\n\t        for (var c in containee.children) {\n\t            if (!container.children[c])\n\t                return false;\n\t            if (!equalSegmentGroups(container.children[c], containee.children[c]))\n\t                return false;\n\t        }\n\t        return true;\n\t    }\n\t    function containsQueryParams(container, containee) {\n\t        return Object.keys(containee) <= Object.keys(container) &&\n\t            Object.keys(containee).every(function (key) { return containee[key] === container[key]; });\n\t    }\n\t    function containsSegmentGroup(container, containee) {\n\t        return containsSegmentGroupHelper(container, containee, containee.segments);\n\t    }\n\t    function containsSegmentGroupHelper(container, containee, containeePaths) {\n\t        if (container.segments.length > containeePaths.length) {\n\t            var current = container.segments.slice(0, containeePaths.length);\n\t            if (!equalPath(current, containeePaths))\n\t                return false;\n\t            if (containee.hasChildren())\n\t                return false;\n\t            return true;\n\t        }\n\t        else if (container.segments.length === containeePaths.length) {\n\t            if (!equalPath(container.segments, containeePaths))\n\t                return false;\n\t            for (var c in containee.children) {\n\t                if (!container.children[c])\n\t                    return false;\n\t                if (!containsSegmentGroup(container.children[c], containee.children[c]))\n\t                    return false;\n\t            }\n\t            return true;\n\t        }\n\t        else {\n\t            var current = containeePaths.slice(0, container.segments.length);\n\t            var next = containeePaths.slice(container.segments.length);\n\t            if (!equalPath(container.segments, current))\n\t                return false;\n\t            if (!container.children[PRIMARY_OUTLET])\n\t                return false;\n\t            return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n\t        }\n\t    }\n\t    /**\n\t     * @whatItDoes Represents the parsed URL.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'template.html'})\n\t     * class MyComponent {\n\t     *   constructor(router: Router) {\n\t     *     const tree: UrlTree =\n\t     * router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n\t     *     const f = tree.fragment; // return 'fragment'\n\t     *     const q = tree.queryParams; // returns {debug: 'true'}\n\t     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n\t     *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n\t     *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n\t     *     g.children['support'].segments; // return 1 segment 'help'\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n\t     * serialized tree.\n\t     * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n\t     *\n\t     * @stable\n\t     */\n\t    var UrlTree = (function () {\n\t        /**\n\t         * @internal\n\t         */\n\t        function UrlTree(\n\t            /**\n\t            * The root segment group of the URL tree.\n\t             */\n\t            root, \n\t            /**\n\t             * The query params of the URL.\n\t             */\n\t            queryParams, \n\t            /**\n\t             * The fragment of the URL.\n\t             */\n\t            fragment) {\n\t            this.root = root;\n\t            this.queryParams = queryParams;\n\t            this.fragment = fragment;\n\t        }\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        UrlTree.prototype.toString = function () { return new DefaultUrlSerializer().serialize(this); };\n\t        return UrlTree;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents the parsed URL segment.\n\t     *\n\t     * See {@link UrlTree} for more information.\n\t     *\n\t     * @stable\n\t     */\n\t    var UrlSegmentGroup = (function () {\n\t        function UrlSegmentGroup(\n\t            /**\n\t             * The URL segments of this group. See {@link UrlSegment} for more information.\n\t             */\n\t            segments, \n\t            /**\n\t             * The list of children of this group.\n\t             */\n\t            children) {\n\t            var _this = this;\n\t            this.segments = segments;\n\t            this.children = children;\n\t            /**\n\t             * The parent node in the url tree.\n\t             */\n\t            this.parent = null;\n\t            forEach(children, function (v, k) { return v.parent = _this; });\n\t        }\n\t        /**\n\t         * Return true if the segment has child segments\n\t         */\n\t        UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };\n\t        Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\n\t            /**\n\t             * Returns the number of child sements.\n\t             */\n\t            get: function () { return Object.keys(this.children).length; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };\n\t        return UrlSegmentGroup;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents a single URL segment.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'template.html'})\n\t     * class MyComponent {\n\t     *   constructor(router: Router) {\n\t     *     const tree: UrlTree = router.parseUrl('/team;id=33');\n\t     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n\t     *     const s: UrlSegment[] = g.segments;\n\t     *     s[0].path; // returns 'team'\n\t     *     s[0].parameters; // returns {id: 33}\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * A UrlSegment is a part of a URL between the two slashes. It contains a path and\n\t     * the matrix parameters associated with the segment.\n\t     *\n\t     * @stable\n\t     */\n\t    var UrlSegment = (function () {\n\t        function UrlSegment(\n\t            /**\n\t             * The path part of a URL segment.\n\t             */\n\t            path, \n\t            /**\n\t             * The matrix parameters associated with a segment.\n\t             */\n\t            parameters) {\n\t            this.path = path;\n\t            this.parameters = parameters;\n\t        }\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        UrlSegment.prototype.toString = function () { return serializePath(this); };\n\t        return UrlSegment;\n\t    }());\n\t    function equalSegments(a, b) {\n\t        if (a.length !== b.length)\n\t            return false;\n\t        for (var i = 0; i < a.length; ++i) {\n\t            if (a[i].path !== b[i].path)\n\t                return false;\n\t            if (!shallowEqual(a[i].parameters, b[i].parameters))\n\t                return false;\n\t        }\n\t        return true;\n\t    }\n\t    function equalPath(a, b) {\n\t        if (a.length !== b.length)\n\t            return false;\n\t        for (var i = 0; i < a.length; ++i) {\n\t            if (a[i].path !== b[i].path)\n\t                return false;\n\t        }\n\t        return true;\n\t    }\n\t    function mapChildrenIntoArray(segment, fn) {\n\t        var res = [];\n\t        forEach(segment.children, function (child, childOutlet) {\n\t            if (childOutlet === PRIMARY_OUTLET) {\n\t                res = res.concat(fn(child, childOutlet));\n\t            }\n\t        });\n\t        forEach(segment.children, function (child, childOutlet) {\n\t            if (childOutlet !== PRIMARY_OUTLET) {\n\t                res = res.concat(fn(child, childOutlet));\n\t            }\n\t        });\n\t        return res;\n\t    }\n\t    /**\n\t     * @whatItDoes Serializes and deserializes a URL string into a URL tree.\n\t     *\n\t     * @description The url serialization strategy is customizable. You can\n\t     * make all URLs case insensitive by providing a custom UrlSerializer.\n\t     *\n\t     * See {@link DefaultUrlSerializer} for an example of a URL serializer.\n\t     *\n\t     * @stable\n\t     */\n\t    var UrlSerializer = (function () {\n\t        function UrlSerializer() {\n\t        }\n\t        return UrlSerializer;\n\t    }());\n\t    /**\n\t     * @whatItDoes A default implementation of the {@link UrlSerializer}.\n\t     *\n\t     * @description\n\t     *\n\t     * Example URLs:\n\t     *\n\t     * ```\n\t     * /inbox/33(popup:compose)\n\t     * /inbox/33;open=true/messages/44\n\t     * ```\n\t     *\n\t     * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n\t     * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n\t     * specify route specific parameters.\n\t     *\n\t     * @stable\n\t     */\n\t    var DefaultUrlSerializer = (function () {\n\t        function DefaultUrlSerializer() {\n\t        }\n\t        /**\n\t         * Parse a url into a {@link UrlTree}.\n\t         */\n\t        DefaultUrlSerializer.prototype.parse = function (url) {\n\t            var p = new UrlParser(url);\n\t            return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n\t        };\n\t        /**\n\t         * Converts a {@link UrlTree} into a url.\n\t         */\n\t        DefaultUrlSerializer.prototype.serialize = function (tree) {\n\t            var segment = \"/\" + serializeSegment(tree.root, true);\n\t            var query = serializeQueryParams(tree.queryParams);\n\t            var fragment = tree.fragment !== null && tree.fragment !== undefined ? \"#\" + encodeURI(tree.fragment) : '';\n\t            return \"\" + segment + query + fragment;\n\t        };\n\t        return DefaultUrlSerializer;\n\t    }());\n\t    function serializePaths(segment) {\n\t        return segment.segments.map(function (p) { return serializePath(p); }).join('/');\n\t    }\n\t    function serializeSegment(segment, root) {\n\t        if (segment.hasChildren() && root) {\n\t            var primary = segment.children[PRIMARY_OUTLET] ?\n\t                serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n\t                '';\n\t            var children_1 = [];\n\t            forEach(segment.children, function (v, k) {\n\t                if (k !== PRIMARY_OUTLET) {\n\t                    children_1.push(k + \":\" + serializeSegment(v, false));\n\t                }\n\t            });\n\t            if (children_1.length > 0) {\n\t                return primary + \"(\" + children_1.join('//') + \")\";\n\t            }\n\t            else {\n\t                return \"\" + primary;\n\t            }\n\t        }\n\t        else if (segment.hasChildren() && !root) {\n\t            var children = mapChildrenIntoArray(segment, function (v, k) {\n\t                if (k === PRIMARY_OUTLET) {\n\t                    return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n\t                }\n\t                else {\n\t                    return [(k + \":\" + serializeSegment(v, false))];\n\t                }\n\t            });\n\t            return serializePaths(segment) + \"/(\" + children.join('//') + \")\";\n\t        }\n\t        else {\n\t            return serializePaths(segment);\n\t        }\n\t    }\n\t    function encode(s) {\n\t        return encodeURIComponent(s);\n\t    }\n\t    function decode(s) {\n\t        return decodeURIComponent(s);\n\t    }\n\t    function serializePath(path) {\n\t        return \"\" + encode(path.path) + serializeParams(path.parameters);\n\t    }\n\t    function serializeParams(params) {\n\t        return pairs(params).map(function (p) { return (\";\" + encode(p.first) + \"=\" + encode(p.second)); }).join('');\n\t    }\n\t    function serializeQueryParams(params) {\n\t        var strs = pairs(params).map(function (p) { return (encode(p.first) + \"=\" + encode(p.second)); });\n\t        return strs.length > 0 ? \"?\" + strs.join(\"&\") : '';\n\t    }\n\t    var Pair = (function () {\n\t        function Pair(first, second) {\n\t            this.first = first;\n\t            this.second = second;\n\t        }\n\t        return Pair;\n\t    }());\n\t    function pairs(obj) {\n\t        var res = [];\n\t        for (var prop in obj) {\n\t            if (obj.hasOwnProperty(prop)) {\n\t                res.push(new Pair(prop, obj[prop]));\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    var SEGMENT_RE = /^[^\\/\\(\\)\\?;=&#]+/;\n\t    function matchSegments(str) {\n\t        SEGMENT_RE.lastIndex = 0;\n\t        var match = str.match(SEGMENT_RE);\n\t        return match ? match[0] : '';\n\t    }\n\t    var QUERY_PARAM_RE = /^[^=\\?&#]+/;\n\t    function matchQueryParams(str) {\n\t        QUERY_PARAM_RE.lastIndex = 0;\n\t        var match = str.match(SEGMENT_RE);\n\t        return match ? match[0] : '';\n\t    }\n\t    var QUERY_PARAM_VALUE_RE = /^[^\\?&#]+/;\n\t    function matchUrlQueryParamValue(str) {\n\t        QUERY_PARAM_VALUE_RE.lastIndex = 0;\n\t        var match = str.match(QUERY_PARAM_VALUE_RE);\n\t        return match ? match[0] : '';\n\t    }\n\t    var UrlParser = (function () {\n\t        function UrlParser(url) {\n\t            this.url = url;\n\t            this.remaining = url;\n\t        }\n\t        UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };\n\t        UrlParser.prototype.capture = function (str) {\n\t            if (!this.remaining.startsWith(str)) {\n\t                throw new Error(\"Expected \\\"\" + str + \"\\\".\");\n\t            }\n\t            this.remaining = this.remaining.substring(str.length);\n\t        };\n\t        UrlParser.prototype.parseRootSegment = function () {\n\t            if (this.remaining.startsWith('/')) {\n\t                this.capture('/');\n\t            }\n\t            if (this.remaining === '' || this.remaining.startsWith('?') || this.remaining.startsWith('#')) {\n\t                return new UrlSegmentGroup([], {});\n\t            }\n\t            else {\n\t                return new UrlSegmentGroup([], this.parseChildren());\n\t            }\n\t        };\n\t        UrlParser.prototype.parseChildren = function () {\n\t            if (this.remaining.length == 0) {\n\t                return {};\n\t            }\n\t            if (this.peekStartsWith('/')) {\n\t                this.capture('/');\n\t            }\n\t            var paths = [];\n\t            if (!this.peekStartsWith('(')) {\n\t                paths.push(this.parseSegments());\n\t            }\n\t            while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n\t                this.capture('/');\n\t                paths.push(this.parseSegments());\n\t            }\n\t            var children = {};\n\t            if (this.peekStartsWith('/(')) {\n\t                this.capture('/');\n\t                children = this.parseParens(true);\n\t            }\n\t            var res = {};\n\t            if (this.peekStartsWith('(')) {\n\t                res = this.parseParens(false);\n\t            }\n\t            if (paths.length > 0 || Object.keys(children).length > 0) {\n\t                res[PRIMARY_OUTLET] = new UrlSegmentGroup(paths, children);\n\t            }\n\t            return res;\n\t        };\n\t        UrlParser.prototype.parseSegments = function () {\n\t            var path = matchSegments(this.remaining);\n\t            if (path === '' && this.peekStartsWith(';')) {\n\t                throw new Error(\"Empty path url segment cannot have parameters: '\" + this.remaining + \"'.\");\n\t            }\n\t            this.capture(path);\n\t            var matrixParams = {};\n\t            if (this.peekStartsWith(';')) {\n\t                matrixParams = this.parseMatrixParams();\n\t            }\n\t            return new UrlSegment(decode(path), matrixParams);\n\t        };\n\t        UrlParser.prototype.parseQueryParams = function () {\n\t            var params = {};\n\t            if (this.peekStartsWith('?')) {\n\t                this.capture('?');\n\t                this.parseQueryParam(params);\n\t                while (this.remaining.length > 0 && this.peekStartsWith('&')) {\n\t                    this.capture('&');\n\t                    this.parseQueryParam(params);\n\t                }\n\t            }\n\t            return params;\n\t        };\n\t        UrlParser.prototype.parseFragment = function () {\n\t            if (this.peekStartsWith('#')) {\n\t                return decodeURI(this.remaining.substring(1));\n\t            }\n\t            else {\n\t                return null;\n\t            }\n\t        };\n\t        UrlParser.prototype.parseMatrixParams = function () {\n\t            var params = {};\n\t            while (this.remaining.length > 0 && this.peekStartsWith(';')) {\n\t                this.capture(';');\n\t                this.parseParam(params);\n\t            }\n\t            return params;\n\t        };\n\t        UrlParser.prototype.parseParam = function (params) {\n\t            var key = matchSegments(this.remaining);\n\t            if (!key) {\n\t                return;\n\t            }\n\t            this.capture(key);\n\t            var value = '';\n\t            if (this.peekStartsWith('=')) {\n\t                this.capture('=');\n\t                var valueMatch = matchSegments(this.remaining);\n\t                if (valueMatch) {\n\t                    value = valueMatch;\n\t                    this.capture(value);\n\t                }\n\t            }\n\t            params[decode(key)] = decode(value);\n\t        };\n\t        UrlParser.prototype.parseQueryParam = function (params) {\n\t            var key = matchQueryParams(this.remaining);\n\t            if (!key) {\n\t                return;\n\t            }\n\t            this.capture(key);\n\t            var value = '';\n\t            if (this.peekStartsWith('=')) {\n\t                this.capture('=');\n\t                var valueMatch = matchUrlQueryParamValue(this.remaining);\n\t                if (valueMatch) {\n\t                    value = valueMatch;\n\t                    this.capture(value);\n\t                }\n\t            }\n\t            params[decode(key)] = decode(value);\n\t        };\n\t        UrlParser.prototype.parseParens = function (allowPrimary) {\n\t            var segments = {};\n\t            this.capture('(');\n\t            while (!this.peekStartsWith(')') && this.remaining.length > 0) {\n\t                var path = matchSegments(this.remaining);\n\t                var next = this.remaining[path.length];\n\t                // if is is not one of these characters, then the segment was unescaped\n\t                // or the group was not closed\n\t                if (next !== '/' && next !== ')' && next !== ';') {\n\t                    throw new Error(\"Cannot parse url '\" + this.url + \"'\");\n\t                }\n\t                var outletName = void 0;\n\t                if (path.indexOf(':') > -1) {\n\t                    outletName = path.substr(0, path.indexOf(':'));\n\t                    this.capture(outletName);\n\t                    this.capture(':');\n\t                }\n\t                else if (allowPrimary) {\n\t                    outletName = PRIMARY_OUTLET;\n\t                }\n\t                var children = this.parseChildren();\n\t                segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n\t                    new UrlSegmentGroup([], children);\n\t                if (this.peekStartsWith('//')) {\n\t                    this.capture('//');\n\t                }\n\t            }\n\t            this.capture(')');\n\t            return segments;\n\t        };\n\t        return UrlParser;\n\t    }());\n\t\n\t    var NoMatch = (function () {\n\t        function NoMatch(segmentGroup) {\n\t            if (segmentGroup === void 0) { segmentGroup = null; }\n\t            this.segmentGroup = segmentGroup;\n\t        }\n\t        return NoMatch;\n\t    }());\n\t    var AbsoluteRedirect = (function () {\n\t        function AbsoluteRedirect(urlTree) {\n\t            this.urlTree = urlTree;\n\t        }\n\t        return AbsoluteRedirect;\n\t    }());\n\t    function noMatch(segmentGroup) {\n\t        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });\n\t    }\n\t    function absoluteRedirect(newTree) {\n\t        return new rxjs_Observable.Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });\n\t    }\n\t    function namedOutletsRedirect(redirectTo) {\n\t        return new rxjs_Observable.Observable(function (obs) { return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\" + redirectTo + \"'\")); });\n\t    }\n\t    function canLoadFails(route) {\n\t        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NavigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\" + route.path + \"'\\\" returned false\")); });\n\t    }\n\t    function applyRedirects(injector, configLoader, urlSerializer, urlTree, config) {\n\t        return new ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config).apply();\n\t    }\n\t    var ApplyRedirects = (function () {\n\t        function ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config) {\n\t            this.injector = injector;\n\t            this.configLoader = configLoader;\n\t            this.urlSerializer = urlSerializer;\n\t            this.urlTree = urlTree;\n\t            this.config = config;\n\t            this.allowRedirects = true;\n\t        }\n\t        ApplyRedirects.prototype.apply = function () {\n\t            var _this = this;\n\t            var expanded$ = this.expandSegmentGroup(this.injector, this.config, this.urlTree.root, PRIMARY_OUTLET);\n\t            var urlTrees$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, _this.urlTree.fragment); });\n\t            return rxjs_operator_catch._catch.call(urlTrees$, function (e) {\n\t                if (e instanceof AbsoluteRedirect) {\n\t                    // after an absolute redirect we do not apply any more redirects!\n\t                    _this.allowRedirects = false;\n\t                    // we need to run matching, so we can fetch all lazy-loaded modules\n\t                    return _this.match(e.urlTree);\n\t                }\n\t                else if (e instanceof NoMatch) {\n\t                    throw _this.noMatchError(e);\n\t                }\n\t                else {\n\t                    throw e;\n\t                }\n\t            });\n\t        };\n\t        ApplyRedirects.prototype.match = function (tree) {\n\t            var _this = this;\n\t            var expanded$ = this.expandSegmentGroup(this.injector, this.config, tree.root, PRIMARY_OUTLET);\n\t            var mapped$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) {\n\t                return _this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment);\n\t            });\n\t            return rxjs_operator_catch._catch.call(mapped$, function (e) {\n\t                if (e instanceof NoMatch) {\n\t                    throw _this.noMatchError(e);\n\t                }\n\t                else {\n\t                    throw e;\n\t                }\n\t            });\n\t        };\n\t        ApplyRedirects.prototype.noMatchError = function (e) {\n\t            return new Error(\"Cannot match any routes. URL Segment: '\" + e.segmentGroup + \"'\");\n\t        };\n\t        ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {\n\t            var root = rootCandidate.segments.length > 0 ?\n\t                new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\n\t                rootCandidate;\n\t            return new UrlTree(root, queryParams, fragment);\n\t            var _a;\n\t        };\n\t        ApplyRedirects.prototype.expandSegmentGroup = function (injector, routes, segmentGroup, outlet) {\n\t            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n\t                return rxjs_operator_map.map.call(this.expandChildren(injector, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });\n\t            }\n\t            else {\n\t                return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.expandChildren = function (injector, routes, segmentGroup) {\n\t            var _this = this;\n\t            return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(injector, routes, child, childOutlet); });\n\t        };\n\t        ApplyRedirects.prototype.expandSegment = function (injector, segmentGroup, routes, segments, outlet, allowRedirects) {\n\t            var _this = this;\n\t            var routes$ = rxjs_observable_of.of.apply(void 0, routes);\n\t            var processedRoutes$ = rxjs_operator_map.map.call(routes$, function (r) {\n\t                var expanded$ = _this.expandSegmentAgainstRoute(injector, segmentGroup, routes, r, segments, outlet, allowRedirects);\n\t                return rxjs_operator_catch._catch.call(expanded$, function (e) {\n\t                    if (e instanceof NoMatch)\n\t                        return rxjs_observable_of.of(null);\n\t                    else\n\t                        throw e;\n\t                });\n\t            });\n\t            var concattedProcessedRoutes$ = rxjs_operator_concatAll.concatAll.call(processedRoutes$);\n\t            var first$ = rxjs_operator_first.first.call(concattedProcessedRoutes$, function (s) { return !!s; });\n\t            return rxjs_operator_catch._catch.call(first$, function (e, _) {\n\t                if (e instanceof rxjs_util_EmptyError.EmptyError) {\n\t                    if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n\t                        return rxjs_observable_of.of(new UrlSegmentGroup([], {}));\n\t                    }\n\t                    else {\n\t                        throw new NoMatch(segmentGroup);\n\t                    }\n\t                }\n\t                else {\n\t                    throw e;\n\t                }\n\t            });\n\t        };\n\t        ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\n\t            return segments.length === 0 && !segmentGroup.children[outlet];\n\t        };\n\t        ApplyRedirects.prototype.expandSegmentAgainstRoute = function (injector, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n\t            if (getOutlet$1(route) !== outlet)\n\t                return noMatch(segmentGroup);\n\t            if (route.redirectTo !== undefined && !(allowRedirects && this.allowRedirects))\n\t                return noMatch(segmentGroup);\n\t            if (route.redirectTo === undefined) {\n\t                return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths);\n\t            }\n\t            else {\n\t                return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, paths, outlet);\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n\t            if (route.path === '**') {\n\t                return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet);\n\t            }\n\t            else {\n\t                return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet);\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (injector, routes, route, outlet) {\n\t            var _this = this;\n\t            var newTree = this.applyRedirectCommands([], route.redirectTo, {});\n\t            if (route.redirectTo.startsWith('/')) {\n\t                return absoluteRedirect(newTree);\n\t            }\n\t            else {\n\t                return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n\t                    var group = new UrlSegmentGroup(newSegments, {});\n\t                    return _this.expandSegment(injector, group, routes, newSegments, outlet, false);\n\t                });\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n\t            var _this = this;\n\t            var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\n\t            if (!matched)\n\t                return noMatch(segmentGroup);\n\t            var newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);\n\t            if (route.redirectTo.startsWith('/')) {\n\t                return absoluteRedirect(newTree);\n\t            }\n\t            else {\n\t                return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n\t                    return _this.expandSegment(injector, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n\t                });\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.matchSegmentAgainstRoute = function (injector, rawSegmentGroup, route, segments) {\n\t            var _this = this;\n\t            if (route.path === '**') {\n\t                if (route.loadChildren) {\n\t                    return rxjs_operator_map.map.call(this.configLoader.load(injector, route.loadChildren), function (r) {\n\t                        route._loadedConfig = r;\n\t                        return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n\t                    });\n\t                }\n\t                else {\n\t                    return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n\t                }\n\t            }\n\t            else {\n\t                var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments_1 = _a.consumedSegments, lastChild = _a.lastChild;\n\t                if (!matched)\n\t                    return noMatch(rawSegmentGroup);\n\t                var rawSlicedSegments_1 = segments.slice(lastChild);\n\t                var childConfig$ = this.getChildConfig(injector, route);\n\t                return rxjs_operator_mergeMap.mergeMap.call(childConfig$, function (routerConfig) {\n\t                    var childInjector = routerConfig.injector;\n\t                    var childConfig = routerConfig.routes;\n\t                    var _a = split(rawSegmentGroup, consumedSegments_1, rawSlicedSegments_1, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n\t                    if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n\t                        var expanded$ = _this.expandChildren(childInjector, childConfig, segmentGroup);\n\t                        return rxjs_operator_map.map.call(expanded$, function (children) { return new UrlSegmentGroup(consumedSegments_1, children); });\n\t                    }\n\t                    else if (childConfig.length === 0 && slicedSegments.length === 0) {\n\t                        return rxjs_observable_of.of(new UrlSegmentGroup(consumedSegments_1, {}));\n\t                    }\n\t                    else {\n\t                        var expanded$ = _this.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n\t                        return rxjs_operator_map.map.call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments_1.concat(cs.segments), cs.children); });\n\t                    }\n\t                });\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.getChildConfig = function (injector, route) {\n\t            var _this = this;\n\t            if (route.children) {\n\t                return rxjs_observable_of.of(new LoadedRouterConfig(route.children, injector, null, null));\n\t            }\n\t            else if (route.loadChildren) {\n\t                return rxjs_operator_mergeMap.mergeMap.call(runGuards(injector, route), function (shouldLoad) {\n\t                    if (shouldLoad) {\n\t                        if (route._loadedConfig) {\n\t                            return rxjs_observable_of.of(route._loadedConfig);\n\t                        }\n\t                        else {\n\t                            return rxjs_operator_map.map.call(_this.configLoader.load(injector, route.loadChildren), function (r) {\n\t                                route._loadedConfig = r;\n\t                                return r;\n\t                            });\n\t                        }\n\t                    }\n\t                    else {\n\t                        return canLoadFails(route);\n\t                    }\n\t                });\n\t            }\n\t            else {\n\t                return rxjs_observable_of.of(new LoadedRouterConfig([], injector, null, null));\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {\n\t            var res = [];\n\t            var c = urlTree.root;\n\t            while (true) {\n\t                res = res.concat(c.segments);\n\t                if (c.numberOfChildren === 0) {\n\t                    return rxjs_observable_of.of(res);\n\t                }\n\t                else if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n\t                    return namedOutletsRedirect(route.redirectTo);\n\t                }\n\t                else {\n\t                    c = c.children[PRIMARY_OUTLET];\n\t                }\n\t            }\n\t        };\n\t        ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {\n\t            var t = this.urlSerializer.parse(redirectTo);\n\t            return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n\t        };\n\t        ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {\n\t            var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n\t            return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n\t        };\n\t        ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {\n\t            var res = {};\n\t            forEach(redirectToParams, function (v, k) {\n\t                if (v.startsWith(':')) {\n\t                    res[k] = actualParams[v.substring(1)];\n\t                }\n\t                else {\n\t                    res[k] = v;\n\t                }\n\t            });\n\t            return res;\n\t        };\n\t        ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {\n\t            var _this = this;\n\t            var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\t            var children = {};\n\t            forEach(group.children, function (child, name) {\n\t                children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);\n\t            });\n\t            return new UrlSegmentGroup(updatedSegments, children);\n\t        };\n\t        ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {\n\t            var _this = this;\n\t            return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :\n\t                _this.findOrReturn(s, actualSegments); });\n\t        };\n\t        ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {\n\t            var pos = posParams[redirectToUrlSegment.path.substring(1)];\n\t            if (!pos)\n\t                throw new Error(\"Cannot redirect to '\" + redirectTo + \"'. Cannot find '\" + redirectToUrlSegment.path + \"'.\");\n\t            return pos;\n\t        };\n\t        ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {\n\t            var idx = 0;\n\t            for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {\n\t                var s = actualSegments_1[_i];\n\t                if (s.path === redirectToUrlSegment.path) {\n\t                    actualSegments.splice(idx);\n\t                    return s;\n\t                }\n\t                idx++;\n\t            }\n\t            return redirectToUrlSegment;\n\t        };\n\t        return ApplyRedirects;\n\t    }());\n\t    function runGuards(injector, route) {\n\t        var canLoad = route.canLoad;\n\t        if (!canLoad || canLoad.length === 0)\n\t            return rxjs_observable_of.of(true);\n\t        var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canLoad), function (c) {\n\t            var guard = injector.get(c);\n\t            if (guard.canLoad) {\n\t                return wrapIntoObservable(guard.canLoad(route));\n\t            }\n\t            else {\n\t                return wrapIntoObservable(guard(route));\n\t            }\n\t        });\n\t        return andObservables(obs);\n\t    }\n\t    function match(segmentGroup, route, segments) {\n\t        var noMatch = { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n\t        if (route.path === '') {\n\t            if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n\t                return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n\t            }\n\t            else {\n\t                return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n\t            }\n\t        }\n\t        var matcher = route.matcher || defaultUrlMatcher;\n\t        var res = matcher(segments, segmentGroup, route);\n\t        if (!res)\n\t            return noMatch;\n\t        return {\n\t            matched: true,\n\t            consumedSegments: res.consumed,\n\t            lastChild: res.consumed.length,\n\t            positionalParamSegments: res.posParams\n\t        };\n\t    }\n\t    function split(segmentGroup, consumedSegments, slicedSegments, config) {\n\t        if (slicedSegments.length > 0 &&\n\t            containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n\t            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\t            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\n\t        }\n\t        else if (slicedSegments.length === 0 &&\n\t            containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n\t            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\t            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\n\t        }\n\t        else {\n\t            return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\n\t        }\n\t    }\n\t    function mergeTrivialChildren(s) {\n\t        if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n\t            var c = s.children[PRIMARY_OUTLET];\n\t            return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n\t        }\n\t        else {\n\t            return s;\n\t        }\n\t    }\n\t    function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n\t        var res = {};\n\t        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n\t            var r = routes_1[_i];\n\t            if (emptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n\t                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n\t            }\n\t        }\n\t        return merge(children, res);\n\t    }\n\t    function createChildrenForEmptySegments(routes, primarySegmentGroup) {\n\t        var res = {};\n\t        res[PRIMARY_OUTLET] = primarySegmentGroup;\n\t        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n\t            var r = routes_2[_i];\n\t            if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n\t                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n\t        return routes\n\t            .filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r) &&\n\t            getOutlet$1(r) !== PRIMARY_OUTLET; })\n\t            .length > 0;\n\t    }\n\t    function containsEmptyPathRedirects(segmentGroup, slicedSegments, routes) {\n\t        return routes.filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r); }).length > 0;\n\t    }\n\t    function emptyPathRedirect(segmentGroup, slicedSegments, r) {\n\t        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n\t            return false;\n\t        return r.path === '' && r.redirectTo !== undefined;\n\t    }\n\t    function getOutlet$1(route) {\n\t        return route.outlet ? route.outlet : PRIMARY_OUTLET;\n\t    }\n\t\n\t    function validateConfig(config) {\n\t        // forEach doesn't iterate undefined values\n\t        for (var i = 0; i < config.length; i++) {\n\t            validateNode(config[i]);\n\t        }\n\t    }\n\t    function validateNode(route) {\n\t        if (!route) {\n\t            throw new Error(\"\\n      Invalid route configuration: Encountered undefined route.\\n      The reason might be an extra comma.\\n       \\n      Example: \\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \");\n\t        }\n\t        if (Array.isArray(route)) {\n\t            throw new Error(\"Invalid route configuration: Array cannot be specified\");\n\t        }\n\t        if (route.component === undefined && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n\t            throw new Error(\"Invalid route configuration of route '\" + route.path + \"': a componentless route cannot have a named outlet set\");\n\t        }\n\t        if (!!route.redirectTo && !!route.children) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and children cannot be used together\");\n\t        }\n\t        if (!!route.redirectTo && !!route.loadChildren) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and loadChildren cannot be used together\");\n\t        }\n\t        if (!!route.children && !!route.loadChildren) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': children and loadChildren cannot be used together\");\n\t        }\n\t        if (!!route.redirectTo && !!route.component) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and component cannot be used together\");\n\t        }\n\t        if (!!route.path && !!route.matcher) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': path and matcher cannot be used together\");\n\t        }\n\t        if (route.redirectTo === undefined && !route.component && !route.children &&\n\t            !route.loadChildren) {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': one of the following must be provided (component or redirectTo or children or loadChildren)\");\n\t        }\n\t        if (route.path === undefined) {\n\t            throw new Error(\"Invalid route configuration: routes must have path specified\");\n\t        }\n\t        if (route.path.startsWith('/')) {\n\t            throw new Error(\"Invalid route configuration of route '\" + route.path + \"': path cannot start with a slash\");\n\t        }\n\t        if (route.path === '' && route.redirectTo !== undefined && route.pathMatch === undefined) {\n\t            var exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n\t            throw new Error(\"Invalid route configuration of route '{path: \\\"\" + route.path + \"\\\", redirectTo: \\\"\" + route.redirectTo + \"\\\"}': please provide 'pathMatch'. \" + exp);\n\t        }\n\t        if (route.pathMatch !== undefined && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n\t            throw new Error(\"Invalid configuration of route '\" + route.path + \"': pathMatch can only be set to 'prefix' or 'full'\");\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @license\n\t     * Copyright Google Inc. All Rights Reserved.\n\t     *\n\t     * Use of this source code is governed by an MIT-style license that can be\n\t     * found in the LICENSE file at https://angular.io/license\n\t     */\n\t    var Tree = (function () {\n\t        function Tree(root) {\n\t            this._root = root;\n\t        }\n\t        Object.defineProperty(Tree.prototype, \"root\", {\n\t            get: function () { return this._root.value; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.parent = function (t) {\n\t            var p = this.pathFromRoot(t);\n\t            return p.length > 1 ? p[p.length - 2] : null;\n\t        };\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.children = function (t) {\n\t            var n = findNode(t, this._root);\n\t            return n ? n.children.map(function (t) { return t.value; }) : [];\n\t        };\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.firstChild = function (t) {\n\t            var n = findNode(t, this._root);\n\t            return n && n.children.length > 0 ? n.children[0].value : null;\n\t        };\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.siblings = function (t) {\n\t            var p = findPath(t, this._root, []);\n\t            if (p.length < 2)\n\t                return [];\n\t            var c = p[p.length - 2].children.map(function (c) { return c.value; });\n\t            return c.filter(function (cc) { return cc !== t; });\n\t        };\n\t        /**\n\t         * @internal\n\t         */\n\t        Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root, []).map(function (s) { return s.value; }); };\n\t        return Tree;\n\t    }());\n\t    function findNode(expected, c) {\n\t        if (expected === c.value)\n\t            return c;\n\t        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n\t            var cc = _a[_i];\n\t            var r = findNode(expected, cc);\n\t            if (r)\n\t                return r;\n\t        }\n\t        return null;\n\t    }\n\t    function findPath(expected, c, collected) {\n\t        collected.push(c);\n\t        if (expected === c.value)\n\t            return collected;\n\t        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n\t            var cc = _a[_i];\n\t            var cloned = collected.slice(0);\n\t            var r = findPath(expected, cc, cloned);\n\t            if (r.length > 0)\n\t                return r;\n\t        }\n\t        return [];\n\t    }\n\t    var TreeNode = (function () {\n\t        function TreeNode(value, children) {\n\t            this.value = value;\n\t            this.children = children;\n\t        }\n\t        TreeNode.prototype.toString = function () { return \"TreeNode(\" + this.value + \")\"; };\n\t        return TreeNode;\n\t    }());\n\t\n\t    /**\n\t     * @license\n\t     * Copyright Google Inc. All Rights Reserved.\n\t     *\n\t     * Use of this source code is governed by an MIT-style license that can be\n\t     * found in the LICENSE file at https://angular.io/license\n\t     */\n\t    var __extends$1 = (this && this.__extends) || function (d, b) {\n\t        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t    /**\n\t     * @whatItDoes Represents the state of the router.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'template.html'})\n\t     * class MyComponent {\n\t     *   constructor(router: Router) {\n\t     *     const state: RouterState = router.routerState;\n\t     *     const root: ActivatedRoute = state.root;\n\t     *     const child = root.firstChild;\n\t     *     const id: Observable<string> = child.params.map(p => p.id);\n\t     *     //...\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @description\n\t     * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n\t     * segments,\n\t     * the extracted parameters, and the resolved data.\n\t     *\n\t     * See {@link ActivatedRoute} for more information.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterState = (function (_super) {\n\t        __extends$1(RouterState, _super);\n\t        /**\n\t         * @internal\n\t         */\n\t        function RouterState(root, \n\t            /**\n\t             * The current snapshot of the router state.\n\t             */\n\t            snapshot) {\n\t            _super.call(this, root);\n\t            this.snapshot = snapshot;\n\t            setRouterStateSnapshot(this, root);\n\t        }\n\t        RouterState.prototype.toString = function () { return this.snapshot.toString(); };\n\t        return RouterState;\n\t    }(Tree));\n\t    function createEmptyState(urlTree, rootComponent) {\n\t        var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n\t        var emptyUrl = new rxjs_BehaviorSubject.BehaviorSubject([new UrlSegment('', {})]);\n\t        var emptyParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n\t        var emptyData = new rxjs_BehaviorSubject.BehaviorSubject({});\n\t        var emptyQueryParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n\t        var fragment = new rxjs_BehaviorSubject.BehaviorSubject('');\n\t        var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n\t        activated.snapshot = snapshot.root;\n\t        return new RouterState(new TreeNode(activated, []), snapshot);\n\t    }\n\t    function createEmptyStateSnapshot(urlTree, rootComponent) {\n\t        var emptyParams = {};\n\t        var emptyData = {};\n\t        var emptyQueryParams = {};\n\t        var fragment = '';\n\t        var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n\t        return new RouterStateSnapshot('', new TreeNode(activated, []));\n\t    }\n\t    /**\n\t     * @whatItDoes Contains the information about a route associated with a component loaded in an\n\t     * outlet.\n\t     * ActivatedRoute can also be used to traverse the router state tree.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'./my-component.html'})\n\t     * class MyComponent {\n\t     *   constructor(route: ActivatedRoute) {\n\t     *     const id: Observable<string> = route.params.map(p => p.id);\n\t     *     const url: Observable<string> = route.url.map(s => s.join(''));\n\t     *     const user = route.data.map(d => d.user); //includes `data` and `resolve`\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @stable\n\t     */\n\t    var ActivatedRoute = (function () {\n\t        /**\n\t         * @internal\n\t         */\n\t        function ActivatedRoute(\n\t            /**\n\t             *  The URL segments matched by this route. The observable will emit a new value when\n\t             *  the array of segments changes.\n\t             */\n\t            url, \n\t            /**\n\t             * The matrix parameters scoped to this route. The observable will emit a new value when\n\t             * the set of the parameters changes.\n\t             */\n\t            params, \n\t            /**\n\t             * The query parameters shared by all the routes. The observable will emit a new value when\n\t             * the set of the parameters changes.\n\t             */\n\t            queryParams, \n\t            /**\n\t             * The URL fragment shared by all the routes. The observable will emit a new value when\n\t             * the URL fragment changes.\n\t             */\n\t            fragment, \n\t            /**\n\t             * The static and resolved data of this route. The observable will emit a new value when\n\t             * any of the resolvers returns a new object.\n\t             */\n\t            data, \n\t            /**\n\t             * The outlet name of the route. It's a constant.\n\t             */\n\t            outlet, \n\t            /**\n\t             * The component of the route. It's a constant.\n\t             */\n\t            component, // TODO: vsavkin: remove |string\n\t            futureSnapshot) {\n\t            this.url = url;\n\t            this.params = params;\n\t            this.queryParams = queryParams;\n\t            this.fragment = fragment;\n\t            this.data = data;\n\t            this.outlet = outlet;\n\t            this.component = component;\n\t            this._futureSnapshot = futureSnapshot;\n\t        }\n\t        Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\n\t            /**\n\t             * The configuration used to match this route.\n\t             */\n\t            get: function () { return this._futureSnapshot.routeConfig; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"root\", {\n\t            /**\n\t             * The root of the router state.\n\t             */\n\t            get: function () { return this._routerState.root; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\n\t            /**\n\t             * The parent of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.parent(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\n\t            /**\n\t             * The first child of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.firstChild(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"children\", {\n\t            /**\n\t             * The children of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.children(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\n\t            /**\n\t             * The path from the root of the router state tree to this route.\n\t             */\n\t            get: function () { return this._routerState.pathFromRoot(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        ActivatedRoute.prototype.toString = function () {\n\t            return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\n\t        };\n\t        return ActivatedRoute;\n\t    }());\n\t    /**\n\t     * @internal\n\t     */\n\t    function inheritedParamsDataResolve(route) {\n\t        var pathToRoot = route.pathFromRoot;\n\t        var inhertingStartingFrom = pathToRoot.length - 1;\n\t        while (inhertingStartingFrom >= 1) {\n\t            var current = pathToRoot[inhertingStartingFrom];\n\t            var parent_1 = pathToRoot[inhertingStartingFrom - 1];\n\t            // current route is an empty path => inherits its parent's params and data\n\t            if (current.routeConfig && current.routeConfig.path === '') {\n\t                inhertingStartingFrom--;\n\t            }\n\t            else if (!parent_1.component) {\n\t                inhertingStartingFrom--;\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {\n\t            var params = merge(res.params, curr.params);\n\t            var data = merge(res.data, curr.data);\n\t            var resolve = merge(res.resolve, curr._resolvedData);\n\t            return { params: params, data: data, resolve: resolve };\n\t        }, { params: {}, data: {}, resolve: {} });\n\t    }\n\t    /**\n\t     * @whatItDoes Contains the information about a route associated with a component loaded in an\n\t     * outlet\n\t     * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router\n\t     * state tree.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'./my-component.html'})\n\t     * class MyComponent {\n\t     *   constructor(route: ActivatedRoute) {\n\t     *     const id: string = route.snapshot.params.id;\n\t     *     const url: string = route.snapshot.url.join('');\n\t     *     const user = route.snapshot.data.user;\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @stable\n\t     */\n\t    var ActivatedRouteSnapshot = (function () {\n\t        /**\n\t         * @internal\n\t         */\n\t        function ActivatedRouteSnapshot(\n\t            /**\n\t             *  The URL segments matched by this route.\n\t             */\n\t            url, \n\t            /**\n\t             * The matrix parameters scoped to this route.\n\t             */\n\t            params, \n\t            /**\n\t             * The query parameters shared by all the routes.\n\t             */\n\t            queryParams, \n\t            /**\n\t             * The URL fragment shared by all the routes.\n\t             */\n\t            fragment, \n\t            /**\n\t             * The static and resolved data of this route.\n\t             */\n\t            data, \n\t            /**\n\t             * The outlet name of the route.\n\t             */\n\t            outlet, \n\t            /**\n\t             * The component of the route.\n\t             */\n\t            component, routeConfig, urlSegment, lastPathIndex, resolve) {\n\t            this.url = url;\n\t            this.params = params;\n\t            this.queryParams = queryParams;\n\t            this.fragment = fragment;\n\t            this.data = data;\n\t            this.outlet = outlet;\n\t            this.component = component;\n\t            this._routeConfig = routeConfig;\n\t            this._urlSegment = urlSegment;\n\t            this._lastPathIndex = lastPathIndex;\n\t            this._resolve = resolve;\n\t        }\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"routeConfig\", {\n\t            /**\n\t             * The configuration used to match this route.\n\t             */\n\t            get: function () { return this._routeConfig; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\n\t            /**\n\t             * The root of the router state.\n\t             */\n\t            get: function () { return this._routerState.root; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\n\t            /**\n\t             * The parent of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.parent(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\n\t            /**\n\t             * The first child of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.firstChild(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\n\t            /**\n\t             * The children of this route in the router state tree.\n\t             */\n\t            get: function () { return this._routerState.children(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\n\t            /**\n\t             * The path from the root of the router state tree to this route.\n\t             */\n\t            get: function () { return this._routerState.pathFromRoot(this); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        ActivatedRouteSnapshot.prototype.toString = function () {\n\t            var url = this.url.map(function (s) { return s.toString(); }).join('/');\n\t            var matched = this._routeConfig ? this._routeConfig.path : '';\n\t            return \"Route(url:'\" + url + \"', path:'\" + matched + \"')\";\n\t        };\n\t        return ActivatedRouteSnapshot;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents the state of the router at a moment in time.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @Component({templateUrl:'template.html'})\n\t     * class MyComponent {\n\t     *   constructor(router: Router) {\n\t     *     const state: RouterState = router.routerState;\n\t     *     const snapshot: RouterStateSnapshot = state.snapshot;\n\t     *     const root: ActivatedRouteSnapshot = snapshot.root;\n\t     *     const child = root.firstChild;\n\t     *     const id: Observable<string> = child.params.map(p => p.id);\n\t     *     //...\n\t     *   }\n\t     * }\n\t     * ```\n\t     *\n\t     * @description\n\t     * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about\n\t     * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterStateSnapshot = (function (_super) {\n\t        __extends$1(RouterStateSnapshot, _super);\n\t        /**\n\t         * @internal\n\t         */\n\t        function RouterStateSnapshot(\n\t            /** The url from which this snapshot was created */\n\t            url, root) {\n\t            _super.call(this, root);\n\t            this.url = url;\n\t            setRouterStateSnapshot(this, root);\n\t        }\n\t        RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };\n\t        return RouterStateSnapshot;\n\t    }(Tree));\n\t    function setRouterStateSnapshot(state, node) {\n\t        node.value._routerState = state;\n\t        node.children.forEach(function (c) { return setRouterStateSnapshot(state, c); });\n\t    }\n\t    function serializeNode(node) {\n\t        var c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(\", \") + \" } \" : '';\n\t        return \"\" + node.value + c;\n\t    }\n\t    /**\n\t     * The expectation is that the activate route is created with the right set of parameters.\n\t     * So we push new values into the observables only when they are not the initial values.\n\t     * And we detect that by checking if the snapshot field is set.\n\t     */\n\t    function advanceActivatedRoute(route) {\n\t        if (route.snapshot) {\n\t            if (!shallowEqual(route.snapshot.queryParams, route._futureSnapshot.queryParams)) {\n\t                route.queryParams.next(route._futureSnapshot.queryParams);\n\t            }\n\t            if (route.snapshot.fragment !== route._futureSnapshot.fragment) {\n\t                route.fragment.next(route._futureSnapshot.fragment);\n\t            }\n\t            if (!shallowEqual(route.snapshot.params, route._futureSnapshot.params)) {\n\t                route.params.next(route._futureSnapshot.params);\n\t            }\n\t            if (!shallowEqualArrays(route.snapshot.url, route._futureSnapshot.url)) {\n\t                route.url.next(route._futureSnapshot.url);\n\t            }\n\t            if (!equalParamsAndUrlSegments(route.snapshot, route._futureSnapshot)) {\n\t                route.data.next(route._futureSnapshot.data);\n\t            }\n\t            route.snapshot = route._futureSnapshot;\n\t        }\n\t        else {\n\t            route.snapshot = route._futureSnapshot;\n\t            // this is for resolved data\n\t            route.data.next(route._futureSnapshot.data);\n\t        }\n\t    }\n\t    function equalParamsAndUrlSegments(a, b) {\n\t        return shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n\t    }\n\t\n\t    function createRouterState(curr, prevState) {\n\t        var root = createNode(curr._root, prevState ? prevState._root : undefined);\n\t        return new RouterState(root, curr);\n\t    }\n\t    function createNode(curr, prevState) {\n\t        if (prevState && equalRouteSnapshots(prevState.value.snapshot, curr.value)) {\n\t            var value = prevState.value;\n\t            value._futureSnapshot = curr.value;\n\t            var children = createOrReuseChildren(curr, prevState);\n\t            return new TreeNode(value, children);\n\t        }\n\t        else {\n\t            var value = createActivatedRoute(curr.value);\n\t            var children = curr.children.map(function (c) { return createNode(c); });\n\t            return new TreeNode(value, children);\n\t        }\n\t    }\n\t    function createOrReuseChildren(curr, prevState) {\n\t        return curr.children.map(function (child) {\n\t            for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {\n\t                var p = _a[_i];\n\t                if (equalRouteSnapshots(p.value.snapshot, child.value)) {\n\t                    return createNode(child, p);\n\t                }\n\t            }\n\t            return createNode(child);\n\t        });\n\t    }\n\t    function createActivatedRoute(c) {\n\t        return new ActivatedRoute(new rxjs_BehaviorSubject.BehaviorSubject(c.url), new rxjs_BehaviorSubject.BehaviorSubject(c.params), new rxjs_BehaviorSubject.BehaviorSubject(c.queryParams), new rxjs_BehaviorSubject.BehaviorSubject(c.fragment), new rxjs_BehaviorSubject.BehaviorSubject(c.data), c.outlet, c.component, c);\n\t    }\n\t    function equalRouteSnapshots(a, b) {\n\t        return a._routeConfig === b._routeConfig;\n\t    }\n\t\n\t    function createUrlTree(route, urlTree, commands, queryParams, fragment) {\n\t        if (commands.length === 0) {\n\t            return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n\t        }\n\t        var normalizedCommands = normalizeCommands(commands);\n\t        validateCommands(normalizedCommands);\n\t        if (navigateToRoot(normalizedCommands)) {\n\t            return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n\t        }\n\t        var startingPosition = findStartingPosition(normalizedCommands, urlTree, route);\n\t        var segmentGroup = startingPosition.processChildren ?\n\t            updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, normalizedCommands.commands) :\n\t            updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, normalizedCommands.commands);\n\t        return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n\t    }\n\t    function validateCommands(n) {\n\t        if (n.isAbsolute && n.commands.length > 0 && isMatrixParams(n.commands[0])) {\n\t            throw new Error('Root segment cannot have matrix parameters');\n\t        }\n\t        var c = n.commands.filter(function (c) { return typeof c === 'object' && c.outlets !== undefined; });\n\t        if (c.length > 0 && c[0] !== n.commands[n.commands.length - 1]) {\n\t            throw new Error('{outlets:{}} has to be the last command');\n\t        }\n\t    }\n\t    function isMatrixParams(command) {\n\t        return typeof command === 'object' && command.outlets === undefined &&\n\t            command.segmentPath === undefined;\n\t    }\n\t    function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n\t        if (urlTree.root === oldSegmentGroup) {\n\t            return new UrlTree(newSegmentGroup, stringify(queryParams), fragment);\n\t        }\n\t        else {\n\t            return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), stringify(queryParams), fragment);\n\t        }\n\t    }\n\t    function replaceSegment(current, oldSegment, newSegment) {\n\t        var children = {};\n\t        forEach(current.children, function (c, outletName) {\n\t            if (c === oldSegment) {\n\t                children[outletName] = newSegment;\n\t            }\n\t            else {\n\t                children[outletName] = replaceSegment(c, oldSegment, newSegment);\n\t            }\n\t        });\n\t        return new UrlSegmentGroup(current.segments, children);\n\t    }\n\t    function navigateToRoot(normalizedChange) {\n\t        return normalizedChange.isAbsolute && normalizedChange.commands.length === 1 &&\n\t            normalizedChange.commands[0] == '/';\n\t    }\n\t    var NormalizedNavigationCommands = (function () {\n\t        function NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, commands) {\n\t            this.isAbsolute = isAbsolute;\n\t            this.numberOfDoubleDots = numberOfDoubleDots;\n\t            this.commands = commands;\n\t        }\n\t        return NormalizedNavigationCommands;\n\t    }());\n\t    function normalizeCommands(commands) {\n\t        if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] == '/') {\n\t            return new NormalizedNavigationCommands(true, 0, commands);\n\t        }\n\t        var numberOfDoubleDots = 0;\n\t        var isAbsolute = false;\n\t        var res = [];\n\t        var _loop_1 = function(i) {\n\t            var c = commands[i];\n\t            if (typeof c === 'object' && c.outlets !== undefined) {\n\t                var r_1 = {};\n\t                forEach(c.outlets, function (commands, name) {\n\t                    if (typeof commands === 'string') {\n\t                        r_1[name] = commands.split('/');\n\t                    }\n\t                    else {\n\t                        r_1[name] = commands;\n\t                    }\n\t                });\n\t                res.push({ outlets: r_1 });\n\t                return \"continue\";\n\t            }\n\t            if (typeof c === 'object' && c.segmentPath !== undefined) {\n\t                res.push(c.segmentPath);\n\t                return \"continue\";\n\t            }\n\t            if (!(typeof c === 'string')) {\n\t                res.push(c);\n\t                return \"continue\";\n\t            }\n\t            if (i === 0) {\n\t                var parts = c.split('/');\n\t                for (var j = 0; j < parts.length; ++j) {\n\t                    var cc = parts[j];\n\t                    if (j == 0 && cc == '.') {\n\t                    }\n\t                    else if (j == 0 && cc == '') {\n\t                        isAbsolute = true;\n\t                    }\n\t                    else if (cc == '..') {\n\t                        numberOfDoubleDots++;\n\t                    }\n\t                    else if (cc != '') {\n\t                        res.push(cc);\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                res.push(c);\n\t            }\n\t        };\n\t        for (var i = 0; i < commands.length; ++i) {\n\t            _loop_1(i);\n\t        }\n\t        return new NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, res);\n\t    }\n\t    var Position = (function () {\n\t        function Position(segmentGroup, processChildren, index) {\n\t            this.segmentGroup = segmentGroup;\n\t            this.processChildren = processChildren;\n\t            this.index = index;\n\t        }\n\t        return Position;\n\t    }());\n\t    function findStartingPosition(normalizedChange, urlTree, route) {\n\t        if (normalizedChange.isAbsolute) {\n\t            return new Position(urlTree.root, true, 0);\n\t        }\n\t        else if (route.snapshot._lastPathIndex === -1) {\n\t            return new Position(route.snapshot._urlSegment, true, 0);\n\t        }\n\t        else {\n\t            var modifier = isMatrixParams(normalizedChange.commands[0]) ? 0 : 1;\n\t            var index = route.snapshot._lastPathIndex + modifier;\n\t            return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, normalizedChange.numberOfDoubleDots);\n\t        }\n\t    }\n\t    function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n\t        var g = group;\n\t        var ci = index;\n\t        var dd = numberOfDoubleDots;\n\t        while (dd > ci) {\n\t            dd -= ci;\n\t            g = g.parent;\n\t            if (!g) {\n\t                throw new Error('Invalid number of \\'../\\'');\n\t            }\n\t            ci = g.segments.length;\n\t        }\n\t        return new Position(g, false, ci - dd);\n\t    }\n\t    function getPath(command) {\n\t        if (typeof command === 'object' && command.outlets)\n\t            return command.outlets[PRIMARY_OUTLET];\n\t        return \"\" + command;\n\t    }\n\t    function getOutlets(commands) {\n\t        if (!(typeof commands[0] === 'object'))\n\t            return (_a = {}, _a[PRIMARY_OUTLET] = commands, _a);\n\t        if (commands[0].outlets === undefined)\n\t            return (_b = {}, _b[PRIMARY_OUTLET] = commands, _b);\n\t        return commands[0].outlets;\n\t        var _a, _b;\n\t    }\n\t    function updateSegmentGroup(segmentGroup, startIndex, commands) {\n\t        if (!segmentGroup) {\n\t            segmentGroup = new UrlSegmentGroup([], {});\n\t        }\n\t        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n\t            return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n\t        }\n\t        var m = prefixedWith(segmentGroup, startIndex, commands);\n\t        var slicedCommands = commands.slice(m.commandIndex);\n\t        if (m.match && m.pathIndex < segmentGroup.segments.length) {\n\t            var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n\t            g.children[PRIMARY_OUTLET] =\n\t                new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n\t            return updateSegmentGroupChildren(g, 0, slicedCommands);\n\t        }\n\t        else if (m.match && slicedCommands.length === 0) {\n\t            return new UrlSegmentGroup(segmentGroup.segments, {});\n\t        }\n\t        else if (m.match && !segmentGroup.hasChildren()) {\n\t            return createNewSegmentGroup(segmentGroup, startIndex, commands);\n\t        }\n\t        else if (m.match) {\n\t            return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n\t        }\n\t        else {\n\t            return createNewSegmentGroup(segmentGroup, startIndex, commands);\n\t        }\n\t    }\n\t    function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n\t        if (commands.length === 0) {\n\t            return new UrlSegmentGroup(segmentGroup.segments, {});\n\t        }\n\t        else {\n\t            var outlets_1 = getOutlets(commands);\n\t            var children_1 = {};\n\t            forEach(outlets_1, function (commands, outlet) {\n\t                if (commands !== null) {\n\t                    children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n\t                }\n\t            });\n\t            forEach(segmentGroup.children, function (child, childOutlet) {\n\t                if (outlets_1[childOutlet] === undefined) {\n\t                    children_1[childOutlet] = child;\n\t                }\n\t            });\n\t            return new UrlSegmentGroup(segmentGroup.segments, children_1);\n\t        }\n\t    }\n\t    function prefixedWith(segmentGroup, startIndex, commands) {\n\t        var currentCommandIndex = 0;\n\t        var currentPathIndex = startIndex;\n\t        var noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n\t        while (currentPathIndex < segmentGroup.segments.length) {\n\t            if (currentCommandIndex >= commands.length)\n\t                return noMatch;\n\t            var path = segmentGroup.segments[currentPathIndex];\n\t            var curr = getPath(commands[currentCommandIndex]);\n\t            var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\t            if (currentPathIndex > 0 && curr === undefined)\n\t                break;\n\t            if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n\t                if (!compare(curr, next, path))\n\t                    return noMatch;\n\t                currentCommandIndex += 2;\n\t            }\n\t            else {\n\t                if (!compare(curr, {}, path))\n\t                    return noMatch;\n\t                currentCommandIndex++;\n\t            }\n\t            currentPathIndex++;\n\t        }\n\t        return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n\t    }\n\t    function createNewSegmentGroup(segmentGroup, startIndex, commands) {\n\t        var paths = segmentGroup.segments.slice(0, startIndex);\n\t        var i = 0;\n\t        while (i < commands.length) {\n\t            if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n\t                var children = createNewSegmentChldren(commands[i].outlets);\n\t                return new UrlSegmentGroup(paths, children);\n\t            }\n\t            // if we start with an object literal, we need to reuse the path part from the segment\n\t            if (i === 0 && isMatrixParams(commands[0])) {\n\t                var p = segmentGroup.segments[startIndex];\n\t                paths.push(new UrlSegment(p.path, commands[0]));\n\t                i++;\n\t                continue;\n\t            }\n\t            var curr = getPath(commands[i]);\n\t            var next = (i < commands.length - 1) ? commands[i + 1] : null;\n\t            if (curr && next && isMatrixParams(next)) {\n\t                paths.push(new UrlSegment(curr, stringify(next)));\n\t                i += 2;\n\t            }\n\t            else {\n\t                paths.push(new UrlSegment(curr, {}));\n\t                i++;\n\t            }\n\t        }\n\t        return new UrlSegmentGroup(paths, {});\n\t    }\n\t    function createNewSegmentChldren(outlets) {\n\t        var children = {};\n\t        forEach(outlets, function (commands, outlet) {\n\t            if (commands !== null) {\n\t                children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n\t            }\n\t        });\n\t        return children;\n\t    }\n\t    function stringify(params) {\n\t        var res = {};\n\t        forEach(params, function (v, k) { return res[k] = \"\" + v; });\n\t        return res;\n\t    }\n\t    function compare(path, params, segment) {\n\t        return path == segment.path && shallowEqual(params, segment.parameters);\n\t    }\n\t\n\t    var NoMatch$1 = (function () {\n\t        function NoMatch() {\n\t        }\n\t        return NoMatch;\n\t    }());\n\t    function recognize(rootComponentType, config, urlTree, url) {\n\t        return new Recognizer(rootComponentType, config, urlTree, url).recognize();\n\t    }\n\t    var Recognizer = (function () {\n\t        function Recognizer(rootComponentType, config, urlTree, url) {\n\t            this.rootComponentType = rootComponentType;\n\t            this.config = config;\n\t            this.urlTree = urlTree;\n\t            this.url = url;\n\t        }\n\t        Recognizer.prototype.recognize = function () {\n\t            try {\n\t                var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;\n\t                var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n\t                var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n\t                var rootNode = new TreeNode(root, children);\n\t                var routeState = new RouterStateSnapshot(this.url, rootNode);\n\t                this.inheriteParamsAndData(routeState._root);\n\t                return rxjs_observable_of.of(routeState);\n\t            }\n\t            catch (e) {\n\t                return new rxjs_Observable.Observable(function (obs) { return obs.error(e); });\n\t            }\n\t        };\n\t        Recognizer.prototype.inheriteParamsAndData = function (routeNode) {\n\t            var _this = this;\n\t            var route = routeNode.value;\n\t            var i = inheritedParamsDataResolve(route);\n\t            route.params = Object.freeze(i.params);\n\t            route.data = Object.freeze(i.data);\n\t            routeNode.children.forEach(function (n) { return _this.inheriteParamsAndData(n); });\n\t        };\n\t        Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {\n\t            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n\t                return this.processChildren(config, segmentGroup);\n\t            }\n\t            else {\n\t                return this.processSegment(config, segmentGroup, 0, segmentGroup.segments, outlet);\n\t            }\n\t        };\n\t        Recognizer.prototype.processChildren = function (config, segmentGroup) {\n\t            var _this = this;\n\t            var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\n\t            checkOutletNameUniqueness(children);\n\t            sortActivatedRouteSnapshots(children);\n\t            return children;\n\t        };\n\t        Recognizer.prototype.processSegment = function (config, segmentGroup, pathIndex, segments, outlet) {\n\t            for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {\n\t                var r = config_1[_i];\n\t                try {\n\t                    return this.processSegmentAgainstRoute(r, segmentGroup, pathIndex, segments, outlet);\n\t                }\n\t                catch (e) {\n\t                    if (!(e instanceof NoMatch$1))\n\t                        throw e;\n\t                }\n\t            }\n\t            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n\t                return [];\n\t            }\n\t            else {\n\t                throw new NoMatch$1();\n\t            }\n\t        };\n\t        Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\n\t            return segments.length === 0 && !segmentGroup.children[outlet];\n\t        };\n\t        Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, pathIndex, segments, outlet) {\n\t            if (route.redirectTo)\n\t                throw new NoMatch$1();\n\t            if ((route.outlet ? route.outlet : PRIMARY_OUTLET) !== outlet)\n\t                throw new NoMatch$1();\n\t            if (route.path === '**') {\n\t                var params = segments.length > 0 ? last(segments).parameters : {};\n\t                var snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n\t                return [new TreeNode(snapshot_1, [])];\n\t            }\n\t            var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;\n\t            var rawSlicedSegments = segments.slice(lastChild);\n\t            var childConfig = getChildConfig(route);\n\t            var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;\n\t            var snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n\t            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n\t                var children = this.processChildren(childConfig, segmentGroup);\n\t                return [new TreeNode(snapshot, children)];\n\t            }\n\t            else if (childConfig.length === 0 && slicedSegments.length === 0) {\n\t                return [new TreeNode(snapshot, [])];\n\t            }\n\t            else {\n\t                var children = this.processSegment(childConfig, segmentGroup, pathIndex + lastChild, slicedSegments, PRIMARY_OUTLET);\n\t                return [new TreeNode(snapshot, children)];\n\t            }\n\t        };\n\t        return Recognizer;\n\t    }());\n\t    function sortActivatedRouteSnapshots(nodes) {\n\t        nodes.sort(function (a, b) {\n\t            if (a.value.outlet === PRIMARY_OUTLET)\n\t                return -1;\n\t            if (b.value.outlet === PRIMARY_OUTLET)\n\t                return 1;\n\t            return a.value.outlet.localeCompare(b.value.outlet);\n\t        });\n\t    }\n\t    function getChildConfig(route) {\n\t        if (route.children) {\n\t            return route.children;\n\t        }\n\t        else if (route.loadChildren) {\n\t            return route._loadedConfig.routes;\n\t        }\n\t        else {\n\t            return [];\n\t        }\n\t    }\n\t    function match$1(segmentGroup, route, segments) {\n\t        if (route.path === '') {\n\t            if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n\t                throw new NoMatch$1();\n\t            }\n\t            else {\n\t                return { consumedSegments: [], lastChild: 0, parameters: {} };\n\t            }\n\t        }\n\t        var matcher = route.matcher || defaultUrlMatcher;\n\t        var res = matcher(segments, segmentGroup, route);\n\t        if (!res)\n\t            throw new NoMatch$1();\n\t        var posParams = {};\n\t        forEach(res.posParams, function (v, k) { posParams[k] = v.path; });\n\t        var parameters = merge(posParams, res.consumed[res.consumed.length - 1].parameters);\n\t        return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };\n\t    }\n\t    function checkOutletNameUniqueness(nodes) {\n\t        var names = {};\n\t        nodes.forEach(function (n) {\n\t            var routeWithSameOutletName = names[n.value.outlet];\n\t            if (routeWithSameOutletName) {\n\t                var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');\n\t                var c = n.value.url.map(function (s) { return s.toString(); }).join('/');\n\t                throw new Error(\"Two segments cannot have the same outlet name: '\" + p + \"' and '\" + c + \"'.\");\n\t            }\n\t            names[n.value.outlet] = n.value;\n\t        });\n\t    }\n\t    function getSourceSegmentGroup(segmentGroup) {\n\t        var s = segmentGroup;\n\t        while (s._sourceSegment) {\n\t            s = s._sourceSegment;\n\t        }\n\t        return s;\n\t    }\n\t    function getPathIndexShift(segmentGroup) {\n\t        var s = segmentGroup;\n\t        var res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n\t        while (s._sourceSegment) {\n\t            s = s._sourceSegment;\n\t            res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n\t        }\n\t        return res - 1;\n\t    }\n\t    function split$1(segmentGroup, consumedSegments, slicedSegments, config) {\n\t        if (slicedSegments.length > 0 &&\n\t            containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n\t            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\t            s._sourceSegment = segmentGroup;\n\t            s._segmentIndexShift = consumedSegments.length;\n\t            return { segmentGroup: s, slicedSegments: [] };\n\t        }\n\t        else if (slicedSegments.length === 0 &&\n\t            containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n\t            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\t            s._sourceSegment = segmentGroup;\n\t            s._segmentIndexShift = consumedSegments.length;\n\t            return { segmentGroup: s, slicedSegments: slicedSegments };\n\t        }\n\t        else {\n\t            var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n\t            s._sourceSegment = segmentGroup;\n\t            s._segmentIndexShift = consumedSegments.length;\n\t            return { segmentGroup: s, slicedSegments: slicedSegments };\n\t        }\n\t    }\n\t    function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n\t        var res = {};\n\t        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n\t            var r = routes_1[_i];\n\t            if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$2(r)]) {\n\t                var s = new UrlSegmentGroup([], {});\n\t                s._sourceSegment = segmentGroup;\n\t                s._segmentIndexShift = segmentGroup.segments.length;\n\t                res[getOutlet$2(r)] = s;\n\t            }\n\t        }\n\t        return merge(children, res);\n\t    }\n\t    function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n\t        var res = {};\n\t        res[PRIMARY_OUTLET] = primarySegment;\n\t        primarySegment._sourceSegment = segmentGroup;\n\t        primarySegment._segmentIndexShift = consumedSegments.length;\n\t        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n\t            var r = routes_2[_i];\n\t            if (r.path === '' && getOutlet$2(r) !== PRIMARY_OUTLET) {\n\t                var s = new UrlSegmentGroup([], {});\n\t                s._sourceSegment = segmentGroup;\n\t                s._segmentIndexShift = consumedSegments.length;\n\t                res[getOutlet$2(r)] = s;\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n\t        return routes\n\t            .filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) &&\n\t            getOutlet$2(r) !== PRIMARY_OUTLET; })\n\t            .length > 0;\n\t    }\n\t    function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n\t        return routes.filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); }).length > 0;\n\t    }\n\t    function emptyPathMatch(segmentGroup, slicedSegments, r) {\n\t        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n\t            return false;\n\t        return r.path === '' && r.redirectTo === undefined;\n\t    }\n\t    function getOutlet$2(route) {\n\t        return route.outlet ? route.outlet : PRIMARY_OUTLET;\n\t    }\n\t    function getData(route) {\n\t        return route.data ? route.data : {};\n\t    }\n\t    function getResolve(route) {\n\t        return route.resolve ? route.resolve : {};\n\t    }\n\t\n\t    /**\n\t     * @license\n\t     * Copyright Google Inc. All Rights Reserved.\n\t     *\n\t     * Use of this source code is governed by an MIT-style license that can be\n\t     * found in the LICENSE file at https://angular.io/license\n\t     */\n\t    /**\n\t     * @whatItDoes Contains all the router outlets created in a component.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterOutletMap = (function () {\n\t        function RouterOutletMap() {\n\t            /** @internal */\n\t            this._outlets = {};\n\t        }\n\t        /**\n\t         * Adds an outlet to this map.\n\t         */\n\t        RouterOutletMap.prototype.registerOutlet = function (name, outlet) { this._outlets[name] = outlet; };\n\t        /**\n\t         * Removes an outlet from this map.\n\t         */\n\t        RouterOutletMap.prototype.removeOutlet = function (name) { this._outlets[name] = undefined; };\n\t        return RouterOutletMap;\n\t    }());\n\t\n\t    /**\n\t     * @license\n\t     * Copyright Google Inc. All Rights Reserved.\n\t     *\n\t     * Use of this source code is governed by an MIT-style license that can be\n\t     * found in the LICENSE file at https://angular.io/license\n\t     */\n\t    /**\n\t     * @whatItDoes Provides a way to migrate Angular 1 applications to Angular 2.\n\t     *\n\t     * @experimental\n\t     */\n\t    var UrlHandlingStrategy = (function () {\n\t        function UrlHandlingStrategy() {\n\t        }\n\t        return UrlHandlingStrategy;\n\t    }());\n\t    /**\n\t     * @experimental\n\t     */\n\t    var DefaultUrlHandlingStrategy = (function () {\n\t        function DefaultUrlHandlingStrategy() {\n\t        }\n\t        DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };\n\t        DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };\n\t        DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };\n\t        return DefaultUrlHandlingStrategy;\n\t    }());\n\t\n\t    /**\n\t     * @whatItDoes Represents an event triggered when a navigation starts.\n\t     *\n\t     * @stable\n\t     */\n\t    var NavigationStart = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function NavigationStart(\n\t            /** @docsNotRequired */\n\t            id, \n\t            /** @docsNotRequired */\n\t            url) {\n\t            this.id = id;\n\t            this.url = url;\n\t        }\n\t        /** @docsNotRequired */\n\t        NavigationStart.prototype.toString = function () { return \"NavigationStart(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n\t        return NavigationStart;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents an event triggered when a navigation ends successfully.\n\t     *\n\t     * @stable\n\t     */\n\t    var NavigationEnd = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function NavigationEnd(\n\t            /** @docsNotRequired */\n\t            id, \n\t            /** @docsNotRequired */\n\t            url, \n\t            /** @docsNotRequired */\n\t            urlAfterRedirects) {\n\t            this.id = id;\n\t            this.url = url;\n\t            this.urlAfterRedirects = urlAfterRedirects;\n\t        }\n\t        /** @docsNotRequired */\n\t        NavigationEnd.prototype.toString = function () {\n\t            return \"NavigationEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"')\";\n\t        };\n\t        return NavigationEnd;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents an event triggered when a navigation is canceled.\n\t     *\n\t     * @stable\n\t     */\n\t    var NavigationCancel = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function NavigationCancel(\n\t            /** @docsNotRequired */\n\t            id, \n\t            /** @docsNotRequired */\n\t            url, \n\t            /** @docsNotRequired */\n\t            reason) {\n\t            this.id = id;\n\t            this.url = url;\n\t            this.reason = reason;\n\t        }\n\t        /** @docsNotRequired */\n\t        NavigationCancel.prototype.toString = function () { return \"NavigationCancel(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n\t        return NavigationCancel;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.\n\t     *\n\t     * @stable\n\t     */\n\t    var NavigationError = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function NavigationError(\n\t            /** @docsNotRequired */\n\t            id, \n\t            /** @docsNotRequired */\n\t            url, \n\t            /** @docsNotRequired */\n\t            error) {\n\t            this.id = id;\n\t            this.url = url;\n\t            this.error = error;\n\t        }\n\t        /** @docsNotRequired */\n\t        NavigationError.prototype.toString = function () {\n\t            return \"NavigationError(id: \" + this.id + \", url: '\" + this.url + \"', error: \" + this.error + \")\";\n\t        };\n\t        return NavigationError;\n\t    }());\n\t    /**\n\t     * @whatItDoes Represents an event triggered when routes are recognized.\n\t     *\n\t     * @stable\n\t     */\n\t    var RoutesRecognized = (function () {\n\t        // TODO: vsavkin: make internal\n\t        function RoutesRecognized(\n\t            /** @docsNotRequired */\n\t            id, \n\t            /** @docsNotRequired */\n\t            url, \n\t            /** @docsNotRequired */\n\t            urlAfterRedirects, \n\t            /** @docsNotRequired */\n\t            state) {\n\t            this.id = id;\n\t            this.url = url;\n\t            this.urlAfterRedirects = urlAfterRedirects;\n\t            this.state = state;\n\t        }\n\t        /** @docsNotRequired */\n\t        RoutesRecognized.prototype.toString = function () {\n\t            return \"RoutesRecognized(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n\t        };\n\t        return RoutesRecognized;\n\t    }());\n\t    function defaultErrorHandler(error) {\n\t        throw error;\n\t    }\n\t    /**\n\t     * @whatItDoes Provides the navigation and url manipulation capabilities.\n\t     *\n\t     * See {@link Routes} for more details and examples.\n\t     *\n\t     * @ngModule RouterModule\n\t     *\n\t     * @stable\n\t     */\n\t    var Router = (function () {\n\t        /**\n\t         * Creates the router service.\n\t         */\n\t        // TODO: vsavkin make internal after the final is out.\n\t        function Router(rootComponentType, urlSerializer, outletMap, location, injector, loader, compiler, config) {\n\t            this.rootComponentType = rootComponentType;\n\t            this.urlSerializer = urlSerializer;\n\t            this.outletMap = outletMap;\n\t            this.location = location;\n\t            this.injector = injector;\n\t            this.config = config;\n\t            this.navigations = new rxjs_BehaviorSubject.BehaviorSubject(null);\n\t            this.routerEvents = new rxjs_Subject.Subject();\n\t            this.navigationId = 0;\n\t            /**\n\t             * Error handler that is invoked when a navigation errors.\n\t             *\n\t             * See {@link ErrorHandler} for more information.\n\t             */\n\t            this.errorHandler = defaultErrorHandler;\n\t            /**\n\t             * Indicates if at least one navigation happened.\n\t             */\n\t            this.navigated = false;\n\t            /**\n\t             * Extracts and merges URLs. Used for Angular 1 to Angular 2 migrations.\n\t             */\n\t            this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n\t            this.resetConfig(config);\n\t            this.currentUrlTree = createEmptyUrlTree();\n\t            this.rawUrlTree = this.currentUrlTree;\n\t            this.configLoader = new RouterConfigLoader(loader, compiler);\n\t            this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n\t            this.processNavigations();\n\t        }\n\t        /**\n\t         * @internal\n\t         * TODO: this should be removed once the constructor of the router made internal\n\t         */\n\t        Router.prototype.resetRootComponentType = function (rootComponentType) {\n\t            this.rootComponentType = rootComponentType;\n\t            // TODO: vsavkin router 4.0 should make the root component set to null\n\t            // this will simplify the lifecycle of the router.\n\t            this.currentRouterState.root.component = this.rootComponentType;\n\t        };\n\t        /**\n\t         * Sets up the location change listener and performs the initial navigation.\n\t         */\n\t        Router.prototype.initialNavigation = function () {\n\t            this.setUpLocationChangeListener();\n\t            this.navigateByUrl(this.location.path(true), { replaceUrl: true });\n\t        };\n\t        /**\n\t         * Sets up the location change listener.\n\t         */\n\t        Router.prototype.setUpLocationChangeListener = function () {\n\t            var _this = this;\n\t            // Zone.current.wrap is needed because of the issue with RxJS scheduler,\n\t            // which does not work properly with zone.js in IE and Safari\n\t            this.locationSubscription = this.location.subscribe(Zone.current.wrap(function (change) {\n\t                var rawUrlTree = _this.urlSerializer.parse(change['url']);\n\t                setTimeout(function () {\n\t                    _this.scheduleNavigation(rawUrlTree, { skipLocationChange: change['pop'], replaceUrl: true });\n\t                }, 0);\n\t            }));\n\t        };\n\t        Object.defineProperty(Router.prototype, \"routerState\", {\n\t            /**\n\t             * Returns the current route state.\n\t             */\n\t            get: function () { return this.currentRouterState; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(Router.prototype, \"url\", {\n\t            /**\n\t             * Returns the current url.\n\t             */\n\t            get: function () { return this.serializeUrl(this.currentUrlTree); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(Router.prototype, \"events\", {\n\t            /**\n\t             * Returns an observable of route events\n\t             */\n\t            get: function () { return this.routerEvents; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * Resets the configuration used for navigation and generating links.\n\t         *\n\t         * ### Usage\n\t         *\n\t         * ```\n\t         * router.resetConfig([\n\t         *  { path: 'team/:id', component: TeamCmp, children: [\n\t         *    { path: 'simple', component: SimpleCmp },\n\t         *    { path: 'user/:name', component: UserCmp }\n\t         *  ] }\n\t         * ]);\n\t         * ```\n\t         */\n\t        Router.prototype.resetConfig = function (config) {\n\t            validateConfig(config);\n\t            this.config = config;\n\t        };\n\t        /**\n\t         * @docsNotRequired\n\t         */\n\t        Router.prototype.ngOnDestroy = function () { this.dispose(); };\n\t        /**\n\t         * Disposes of the router.\n\t         */\n\t        Router.prototype.dispose = function () { this.locationSubscription.unsubscribe(); };\n\t        /**\n\t         * Applies an array of commands to the current url tree and creates a new url tree.\n\t         *\n\t         * When given an activate route, applies the given commands starting from the route.\n\t         * When not given a route, applies the given command starting from the root.\n\t         *\n\t         * ### Usage\n\t         *\n\t         * ```\n\t         * // create /team/33/user/11\n\t         * router.createUrlTree(['/team', 33, 'user', 11]);\n\t         *\n\t         * // create /team/33;expand=true/user/11\n\t         * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n\t         *\n\t         * // you can collapse static segments like this (this works only with the first passed-in value):\n\t         * router.createUrlTree(['/team/33/user', userId]);\n\t         *\n\t         * // If the first segment can contain slashes, and you do not want the router to split it, you\n\t         * // can do the following:\n\t         *\n\t         * router.createUrlTree([{segmentPath: '/one/two'}]);\n\t         *\n\t         * // create /team/33/(user/11//right:chat)\n\t         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n\t         *\n\t         * // remove the right secondary node\n\t         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n\t         *\n\t         * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n\t         *\n\t         * // navigate to /team/33/user/11/details\n\t         * router.createUrlTree(['details'], {relativeTo: route});\n\t         *\n\t         * // navigate to /team/33/user/22\n\t         * router.createUrlTree(['../22'], {relativeTo: route});\n\t         *\n\t         * // navigate to /team/44/user/22\n\t         * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n\t         * ```\n\t         */\n\t        Router.prototype.createUrlTree = function (commands, _a) {\n\t            var _b = _a === void 0 ? {} : _a, relativeTo = _b.relativeTo, queryParams = _b.queryParams, fragment = _b.fragment, preserveQueryParams = _b.preserveQueryParams, preserveFragment = _b.preserveFragment;\n\t            var a = relativeTo ? relativeTo : this.routerState.root;\n\t            var q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams;\n\t            var f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n\t            return createUrlTree(a, this.currentUrlTree, commands, q, f);\n\t        };\n\t        /**\n\t         * Navigate based on the provided url. This navigation is always absolute.\n\t         *\n\t         * Returns a promise that:\n\t         * - is resolved with 'true' when navigation succeeds\n\t         * - is resolved with 'false' when navigation fails\n\t         * - is rejected when an error happens\n\t         *\n\t         * ### Usage\n\t         *\n\t         * ```\n\t         * router.navigateByUrl(\"/team/33/user/11\");\n\t         *\n\t         * // Navigate without updating the URL\n\t         * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n\t         * ```\n\t         *\n\t         * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n\t         * and does not apply any delta to the current one.\n\t         */\n\t        Router.prototype.navigateByUrl = function (url, extras) {\n\t            if (extras === void 0) { extras = { skipLocationChange: false }; }\n\t            if (url instanceof UrlTree) {\n\t                return this.scheduleNavigation(this.urlHandlingStrategy.merge(url, this.rawUrlTree), extras);\n\t            }\n\t            else {\n\t                var urlTree = this.urlSerializer.parse(url);\n\t                return this.scheduleNavigation(this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree), extras);\n\t            }\n\t        };\n\t        /**\n\t         * Navigate based on the provided array of commands and a starting point.\n\t         * If no starting route is provided, the navigation is absolute.\n\t         *\n\t         * Returns a promise that:\n\t         * - is resolved with 'true' when navigation succeeds\n\t         * - is resolved with 'false' when navigation fails\n\t         * - is rejected when an error happens\n\t         *\n\t         * ### Usage\n\t         *\n\t         * ```\n\t         * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n\t         *\n\t         * // Navigate without updating the URL\n\t         * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true });\n\t         * ```\n\t         *\n\t         * In opposite to `navigateByUrl`, `navigate` always takes a delta\n\t         * that is applied to the current URL.\n\t         */\n\t        Router.prototype.navigate = function (commands, extras) {\n\t            if (extras === void 0) { extras = { skipLocationChange: false }; }\n\t            if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {\n\t                extras.queryParams = this.removeEmptyProps(extras.queryParams);\n\t            }\n\t            return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n\t        };\n\t        /**\n\t         * Serializes a {@link UrlTree} into a string.\n\t         */\n\t        Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };\n\t        /**\n\t         * Parses a string into a {@link UrlTree}.\n\t         */\n\t        Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };\n\t        /**\n\t         * Returns if the url is activated or not.\n\t         */\n\t        Router.prototype.isActive = function (url, exact) {\n\t            if (url instanceof UrlTree) {\n\t                return containsTree(this.currentUrlTree, url, exact);\n\t            }\n\t            else {\n\t                var urlTree = this.urlSerializer.parse(url);\n\t                return containsTree(this.currentUrlTree, urlTree, exact);\n\t            }\n\t        };\n\t        Router.prototype.removeEmptyProps = function (params) {\n\t            return Object.keys(params).reduce(function (result, key) {\n\t                var value = params[key];\n\t                if (value !== null && value !== undefined) {\n\t                    result[key] = value;\n\t                }\n\t                return result;\n\t            }, {});\n\t        };\n\t        Router.prototype.processNavigations = function () {\n\t            var _this = this;\n\t            rxjs_operator_concatMap.concatMap\n\t                .call(this.navigations, function (nav) {\n\t                if (nav) {\n\t                    _this.executeScheduledNavigation(nav);\n\t                    // a failed navigation should not stop the router from processing\n\t                    // further navigations => the catch\n\t                    return nav.promise.catch(function () { });\n\t                }\n\t                else {\n\t                    return rxjs_observable_of.of(null);\n\t                }\n\t            })\n\t                .subscribe(function () { });\n\t        };\n\t        Router.prototype.scheduleNavigation = function (rawUrl, extras) {\n\t            var prevRawUrl = this.navigations.value ? this.navigations.value.rawUrl : null;\n\t            if (prevRawUrl && prevRawUrl.toString() === rawUrl.toString()) {\n\t                return this.navigations.value.promise;\n\t            }\n\t            var resolve = null;\n\t            var reject = null;\n\t            var promise = new Promise(function (res, rej) {\n\t                resolve = res;\n\t                reject = rej;\n\t            });\n\t            var id = ++this.navigationId;\n\t            this.navigations.next({ id: id, rawUrl: rawUrl, prevRawUrl: prevRawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });\n\t            // Make sure that the error is propagated even though `processNavigations` catch\n\t            // handler does not rethrow\n\t            return promise.catch(function (e) { return Promise.reject(e); });\n\t        };\n\t        Router.prototype.executeScheduledNavigation = function (_a) {\n\t            var _this = this;\n\t            var id = _a.id, rawUrl = _a.rawUrl, prevRawUrl = _a.prevRawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;\n\t            var url = this.urlHandlingStrategy.extract(rawUrl);\n\t            var prevUrl = prevRawUrl ? this.urlHandlingStrategy.extract(prevRawUrl) : null;\n\t            var urlTransition = !prevUrl || url.toString() !== prevUrl.toString();\n\t            if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n\t                this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n\t                Promise.resolve()\n\t                    .then(function (_) { return _this.runNavigate(url, rawUrl, extras.skipLocationChange, extras.replaceUrl, id, null); })\n\t                    .then(resolve, reject);\n\t            }\n\t            else if (urlTransition && prevRawUrl && this.urlHandlingStrategy.shouldProcessUrl(prevRawUrl)) {\n\t                this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n\t                Promise.resolve()\n\t                    .then(function (_) { return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot); })\n\t                    .then(resolve, reject);\n\t            }\n\t            else {\n\t                this.rawUrlTree = rawUrl;\n\t                resolve(null);\n\t            }\n\t        };\n\t        Router.prototype.runNavigate = function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {\n\t            var _this = this;\n\t            if (id !== this.navigationId) {\n\t                this.location.go(this.urlSerializer.serialize(this.currentUrlTree));\n\t                this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \" + id + \" is not equal to the current navigation id \" + this.navigationId));\n\t                return Promise.resolve(false);\n\t            }\n\t            return new Promise(function (resolvePromise, rejectPromise) {\n\t                // create an observable of the url and route state snapshot\n\t                // this operation do not result in any side effects\n\t                var urlAndSnapshot$;\n\t                if (!precreatedState) {\n\t                    var redirectsApplied$ = applyRedirects(_this.injector, _this.configLoader, _this.urlSerializer, url, _this.config);\n\t                    urlAndSnapshot$ = rxjs_operator_mergeMap.mergeMap.call(redirectsApplied$, function (appliedUrl) {\n\t                        return rxjs_operator_map.map.call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {\n\t                            _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));\n\t                            return { appliedUrl: appliedUrl, snapshot: snapshot };\n\t                        });\n\t                    });\n\t                }\n\t                else {\n\t                    urlAndSnapshot$ = rxjs_observable_of.of({ appliedUrl: url, snapshot: precreatedState });\n\t                }\n\t                // run preactivation: guards and data resolvers\n\t                var preActivation;\n\t                var preactivationTraverse$ = rxjs_operator_map.map.call(urlAndSnapshot$, function (_a) {\n\t                    var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n\t                    preActivation =\n\t                        new PreActivation(snapshot, _this.currentRouterState.snapshot, _this.injector);\n\t                    preActivation.traverse(_this.outletMap);\n\t                    return { appliedUrl: appliedUrl, snapshot: snapshot };\n\t                });\n\t                var preactivationCheckGuards = rxjs_operator_mergeMap.mergeMap.call(preactivationTraverse$, function (_a) {\n\t                    var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n\t                    if (_this.navigationId !== id)\n\t                        return rxjs_observable_of.of(false);\n\t                    return rxjs_operator_map.map.call(preActivation.checkGuards(), function (shouldActivate) {\n\t                        return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };\n\t                    });\n\t                });\n\t                var preactivationResolveData$ = rxjs_operator_mergeMap.mergeMap.call(preactivationCheckGuards, function (p) {\n\t                    if (_this.navigationId !== id)\n\t                        return rxjs_observable_of.of(false);\n\t                    if (p.shouldActivate) {\n\t                        return rxjs_operator_map.map.call(preActivation.resolveData(), function () { return p; });\n\t                    }\n\t                    else {\n\t                        return rxjs_observable_of.of(p);\n\t                    }\n\t                });\n\t                // create router state\n\t                // this operation has side effects => route state is being affected\n\t                var routerState$ = rxjs_operator_map.map.call(preactivationResolveData$, function (_a) {\n\t                    var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;\n\t                    if (shouldActivate) {\n\t                        var state = createRouterState(snapshot, _this.currentRouterState);\n\t                        return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };\n\t                    }\n\t                    else {\n\t                        return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };\n\t                    }\n\t                });\n\t                // applied the new router state\n\t                // this operation has side effects\n\t                var navigationIsSuccessful;\n\t                var storedState = _this.currentRouterState;\n\t                var storedUrl = _this.currentUrlTree;\n\t                routerState$\n\t                    .forEach(function (_a) {\n\t                    var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;\n\t                    if (!shouldActivate || id !== _this.navigationId) {\n\t                        navigationIsSuccessful = false;\n\t                        return;\n\t                    }\n\t                    _this.currentUrlTree = appliedUrl;\n\t                    _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n\t                    _this.currentRouterState = state;\n\t                    if (!shouldPreventPushState) {\n\t                        var path = _this.urlSerializer.serialize(_this.rawUrlTree);\n\t                        if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {\n\t                            _this.location.replaceState(path);\n\t                        }\n\t                        else {\n\t                            _this.location.go(path);\n\t                        }\n\t                    }\n\t                    new ActivateRoutes(state, storedState).activate(_this.outletMap);\n\t                    navigationIsSuccessful = true;\n\t                })\n\t                    .then(function () {\n\t                    _this.navigated = true;\n\t                    if (navigationIsSuccessful) {\n\t                        _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));\n\t                        resolvePromise(true);\n\t                    }\n\t                    else {\n\t                        _this.resetUrlToCurrentUrlTree();\n\t                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));\n\t                        resolvePromise(false);\n\t                    }\n\t                }, function (e) {\n\t                    if (e instanceof NavigationCancelingError) {\n\t                        _this.resetUrlToCurrentUrlTree();\n\t                        _this.navigated = true;\n\t                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));\n\t                        resolvePromise(false);\n\t                    }\n\t                    else {\n\t                        _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));\n\t                        try {\n\t                            resolvePromise(_this.errorHandler(e));\n\t                        }\n\t                        catch (ee) {\n\t                            rejectPromise(ee);\n\t                        }\n\t                    }\n\t                    _this.currentRouterState = storedState;\n\t                    _this.currentUrlTree = storedUrl;\n\t                    _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n\t                    _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));\n\t                });\n\t            });\n\t        };\n\t        Router.prototype.resetUrlToCurrentUrlTree = function () {\n\t            var path = this.urlSerializer.serialize(this.rawUrlTree);\n\t            this.location.replaceState(path);\n\t        };\n\t        return Router;\n\t    }());\n\t    var CanActivate = (function () {\n\t        function CanActivate(path) {\n\t            this.path = path;\n\t        }\n\t        Object.defineProperty(CanActivate.prototype, \"route\", {\n\t            get: function () { return this.path[this.path.length - 1]; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        return CanActivate;\n\t    }());\n\t    var CanDeactivate = (function () {\n\t        function CanDeactivate(component, route) {\n\t            this.component = component;\n\t            this.route = route;\n\t        }\n\t        return CanDeactivate;\n\t    }());\n\t    var PreActivation = (function () {\n\t        function PreActivation(future, curr, injector) {\n\t            this.future = future;\n\t            this.curr = curr;\n\t            this.injector = injector;\n\t            this.checks = [];\n\t        }\n\t        PreActivation.prototype.traverse = function (parentOutletMap) {\n\t            var futureRoot = this.future._root;\n\t            var currRoot = this.curr ? this.curr._root : null;\n\t            this.traverseChildRoutes(futureRoot, currRoot, parentOutletMap, [futureRoot.value]);\n\t        };\n\t        PreActivation.prototype.checkGuards = function () {\n\t            var _this = this;\n\t            if (this.checks.length === 0)\n\t                return rxjs_observable_of.of(true);\n\t            var checks$ = rxjs_observable_from.from(this.checks);\n\t            var runningChecks$ = rxjs_operator_mergeMap.mergeMap.call(checks$, function (s) {\n\t                if (s instanceof CanActivate) {\n\t                    return andObservables(rxjs_observable_from.from([_this.runCanActivateChild(s.path), _this.runCanActivate(s.route)]));\n\t                }\n\t                else if (s instanceof CanDeactivate) {\n\t                    // workaround https://github.com/Microsoft/TypeScript/issues/7271\n\t                    var s2 = s;\n\t                    return _this.runCanDeactivate(s2.component, s2.route);\n\t                }\n\t                else {\n\t                    throw new Error('Cannot be reached');\n\t                }\n\t            });\n\t            return rxjs_operator_every.every.call(runningChecks$, function (result) { return result === true; });\n\t        };\n\t        PreActivation.prototype.resolveData = function () {\n\t            var _this = this;\n\t            if (this.checks.length === 0)\n\t                return rxjs_observable_of.of(null);\n\t            var checks$ = rxjs_observable_from.from(this.checks);\n\t            var runningChecks$ = rxjs_operator_concatMap.concatMap.call(checks$, function (s) {\n\t                if (s instanceof CanActivate) {\n\t                    return _this.runResolve(s.route);\n\t                }\n\t                else {\n\t                    return rxjs_observable_of.of(null);\n\t                }\n\t            });\n\t            return rxjs_operator_reduce.reduce.call(runningChecks$, function (_, __) { return _; });\n\t        };\n\t        PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, outletMap, futurePath) {\n\t            var _this = this;\n\t            var prevChildren = nodeChildrenAsMap(currNode);\n\t            futureNode.children.forEach(function (c) {\n\t                _this.traverseRoutes(c, prevChildren[c.value.outlet], outletMap, futurePath.concat([c.value]));\n\t                delete prevChildren[c.value.outlet];\n\t            });\n\t            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap._outlets[k]); });\n\t        };\n\t        PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentOutletMap, futurePath) {\n\t            var future = futureNode.value;\n\t            var curr = currNode ? currNode.value : null;\n\t            var outlet = parentOutletMap ? parentOutletMap._outlets[futureNode.value.outlet] : null;\n\t            // reusing the node\n\t            if (curr && future._routeConfig === curr._routeConfig) {\n\t                if (!equalParamsAndUrlSegments(future, curr)) {\n\t                    this.checks.push(new CanDeactivate(outlet.component, curr), new CanActivate(futurePath));\n\t                }\n\t                else {\n\t                    // we need to set the data\n\t                    future.data = curr.data;\n\t                    future._resolvedData = curr._resolvedData;\n\t                }\n\t                // If we have a component, we need to go through an outlet.\n\t                if (future.component) {\n\t                    this.traverseChildRoutes(futureNode, currNode, outlet ? outlet.outletMap : null, futurePath);\n\t                }\n\t                else {\n\t                    this.traverseChildRoutes(futureNode, currNode, parentOutletMap, futurePath);\n\t                }\n\t            }\n\t            else {\n\t                if (curr) {\n\t                    this.deactiveRouteAndItsChildren(currNode, outlet);\n\t                }\n\t                this.checks.push(new CanActivate(futurePath));\n\t                // If we have a component, we need to go through an outlet.\n\t                if (future.component) {\n\t                    this.traverseChildRoutes(futureNode, null, outlet ? outlet.outletMap : null, futurePath);\n\t                }\n\t                else {\n\t                    this.traverseChildRoutes(futureNode, null, parentOutletMap, futurePath);\n\t                }\n\t            }\n\t        };\n\t        PreActivation.prototype.deactiveRouteAndItsChildren = function (route, outlet) {\n\t            var _this = this;\n\t            var prevChildren = nodeChildrenAsMap(route);\n\t            var r = route.value;\n\t            forEach(prevChildren, function (v, k) {\n\t                if (!r.component) {\n\t                    _this.deactiveRouteAndItsChildren(v, outlet);\n\t                }\n\t                else if (!!outlet) {\n\t                    _this.deactiveRouteAndItsChildren(v, outlet.outletMap._outlets[k]);\n\t                }\n\t                else {\n\t                    _this.deactiveRouteAndItsChildren(v, null);\n\t                }\n\t            });\n\t            if (!r.component) {\n\t                this.checks.push(new CanDeactivate(null, r));\n\t            }\n\t            else if (outlet && outlet.isActivated) {\n\t                this.checks.push(new CanDeactivate(outlet.component, r));\n\t            }\n\t            else {\n\t                this.checks.push(new CanDeactivate(null, r));\n\t            }\n\t        };\n\t        PreActivation.prototype.runCanActivate = function (future) {\n\t            var _this = this;\n\t            var canActivate = future._routeConfig ? future._routeConfig.canActivate : null;\n\t            if (!canActivate || canActivate.length === 0)\n\t                return rxjs_observable_of.of(true);\n\t            var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canActivate), function (c) {\n\t                var guard = _this.getToken(c, future);\n\t                var observable;\n\t                if (guard.canActivate) {\n\t                    observable = wrapIntoObservable(guard.canActivate(future, _this.future));\n\t                }\n\t                else {\n\t                    observable = wrapIntoObservable(guard(future, _this.future));\n\t                }\n\t                return rxjs_operator_first.first.call(observable);\n\t            });\n\t            return andObservables(obs);\n\t        };\n\t        PreActivation.prototype.runCanActivateChild = function (path) {\n\t            var _this = this;\n\t            var future = path[path.length - 1];\n\t            var canActivateChildGuards = path.slice(0, path.length - 1)\n\t                .reverse()\n\t                .map(function (p) { return _this.extractCanActivateChild(p); })\n\t                .filter(function (_) { return _ !== null; });\n\t            return andObservables(rxjs_operator_map.map.call(rxjs_observable_from.from(canActivateChildGuards), function (d) {\n\t                var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(d.guards), function (c) {\n\t                    var guard = _this.getToken(c, c.node);\n\t                    var observable;\n\t                    if (guard.canActivateChild) {\n\t                        observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));\n\t                    }\n\t                    else {\n\t                        observable = wrapIntoObservable(guard(future, _this.future));\n\t                    }\n\t                    return rxjs_operator_first.first.call(observable);\n\t                });\n\t                return andObservables(obs);\n\t            }));\n\t        };\n\t        PreActivation.prototype.extractCanActivateChild = function (p) {\n\t            var canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;\n\t            if (!canActivateChild || canActivateChild.length === 0)\n\t                return null;\n\t            return { node: p, guards: canActivateChild };\n\t        };\n\t        PreActivation.prototype.runCanDeactivate = function (component, curr) {\n\t            var _this = this;\n\t            var canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;\n\t            if (!canDeactivate || canDeactivate.length === 0)\n\t                return rxjs_observable_of.of(true);\n\t            var canDeactivate$ = rxjs_operator_mergeMap.mergeMap.call(rxjs_observable_from.from(canDeactivate), function (c) {\n\t                var guard = _this.getToken(c, curr);\n\t                var observable;\n\t                if (guard.canDeactivate) {\n\t                    observable = wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr));\n\t                }\n\t                else {\n\t                    observable = wrapIntoObservable(guard(component, curr, _this.curr));\n\t                }\n\t                return rxjs_operator_first.first.call(observable);\n\t            });\n\t            return rxjs_operator_every.every.call(canDeactivate$, function (result) { return result === true; });\n\t        };\n\t        PreActivation.prototype.runResolve = function (future) {\n\t            var resolve = future._resolve;\n\t            return rxjs_operator_map.map.call(this.resolveNode(resolve, future), function (resolvedData) {\n\t                future._resolvedData = resolvedData;\n\t                future.data = merge(future.data, inheritedParamsDataResolve(future).resolve);\n\t                return null;\n\t            });\n\t        };\n\t        PreActivation.prototype.resolveNode = function (resolve, future) {\n\t            var _this = this;\n\t            return waitForMap(resolve, function (k, v) {\n\t                var resolver = _this.getToken(v, future);\n\t                return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, _this.future)) :\n\t                    wrapIntoObservable(resolver(future, _this.future));\n\t            });\n\t        };\n\t        PreActivation.prototype.getToken = function (token, snapshot) {\n\t            var config = closestLoadedConfig(snapshot);\n\t            var injector = config ? config.injector : this.injector;\n\t            return injector.get(token);\n\t        };\n\t        return PreActivation;\n\t    }());\n\t    var ActivateRoutes = (function () {\n\t        function ActivateRoutes(futureState, currState) {\n\t            this.futureState = futureState;\n\t            this.currState = currState;\n\t        }\n\t        ActivateRoutes.prototype.activate = function (parentOutletMap) {\n\t            var futureRoot = this.futureState._root;\n\t            var currRoot = this.currState ? this.currState._root : null;\n\t            this.deactivateChildRoutes(futureRoot, currRoot, parentOutletMap);\n\t            advanceActivatedRoute(this.futureState.root);\n\t            this.activateChildRoutes(futureRoot, currRoot, parentOutletMap);\n\t        };\n\t        ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, outletMap) {\n\t            var _this = this;\n\t            var prevChildren = nodeChildrenAsMap(currNode);\n\t            futureNode.children.forEach(function (c) {\n\t                _this.deactivateRoutes(c, prevChildren[c.value.outlet], outletMap);\n\t                delete prevChildren[c.value.outlet];\n\t            });\n\t            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap); });\n\t        };\n\t        ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, outletMap) {\n\t            var _this = this;\n\t            var prevChildren = nodeChildrenAsMap(currNode);\n\t            futureNode.children.forEach(function (c) { _this.activateRoutes(c, prevChildren[c.value.outlet], outletMap); });\n\t        };\n\t        ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentOutletMap) {\n\t            var future = futureNode.value;\n\t            var curr = currNode ? currNode.value : null;\n\t            // reusing the node\n\t            if (future === curr) {\n\t                // If we have a normal route, we need to go through an outlet.\n\t                if (future.component) {\n\t                    var outlet = getOutlet(parentOutletMap, future);\n\t                    this.deactivateChildRoutes(futureNode, currNode, outlet.outletMap);\n\t                }\n\t                else {\n\t                    this.deactivateChildRoutes(futureNode, currNode, parentOutletMap);\n\t                }\n\t            }\n\t            else {\n\t                if (curr) {\n\t                    this.deactiveRouteAndItsChildren(currNode, parentOutletMap);\n\t                }\n\t            }\n\t        };\n\t        ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentOutletMap) {\n\t            var future = futureNode.value;\n\t            var curr = currNode ? currNode.value : null;\n\t            // reusing the node\n\t            if (future === curr) {\n\t                // advance the route to push the parameters\n\t                advanceActivatedRoute(future);\n\t                // If we have a normal route, we need to go through an outlet.\n\t                if (future.component) {\n\t                    var outlet = getOutlet(parentOutletMap, future);\n\t                    this.activateChildRoutes(futureNode, currNode, outlet.outletMap);\n\t                }\n\t                else {\n\t                    this.activateChildRoutes(futureNode, currNode, parentOutletMap);\n\t                }\n\t            }\n\t            else {\n\t                // if we have a normal route, we need to advance the route\n\t                // and place the component into the outlet. After that recurse.\n\t                if (future.component) {\n\t                    advanceActivatedRoute(future);\n\t                    var outlet = getOutlet(parentOutletMap, futureNode.value);\n\t                    var outletMap = new RouterOutletMap();\n\t                    this.placeComponentIntoOutlet(outletMap, future, outlet);\n\t                    this.activateChildRoutes(futureNode, null, outletMap);\n\t                }\n\t                else {\n\t                    advanceActivatedRoute(future);\n\t                    this.activateChildRoutes(futureNode, null, parentOutletMap);\n\t                }\n\t            }\n\t        };\n\t        ActivateRoutes.prototype.placeComponentIntoOutlet = function (outletMap, future, outlet) {\n\t            var resolved = [{ provide: ActivatedRoute, useValue: future }, {\n\t                    provide: RouterOutletMap,\n\t                    useValue: outletMap\n\t                }];\n\t            var config = parentLoadedConfig(future.snapshot);\n\t            var resolver = null;\n\t            var injector = null;\n\t            if (config) {\n\t                injector = config.injectorFactory(outlet.locationInjector);\n\t                resolver = config.factoryResolver;\n\t                resolved.push({ provide: _angular_core.ComponentFactoryResolver, useValue: resolver });\n\t            }\n\t            else {\n\t                injector = outlet.locationInjector;\n\t                resolver = outlet.locationFactoryResolver;\n\t            }\n\t            outlet.activate(future, resolver, injector, _angular_core.ReflectiveInjector.resolve(resolved), outletMap);\n\t        };\n\t        ActivateRoutes.prototype.deactiveRouteAndItsChildren = function (route, parentOutletMap) {\n\t            var _this = this;\n\t            var prevChildren = nodeChildrenAsMap(route);\n\t            var outlet = null;\n\t            // getOutlet throws when cannot find the right outlet,\n\t            // which can happen if an outlet was in an NgIf and was removed\n\t            try {\n\t                outlet = getOutlet(parentOutletMap, route.value);\n\t            }\n\t            catch (e) {\n\t                return;\n\t            }\n\t            var childOutletMap = outlet.outletMap;\n\t            forEach(prevChildren, function (v, k) {\n\t                if (route.value.component) {\n\t                    _this.deactiveRouteAndItsChildren(v, childOutletMap);\n\t                }\n\t                else {\n\t                    _this.deactiveRouteAndItsChildren(v, parentOutletMap);\n\t                }\n\t            });\n\t            if (outlet && outlet.isActivated) {\n\t                outlet.deactivate();\n\t            }\n\t        };\n\t        return ActivateRoutes;\n\t    }());\n\t    function parentLoadedConfig(snapshot) {\n\t        var s = snapshot.parent;\n\t        while (s) {\n\t            var c = s._routeConfig;\n\t            if (c && c._loadedConfig)\n\t                return c._loadedConfig;\n\t            if (c && c.component)\n\t                return null;\n\t            s = s.parent;\n\t        }\n\t        return null;\n\t    }\n\t    function closestLoadedConfig(snapshot) {\n\t        if (!snapshot)\n\t            return null;\n\t        var s = snapshot.parent;\n\t        while (s) {\n\t            var c = s._routeConfig;\n\t            if (c && c._loadedConfig)\n\t                return c._loadedConfig;\n\t            s = s.parent;\n\t        }\n\t        return null;\n\t    }\n\t    function nodeChildrenAsMap(node) {\n\t        return node ? node.children.reduce(function (m, c) {\n\t            m[c.value.outlet] = c;\n\t            return m;\n\t        }, {}) : {};\n\t    }\n\t    function getOutlet(outletMap, route) {\n\t        var outlet = outletMap._outlets[route.outlet];\n\t        if (!outlet) {\n\t            var componentName = route.component.name;\n\t            if (route.outlet === PRIMARY_OUTLET) {\n\t                throw new Error(\"Cannot find primary outlet to load '\" + componentName + \"'\");\n\t            }\n\t            else {\n\t                throw new Error(\"Cannot find the outlet \" + route.outlet + \" to load '\" + componentName + \"'\");\n\t            }\n\t        }\n\t        return outlet;\n\t    }\n\t\n\t    /**\n\t     * @whatItDoes Lets you link to specific parts of your app.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * Consider the following route configuration:\n\t\n\t     * ```\n\t     * [{ path: 'user/:name', component: UserCmp }]\n\t     * ```\n\t     *\n\t     * When linking to this `user/:name` route, you can write:\n\t     *\n\t     * ```\n\t     * <a routerLink='/user/bob'>link to user component</a>\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * The RouterLink directives let you link to specific parts of your app.\n\t     *\n\t     * Whe the link is static, you can use the directive as follows:\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\">link to user component</a>\n\t     * ```\n\t     *\n\t     * If you use dynamic values to generate the link, you can pass an array of path\n\t     * segments, followed by the params for each segment.\n\t     *\n\t     * For instance `['/team', teamId, 'user', userName, {details: true}]`\n\t     * means that we want to generate a link to `/team/11/user/bob;details=true`.\n\t     *\n\t     * Multiple static segments can be merged into one (e.g., `['/team/11/user', userName, {details:\n\t     true}]`).\n\t     *\n\t     * The first segment name can be prepended with `/`, `./`, or `../`:\n\t     * * If the first segment begins with `/`, the router will look up the route from the root of the\n\t     app.\n\t     * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n\t     * instead look in the children of the current activated route.\n\t     * * And if the first segment begins with `../`, the router will go up one level.\n\t     *\n\t     * You can set query params and fragment as follows:\n\t     *\n\t     * ```\n\t     * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">link to user\n\t     component</a>\n\t     * ```\n\t     * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n\t     *\n\t     * You can also tell the directive to preserve the current query params and fragment:\n\t     *\n\t     * ```\n\t     * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>link to user\n\t     component</a>\n\t     * ```\n\t     *\n\t     * The router link directive always treats the provided input as a delta to the current url.\n\t     *\n\t     * For instance, if the current url is `/user/(box//aux:team)`.\n\t     *\n\t     * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n\t     * `/user/(jim//aux:team)`.\n\t     *\n\t     * @selector ':not(a)[routerLink]'\n\t     * @ngModule RouterModule\n\t     *\n\t     * See {@link Router.createUrlTree} for more information.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterLink = (function () {\n\t        function RouterLink(router, route, locationStrategy) {\n\t            this.router = router;\n\t            this.route = route;\n\t            this.locationStrategy = locationStrategy;\n\t            this.commands = [];\n\t        }\n\t        Object.defineProperty(RouterLink.prototype, \"routerLink\", {\n\t            set: function (data) {\n\t                if (Array.isArray(data)) {\n\t                    this.commands = data;\n\t                }\n\t                else {\n\t                    this.commands = [data];\n\t                }\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLink.prototype.onClick = function () {\n\t            this.router.navigateByUrl(this.urlTree);\n\t            return true;\n\t        };\n\t        Object.defineProperty(RouterLink.prototype, \"urlTree\", {\n\t            get: function () {\n\t                return this.router.createUrlTree(this.commands, {\n\t                    relativeTo: this.route,\n\t                    queryParams: this.queryParams,\n\t                    fragment: this.fragment,\n\t                    preserveQueryParams: toBool(this.preserveQueryParams),\n\t                    preserveFragment: toBool(this.preserveFragment)\n\t                });\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLink.decorators = [\n\t            { type: _angular_core.Directive, args: [{ selector: ':not(a)[routerLink]' },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterLink.ctorParameters = [\n\t            { type: Router, },\n\t            { type: ActivatedRoute, },\n\t            { type: _angular_common.LocationStrategy, },\n\t        ];\n\t        RouterLink.propDecorators = {\n\t            'queryParams': [{ type: _angular_core.Input },],\n\t            'fragment': [{ type: _angular_core.Input },],\n\t            'preserveQueryParams': [{ type: _angular_core.Input },],\n\t            'preserveFragment': [{ type: _angular_core.Input },],\n\t            'routerLink': [{ type: _angular_core.Input },],\n\t            'onClick': [{ type: _angular_core.HostListener, args: ['click', [],] },],\n\t        };\n\t        return RouterLink;\n\t    }());\n\t    /**\n\t     * @whatItDoes Lets you link to specific parts of your app.\n\t     *\n\t     * See {@link RouterLink} for more information.\n\t     *\n\t     * @selector 'a[routerLink]'\n\t     * @ngModule RouterModule\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterLinkWithHref = (function () {\n\t        function RouterLinkWithHref(router, route, locationStrategy) {\n\t            var _this = this;\n\t            this.router = router;\n\t            this.route = route;\n\t            this.locationStrategy = locationStrategy;\n\t            this.commands = [];\n\t            this.subscription = router.events.subscribe(function (s) {\n\t                if (s instanceof NavigationEnd) {\n\t                    _this.updateTargetUrlAndHref();\n\t                }\n\t            });\n\t        }\n\t        Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\n\t            set: function (data) {\n\t                if (Array.isArray(data)) {\n\t                    this.commands = data;\n\t                }\n\t                else {\n\t                    this.commands = [data];\n\t                }\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };\n\t        RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n\t        RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey) {\n\t            if (button !== 0 || ctrlKey || metaKey) {\n\t                return true;\n\t            }\n\t            if (typeof this.target === 'string' && this.target != '_self') {\n\t                return true;\n\t            }\n\t            this.router.navigateByUrl(this.urlTree);\n\t            return false;\n\t        };\n\t        RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {\n\t            this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n\t        };\n\t        Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\n\t            get: function () {\n\t                return this.router.createUrlTree(this.commands, {\n\t                    relativeTo: this.route,\n\t                    queryParams: this.queryParams,\n\t                    fragment: this.fragment,\n\t                    preserveQueryParams: toBool(this.preserveQueryParams),\n\t                    preserveFragment: toBool(this.preserveFragment)\n\t                });\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLinkWithHref.decorators = [\n\t            { type: _angular_core.Directive, args: [{ selector: 'a[routerLink]' },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterLinkWithHref.ctorParameters = [\n\t            { type: Router, },\n\t            { type: ActivatedRoute, },\n\t            { type: _angular_common.LocationStrategy, },\n\t        ];\n\t        RouterLinkWithHref.propDecorators = {\n\t            'target': [{ type: _angular_core.Input },],\n\t            'queryParams': [{ type: _angular_core.Input },],\n\t            'fragment': [{ type: _angular_core.Input },],\n\t            'routerLinkOptions': [{ type: _angular_core.Input },],\n\t            'preserveQueryParams': [{ type: _angular_core.Input },],\n\t            'preserveFragment': [{ type: _angular_core.Input },],\n\t            'href': [{ type: _angular_core.HostBinding },],\n\t            'routerLink': [{ type: _angular_core.Input },],\n\t            'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey'],] },],\n\t        };\n\t        return RouterLinkWithHref;\n\t    }());\n\t    function toBool(s) {\n\t        if (s === '')\n\t            return true;\n\t        return !!s;\n\t    }\n\t\n\t    /**\n\t     * @whatItDoes Lets you add a CSS class to an element when the link's route becomes active.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n\t     * becomes active.\n\t     *\n\t     * Consider the following example:\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n\t     * ```\n\t     *\n\t     * When the url is either '/user' or '/user/bob', the active-link class will\n\t     * be added to the `a` tag. If the url changes, the class will be removed.\n\t     *\n\t     * You can set more than one class, as follows:\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n\t     * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n\t     * ```\n\t     *\n\t     * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n\t     * only when the url matches the link exactly.\n\t     *\n\t     * ```\n\t     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n\t     * true}\">Bob</a>\n\t     * ```\n\t     *\n\t     * You can assign the RouterLinkActive instance to a template variable and directly check\n\t     * the `isActive` status.\n\t     * ```\n\t     * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n\t     *   Bob {{ rla.isActive ? '(already open)' : ''}}\n\t     * </a>\n\t     * ```\n\t     *\n\t     * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n\t     *\n\t     * ```\n\t     * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n\t     *   <a routerLink=\"/user/jim\">Jim</a>\n\t     *   <a routerLink=\"/user/bob\">Bob</a>\n\t     * </div>\n\t     * ```\n\t     *\n\t     * This will set the active-link class on the div tag if the url is either '/user/jim' or\n\t     * '/user/bob'.\n\t     *\n\t     * @selector ':not(a)[routerLink]'\n\t     * @ngModule RouterModule\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterLinkActive = (function () {\n\t        function RouterLinkActive(router, element, renderer) {\n\t            var _this = this;\n\t            this.router = router;\n\t            this.element = element;\n\t            this.renderer = renderer;\n\t            this.classes = [];\n\t            this.routerLinkActiveOptions = { exact: false };\n\t            this.subscription = router.events.subscribe(function (s) {\n\t                if (s instanceof NavigationEnd) {\n\t                    _this.update();\n\t                }\n\t            });\n\t        }\n\t        Object.defineProperty(RouterLinkActive.prototype, \"isActive\", {\n\t            get: function () { return this.hasActiveLink(); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLinkActive.prototype.ngAfterContentInit = function () {\n\t            var _this = this;\n\t            this.links.changes.subscribe(function (s) { return _this.update(); });\n\t            this.linksWithHrefs.changes.subscribe(function (s) { return _this.update(); });\n\t            this.update();\n\t        };\n\t        Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\n\t            set: function (data) {\n\t                if (Array.isArray(data)) {\n\t                    this.classes = data;\n\t                }\n\t                else {\n\t                    this.classes = data.split(' ');\n\t                }\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };\n\t        RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n\t        RouterLinkActive.prototype.update = function () {\n\t            var _this = this;\n\t            if (!this.links || !this.linksWithHrefs || !this.router.navigated)\n\t                return;\n\t            var isActive = this.hasActiveLink();\n\t            this.classes.forEach(function (c) {\n\t                if (c) {\n\t                    _this.renderer.setElementClass(_this.element.nativeElement, c, isActive);\n\t                }\n\t            });\n\t        };\n\t        RouterLinkActive.prototype.isLinkActive = function (router) {\n\t            var _this = this;\n\t            return function (link) {\n\t                return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\n\t            };\n\t        };\n\t        RouterLinkActive.prototype.hasActiveLink = function () {\n\t            return this.links.some(this.isLinkActive(this.router)) ||\n\t                this.linksWithHrefs.some(this.isLinkActive(this.router));\n\t        };\n\t        RouterLinkActive.decorators = [\n\t            { type: _angular_core.Directive, args: [{\n\t                        selector: '[routerLinkActive]',\n\t                        exportAs: 'routerLinkActive',\n\t                    },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterLinkActive.ctorParameters = [\n\t            { type: Router, },\n\t            { type: _angular_core.ElementRef, },\n\t            { type: _angular_core.Renderer, },\n\t        ];\n\t        RouterLinkActive.propDecorators = {\n\t            'links': [{ type: _angular_core.ContentChildren, args: [RouterLink, { descendants: true },] },],\n\t            'linksWithHrefs': [{ type: _angular_core.ContentChildren, args: [RouterLinkWithHref, { descendants: true },] },],\n\t            'routerLinkActiveOptions': [{ type: _angular_core.Input },],\n\t            'routerLinkActive': [{ type: _angular_core.Input },],\n\t        };\n\t        return RouterLinkActive;\n\t    }());\n\t\n\t    /**\n\t     * @whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router\n\t     * state.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * <router-outlet></router-outlet>\n\t     * <router-outlet name='left'></router-outlet>\n\t     * <router-outlet name='right'></router-outlet>\n\t     * ```\n\t     *\n\t     * A router outlet will emit an activate event any time a new component is being instantiated,\n\t     * and a deactivate event when it is being destroyed.\n\t     *\n\t     * ```\n\t     * <router-outlet\n\t     *   (activate)='onActivate($event)'\n\t     *   (deactivate)='onDeactivate($event)'></router-outlet>\n\t     * ```\n\t     * @selector 'a[routerLink]'\n\t     * @ngModule RouterModule\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterOutlet = (function () {\n\t        function RouterOutlet(parentOutletMap, location, resolver, name) {\n\t            this.parentOutletMap = parentOutletMap;\n\t            this.location = location;\n\t            this.resolver = resolver;\n\t            this.name = name;\n\t            this.activateEvents = new _angular_core.EventEmitter();\n\t            this.deactivateEvents = new _angular_core.EventEmitter();\n\t            parentOutletMap.registerOutlet(name ? name : PRIMARY_OUTLET, this);\n\t        }\n\t        RouterOutlet.prototype.ngOnDestroy = function () { this.parentOutletMap.removeOutlet(this.name ? this.name : PRIMARY_OUTLET); };\n\t        Object.defineProperty(RouterOutlet.prototype, \"locationInjector\", {\n\t            get: function () { return this.location.injector; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(RouterOutlet.prototype, \"locationFactoryResolver\", {\n\t            get: function () { return this.resolver; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\n\t            get: function () { return !!this.activated; },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(RouterOutlet.prototype, \"component\", {\n\t            get: function () {\n\t                if (!this.activated)\n\t                    throw new Error('Outlet is not activated');\n\t                return this.activated.instance;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\n\t            get: function () {\n\t                if (!this.activated)\n\t                    throw new Error('Outlet is not activated');\n\t                return this._activatedRoute;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        RouterOutlet.prototype.deactivate = function () {\n\t            if (this.activated) {\n\t                var c = this.component;\n\t                this.activated.destroy();\n\t                this.activated = null;\n\t                this.deactivateEvents.emit(c);\n\t            }\n\t        };\n\t        RouterOutlet.prototype.activate = function (activatedRoute, resolver, injector, providers, outletMap) {\n\t            if (this.isActivated) {\n\t                throw new Error('Cannot activate an already activated outlet');\n\t            }\n\t            this.outletMap = outletMap;\n\t            this._activatedRoute = activatedRoute;\n\t            var snapshot = activatedRoute._futureSnapshot;\n\t            var component = snapshot._routeConfig.component;\n\t            var factory = resolver.resolveComponentFactory(component);\n\t            var inj = _angular_core.ReflectiveInjector.fromResolvedProviders(providers, injector);\n\t            this.activated = this.location.createComponent(factory, this.location.length, inj, []);\n\t            this.activated.changeDetectorRef.detectChanges();\n\t            this.activateEvents.emit(this.activated.instance);\n\t        };\n\t        RouterOutlet.decorators = [\n\t            { type: _angular_core.Directive, args: [{ selector: 'router-outlet' },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterOutlet.ctorParameters = [\n\t            { type: RouterOutletMap, },\n\t            { type: _angular_core.ViewContainerRef, },\n\t            { type: _angular_core.ComponentFactoryResolver, },\n\t            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['name',] },] },\n\t        ];\n\t        RouterOutlet.propDecorators = {\n\t            'activateEvents': [{ type: _angular_core.Output, args: ['activate',] },],\n\t            'deactivateEvents': [{ type: _angular_core.Output, args: ['deactivate',] },],\n\t        };\n\t        return RouterOutlet;\n\t    }());\n\t\n\t    var getDOM = _angular_platformBrowser.__platform_browser_private__.getDOM;\n\t\n\t    /**\n\t     * @whatItDoes Provides a preloading strategy.\n\t     *\n\t     * @experimental\n\t     */\n\t    var PreloadingStrategy = (function () {\n\t        function PreloadingStrategy() {\n\t        }\n\t        return PreloadingStrategy;\n\t    }());\n\t    /**\n\t     * @whatItDoes Provides a preloading strategy that preloads all modules as quicky as possible.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n\t     * ```\n\t     *\n\t     * @experimental\n\t     */\n\t    var PreloadAllModules = (function () {\n\t        function PreloadAllModules() {\n\t        }\n\t        PreloadAllModules.prototype.preload = function (route, fn) {\n\t            return rxjs_operator_catch._catch.call(fn(), function () { return rxjs_observable_of.of(null); });\n\t        };\n\t        return PreloadAllModules;\n\t    }());\n\t    /**\n\t     * @whatItDoes Provides a preloading strategy that does not preload any modules.\n\t     *\n\t     * @description\n\t     *\n\t     * This strategy is enabled by default.\n\t     *\n\t     * @experimental\n\t     */\n\t    var NoPreloading = (function () {\n\t        function NoPreloading() {\n\t        }\n\t        NoPreloading.prototype.preload = function (route, fn) { return rxjs_observable_of.of(null); };\n\t        return NoPreloading;\n\t    }());\n\t    /**\n\t     * The preloader optimistically loads all router configurations to\n\t     * make navigations into lazily-loaded sections of the application faster.\n\t     *\n\t     * The preloader runs in the background. When the router bootstraps, the preloader\n\t     * starts listening to all navigation events. After every such event, the preloader\n\t     * will check if any configurations can be loaded lazily.\n\t     *\n\t     * If a route is protected by `canLoad` guards, the preloaded will not load it.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterPreloader = (function () {\n\t        function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n\t            this.router = router;\n\t            this.injector = injector;\n\t            this.preloadingStrategy = preloadingStrategy;\n\t            this.loader = new RouterConfigLoader(moduleLoader, compiler);\n\t        }\n\t        ;\n\t        RouterPreloader.prototype.setUpPreloading = function () {\n\t            var _this = this;\n\t            var navigations = rxjs_operator_filter.filter.call(this.router.events, function (e) { return e instanceof NavigationEnd; });\n\t            this.subscription = rxjs_operator_concatMap.concatMap.call(navigations, function () { return _this.preload(); }).subscribe(function (v) { });\n\t        };\n\t        RouterPreloader.prototype.preload = function () { return this.processRoutes(this.injector, this.router.config); };\n\t        RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n\t        RouterPreloader.prototype.processRoutes = function (injector, routes) {\n\t            var res = [];\n\t            for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n\t                var c = routes_1[_i];\n\t                // we already have the config loaded, just recurce\n\t                if (c.loadChildren && !c.canLoad && c._loadedConfig) {\n\t                    var childConfig = c._loadedConfig;\n\t                    res.push(this.processRoutes(childConfig.injector, childConfig.routes));\n\t                }\n\t                else if (c.loadChildren && !c.canLoad) {\n\t                    res.push(this.preloadConfig(injector, c));\n\t                }\n\t                else if (c.children) {\n\t                    res.push(this.processRoutes(injector, c.children));\n\t                }\n\t            }\n\t            return rxjs_operator_mergeAll.mergeAll.call(rxjs_observable_from.from(res));\n\t        };\n\t        RouterPreloader.prototype.preloadConfig = function (injector, route) {\n\t            var _this = this;\n\t            return this.preloadingStrategy.preload(route, function () {\n\t                var loaded = _this.loader.load(injector, route.loadChildren);\n\t                return rxjs_operator_mergeMap.mergeMap.call(loaded, function (config) {\n\t                    var c = route;\n\t                    c._loadedConfig = config;\n\t                    return _this.processRoutes(config.injector, config.routes);\n\t                });\n\t            });\n\t        };\n\t        RouterPreloader.decorators = [\n\t            { type: _angular_core.Injectable },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterPreloader.ctorParameters = [\n\t            { type: Router, },\n\t            { type: _angular_core.NgModuleFactoryLoader, },\n\t            { type: _angular_core.Compiler, },\n\t            { type: _angular_core.Injector, },\n\t            { type: PreloadingStrategy, },\n\t        ];\n\t        return RouterPreloader;\n\t    }());\n\t\n\t    /**\n\t     * @whatItDoes Contains a list of directives\n\t     * @stable\n\t     */\n\t    var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n\t    /**\n\t     * @whatItDoes Is used in DI to configure the router.\n\t     * @stable\n\t     */\n\t    var ROUTER_CONFIGURATION = new _angular_core.OpaqueToken('ROUTER_CONFIGURATION');\n\t    /**\n\t     * @docsNotRequired\n\t     */\n\t    var ROUTER_FORROOT_GUARD = new _angular_core.OpaqueToken('ROUTER_FORROOT_GUARD');\n\t    var ROUTER_PROVIDERS = [\n\t        _angular_common.Location, { provide: UrlSerializer, useClass: DefaultUrlSerializer }, {\n\t            provide: Router,\n\t            useFactory: setupRouter,\n\t            deps: [\n\t                _angular_core.ApplicationRef, UrlSerializer, RouterOutletMap, _angular_common.Location, _angular_core.Injector, _angular_core.NgModuleFactoryLoader,\n\t                _angular_core.Compiler, ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new _angular_core.Optional()]\n\t            ]\n\t        },\n\t        RouterOutletMap, { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n\t        { provide: _angular_core.NgModuleFactoryLoader, useClass: _angular_core.SystemJsNgModuleLoader }, RouterPreloader, NoPreloading,\n\t        PreloadAllModules, { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } }\n\t    ];\n\t    /**\n\t     * @whatItDoes Adds router directives and providers.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n\t     * Since the router deals with a global shared resource--location, we cannot have\n\t     * more than one router service active.\n\t     *\n\t     * That is why there are two ways to create the module: `RouterModule.forRoot` and\n\t     * `RouterModule.forChild`.\n\t     *\n\t     * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n\t     * service itself.\n\t     * * `forChild` creates a module that contains all the directives and the given routes, but does not\n\t     * include\n\t     * the router service.\n\t     *\n\t     * When registered at the root, the module should be used as follows\n\t     *\n\t     * ```\n\t     * @NgModule({\n\t     *   imports: [RouterModule.forRoot(ROUTES)]\n\t     * })\n\t     * class MyNgModule {}\n\t     * ```\n\t     *\n\t     * For submodules and lazy loaded submodules the module should be used as follows:\n\t     *\n\t     * ```\n\t     * @NgModule({\n\t     *   imports: [RouterModule.forChild(ROUTES)]\n\t     * })\n\t     * class MyNgModule {}\n\t     * ```\n\t     *\n\t     * @description\n\t     *\n\t     * Managing state transitions is one of the hardest parts of building applications. This is\n\t     * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n\t     * In addition, we often want to split applications into multiple bundles and load them on demand.\n\t     * Doing this transparently is not trivial.\n\t     *\n\t     * The Angular 2 router solves these problems. Using the router, you can declaratively specify\n\t     * application states, manage state transitions while taking care of the URL, and load bundles on\n\t     * demand.\n\t     *\n\t     * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n\t     * overview of how the router should be used.\n\t     *\n\t     * @stable\n\t     */\n\t    var RouterModule = (function () {\n\t        function RouterModule(guard) {\n\t        }\n\t        /**\n\t         * Creates a module with all the router providers and directives. It also optionally sets up an\n\t         * application listener to perform an initial navigation.\n\t         *\n\t         * Options:\n\t         * * `enableTracing` makes the router log all its internal events to the console.\n\t         * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n\t         * API.\n\t         * * `initialNavigation` disables the initial navigation.\n\t         * * `errorHandler` provides a custom error handler.\n\t         */\n\t        RouterModule.forRoot = function (routes, config) {\n\t            return {\n\t                ngModule: RouterModule,\n\t                providers: [\n\t                    ROUTER_PROVIDERS, provideRoutes(routes), {\n\t                        provide: ROUTER_FORROOT_GUARD,\n\t                        useFactory: provideForRootGuard,\n\t                        deps: [[Router, new _angular_core.Optional(), new _angular_core.SkipSelf()]]\n\t                    },\n\t                    { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} }, {\n\t                        provide: _angular_common.LocationStrategy,\n\t                        useFactory: provideLocationStrategy,\n\t                        deps: [\n\t                            _angular_common.PlatformLocation, [new _angular_core.Inject(_angular_common.APP_BASE_HREF), new _angular_core.Optional()], ROUTER_CONFIGURATION\n\t                        ]\n\t                    },\n\t                    {\n\t                        provide: PreloadingStrategy,\n\t                        useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n\t                            NoPreloading\n\t                    },\n\t                    provideRouterInitializer()\n\t                ]\n\t            };\n\t        };\n\t        /**\n\t         * Creates a module with all the router directives and a provider registering routes.\n\t         */\n\t        RouterModule.forChild = function (routes) {\n\t            return { ngModule: RouterModule, providers: [provideRoutes(routes)] };\n\t        };\n\t        RouterModule.decorators = [\n\t            { type: _angular_core.NgModule, args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },\n\t        ];\n\t        /** @nocollapse */\n\t        RouterModule.ctorParameters = [\n\t            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [ROUTER_FORROOT_GUARD,] },] },\n\t        ];\n\t        return RouterModule;\n\t    }());\n\t    function provideLocationStrategy(platformLocationStrategy, baseHref, options) {\n\t        if (options === void 0) { options = {}; }\n\t        return options.useHash ? new _angular_common.HashLocationStrategy(platformLocationStrategy, baseHref) :\n\t            new _angular_common.PathLocationStrategy(platformLocationStrategy, baseHref);\n\t    }\n\t    function provideForRootGuard(router) {\n\t        if (router) {\n\t            throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n\t        }\n\t        return 'guarded';\n\t    }\n\t    /**\n\t     * @whatItDoes Registers routes.\n\t     *\n\t     * @howToUse\n\t     *\n\t     * ```\n\t     * @NgModule({\n\t     *   imports: [RouterModule.forChild(ROUTES)],\n\t     *   providers: [provideRoutes(EXTRA_ROUTES)]\n\t     * })\n\t     * class MyNgModule {}\n\t     * ```\n\t     *\n\t     * @stable\n\t     */\n\t    function provideRoutes(routes) {\n\t        return [\n\t            { provide: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },\n\t            { provide: ROUTES, multi: true, useValue: routes }\n\t        ];\n\t    }\n\t    function setupRouter(ref, urlSerializer, outletMap, location, injector, loader, compiler, config, opts, urlHandlingStrategy) {\n\t        if (opts === void 0) { opts = {}; }\n\t        var router = new Router(null, urlSerializer, outletMap, location, injector, loader, compiler, flatten(config));\n\t        if (urlHandlingStrategy) {\n\t            router.urlHandlingStrategy = urlHandlingStrategy;\n\t        }\n\t        if (opts.errorHandler) {\n\t            router.errorHandler = opts.errorHandler;\n\t        }\n\t        if (opts.enableTracing) {\n\t            var dom_1 = getDOM();\n\t            router.events.subscribe(function (e) {\n\t                dom_1.logGroup(\"Router Event: \" + e.constructor.name);\n\t                dom_1.log(e.toString());\n\t                dom_1.log(e);\n\t                dom_1.logGroupEnd();\n\t            });\n\t        }\n\t        return router;\n\t    }\n\t    function rootRoute(router) {\n\t        return router.routerState.root;\n\t    }\n\t    function initialRouterNavigation(router, ref, preloader, opts) {\n\t        return function (bootstrappedComponentRef) {\n\t            if (bootstrappedComponentRef !== ref.components[0]) {\n\t                return;\n\t            }\n\t            router.resetRootComponentType(ref.componentTypes[0]);\n\t            preloader.setUpPreloading();\n\t            if (opts.initialNavigation === false) {\n\t                router.setUpLocationChangeListener();\n\t            }\n\t            else {\n\t                router.initialNavigation();\n\t            }\n\t        };\n\t    }\n\t    /**\n\t     * A token for the router initializer that will be called after the app is bootstrapped.\n\t     *\n\t     * @experimental\n\t     */\n\t    var ROUTER_INITIALIZER = new _angular_core.OpaqueToken('Router Initializer');\n\t    function provideRouterInitializer() {\n\t        return [\n\t            {\n\t                provide: ROUTER_INITIALIZER,\n\t                useFactory: initialRouterNavigation,\n\t                deps: [Router, _angular_core.ApplicationRef, RouterPreloader, ROUTER_CONFIGURATION]\n\t            },\n\t            { provide: _angular_core.APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER }\n\t        ];\n\t    }\n\t\n\t    var __router_private__ = {\n\t        ROUTER_PROVIDERS: ROUTER_PROVIDERS,\n\t        ROUTES: ROUTES,\n\t        flatten: flatten\n\t    };\n\t\n\t    exports.RouterLink = RouterLink;\n\t    exports.RouterLinkWithHref = RouterLinkWithHref;\n\t    exports.RouterLinkActive = RouterLinkActive;\n\t    exports.RouterOutlet = RouterOutlet;\n\t    exports.NavigationCancel = NavigationCancel;\n\t    exports.NavigationEnd = NavigationEnd;\n\t    exports.NavigationError = NavigationError;\n\t    exports.NavigationStart = NavigationStart;\n\t    exports.Router = Router;\n\t    exports.RoutesRecognized = RoutesRecognized;\n\t    exports.ROUTER_CONFIGURATION = ROUTER_CONFIGURATION;\n\t    exports.ROUTER_INITIALIZER = ROUTER_INITIALIZER;\n\t    exports.RouterModule = RouterModule;\n\t    exports.provideRoutes = provideRoutes;\n\t    exports.RouterOutletMap = RouterOutletMap;\n\t    exports.NoPreloading = NoPreloading;\n\t    exports.PreloadAllModules = PreloadAllModules;\n\t    exports.PreloadingStrategy = PreloadingStrategy;\n\t    exports.RouterPreloader = RouterPreloader;\n\t    exports.ActivatedRoute = ActivatedRoute;\n\t    exports.ActivatedRouteSnapshot = ActivatedRouteSnapshot;\n\t    exports.RouterState = RouterState;\n\t    exports.RouterStateSnapshot = RouterStateSnapshot;\n\t    exports.PRIMARY_OUTLET = PRIMARY_OUTLET;\n\t    exports.UrlHandlingStrategy = UrlHandlingStrategy;\n\t    exports.DefaultUrlSerializer = DefaultUrlSerializer;\n\t    exports.UrlSegment = UrlSegment;\n\t    exports.UrlSegmentGroup = UrlSegmentGroup;\n\t    exports.UrlSerializer = UrlSerializer;\n\t    exports.UrlTree = UrlTree;\n\t    exports.__router_private__ = __router_private__;\n\t\n\t}));\n\n/***/ },\n\n/***/ 144:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subject_1 = __webpack_require__(46);\n\tvar ObjectUnsubscribedError_1 = __webpack_require__(93);\n\t/**\n\t * @class BehaviorSubject<T>\n\t */\n\tvar BehaviorSubject = (function (_super) {\n\t    __extends(BehaviorSubject, _super);\n\t    function BehaviorSubject(_value) {\n\t        _super.call(this);\n\t        this._value = _value;\n\t    }\n\t    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n\t        get: function () {\n\t            return this.getValue();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    BehaviorSubject.prototype._subscribe = function (subscriber) {\n\t        var subscription = _super.prototype._subscribe.call(this, subscriber);\n\t        if (subscription && !subscription.closed) {\n\t            subscriber.next(this._value);\n\t        }\n\t        return subscription;\n\t    };\n\t    BehaviorSubject.prototype.getValue = function () {\n\t        if (this.hasError) {\n\t            throw this.thrownError;\n\t        }\n\t        else if (this.closed) {\n\t            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n\t        }\n\t        else {\n\t            return this._value;\n\t        }\n\t    };\n\t    BehaviorSubject.prototype.next = function (value) {\n\t        _super.prototype.next.call(this, this._value = value);\n\t    };\n\t    return BehaviorSubject;\n\t}(Subject_1.Subject));\n\texports.BehaviorSubject = BehaviorSubject;\n\t//# sourceMappingURL=BehaviorSubject.js.map\n\n/***/ },\n\n/***/ 145:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar InnerSubscriber = (function (_super) {\n\t    __extends(InnerSubscriber, _super);\n\t    function InnerSubscriber(parent, outerValue, outerIndex) {\n\t        _super.call(this);\n\t        this.parent = parent;\n\t        this.outerValue = outerValue;\n\t        this.outerIndex = outerIndex;\n\t        this.index = 0;\n\t    }\n\t    InnerSubscriber.prototype._next = function (value) {\n\t        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n\t    };\n\t    InnerSubscriber.prototype._error = function (error) {\n\t        this.parent.notifyError(error, this);\n\t        this.unsubscribe();\n\t    };\n\t    InnerSubscriber.prototype._complete = function () {\n\t        this.parent.notifyComplete(this);\n\t        this.unsubscribe();\n\t    };\n\t    return InnerSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.InnerSubscriber = InnerSubscriber;\n\t//# sourceMappingURL=InnerSubscriber.js.map\n\n/***/ },\n\n/***/ 146:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(11);\n\t/**\n\t * Represents a push-based event or value that an {@link Observable} can emit.\n\t * This class is particularly useful for operators that manage notifications,\n\t * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n\t * others. Besides wrapping the actual delivered value, it also annotates it\n\t * with metadata of, for instance, what type of push message it is (`next`,\n\t * `error`, or `complete`).\n\t *\n\t * @see {@link materialize}\n\t * @see {@link dematerialize}\n\t * @see {@link observeOn}\n\t *\n\t * @class Notification<T>\n\t */\n\tvar Notification = (function () {\n\t    function Notification(kind, value, exception) {\n\t        this.kind = kind;\n\t        this.value = value;\n\t        this.exception = exception;\n\t        this.hasValue = kind === 'N';\n\t    }\n\t    /**\n\t     * Delivers to the given `observer` the value wrapped by this Notification.\n\t     * @param {Observer} observer\n\t     * @return\n\t     */\n\t    Notification.prototype.observe = function (observer) {\n\t        switch (this.kind) {\n\t            case 'N':\n\t                return observer.next && observer.next(this.value);\n\t            case 'E':\n\t                return observer.error && observer.error(this.exception);\n\t            case 'C':\n\t                return observer.complete && observer.complete();\n\t        }\n\t    };\n\t    /**\n\t     * Given some {@link Observer} callbacks, deliver the value represented by the\n\t     * current Notification to the correctly corresponding callback.\n\t     * @param {function(value: T): void} next An Observer `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.do = function (next, error, complete) {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return next && next(this.value);\n\t            case 'E':\n\t                return error && error(this.exception);\n\t            case 'C':\n\t                return complete && complete();\n\t        }\n\t    };\n\t    /**\n\t     * Takes an Observer or its individual callback functions, and calls `observe`\n\t     * or `do` methods accordingly.\n\t     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n\t     * the `next` callback.\n\t     * @param {function(err: any): void} [error] An Observer `error` callback.\n\t     * @param {function(): void} [complete] An Observer `complete` callback.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n\t        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n\t            return this.observe(nextOrObserver);\n\t        }\n\t        else {\n\t            return this.do(nextOrObserver, error, complete);\n\t        }\n\t    };\n\t    /**\n\t     * Returns a simple Observable that just delivers the notification represented\n\t     * by this Notification instance.\n\t     * @return {any}\n\t     */\n\t    Notification.prototype.toObservable = function () {\n\t        var kind = this.kind;\n\t        switch (kind) {\n\t            case 'N':\n\t                return Observable_1.Observable.of(this.value);\n\t            case 'E':\n\t                return Observable_1.Observable.throw(this.exception);\n\t            case 'C':\n\t                return Observable_1.Observable.empty();\n\t        }\n\t        throw new Error('unexpected notification kind value');\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `next` from a\n\t     * given value.\n\t     * @param {T} value The `next` value.\n\t     * @return {Notification<T>} The \"next\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createNext = function (value) {\n\t        if (typeof value !== 'undefined') {\n\t            return new Notification('N', value);\n\t        }\n\t        return this.undefinedValueNotification;\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `error` from a\n\t     * given error.\n\t     * @param {any} [err] The `error` exception.\n\t     * @return {Notification<T>} The \"error\" Notification representing the\n\t     * argument.\n\t     */\n\t    Notification.createError = function (err) {\n\t        return new Notification('E', undefined, err);\n\t    };\n\t    /**\n\t     * A shortcut to create a Notification instance of the type `complete`.\n\t     * @return {Notification<any>} The valueless \"complete\" Notification.\n\t     */\n\t    Notification.createComplete = function () {\n\t        return this.completeNotification;\n\t    };\n\t    Notification.completeNotification = new Notification('C');\n\t    Notification.undefinedValueNotification = new Notification('N', undefined);\n\t    return Notification;\n\t}());\n\texports.Notification = Notification;\n\t//# sourceMappingURL=Notification.js.map\n\n/***/ },\n\n/***/ 57:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar OuterSubscriber = (function (_super) {\n\t    __extends(OuterSubscriber, _super);\n\t    function OuterSubscriber() {\n\t        _super.apply(this, arguments);\n\t    }\n\t    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        this.destination.next(innerValue);\n\t    };\n\t    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n\t        this.destination.error(error);\n\t    };\n\t    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        this.destination.complete();\n\t    };\n\t    return OuterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.OuterSubscriber = OuterSubscriber;\n\t//# sourceMappingURL=OuterSubscriber.js.map\n\n/***/ },\n\n/***/ 149:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(11);\n\tvar ScalarObservable_1 = __webpack_require__(89);\n\tvar EmptyObservable_1 = __webpack_require__(87);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ArrayLikeObservable = (function (_super) {\n\t    __extends(ArrayLikeObservable, _super);\n\t    function ArrayLikeObservable(arrayLike, scheduler) {\n\t        _super.call(this);\n\t        this.arrayLike = arrayLike;\n\t        this.scheduler = scheduler;\n\t        if (!scheduler && arrayLike.length === 1) {\n\t            this._isScalar = true;\n\t            this.value = arrayLike[0];\n\t        }\n\t    }\n\t    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n\t        var length = arrayLike.length;\n\t        if (length === 0) {\n\t            return new EmptyObservable_1.EmptyObservable();\n\t        }\n\t        else if (length === 1) {\n\t            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n\t        }\n\t        else {\n\t            return new ArrayLikeObservable(arrayLike, scheduler);\n\t        }\n\t    };\n\t    ArrayLikeObservable.dispatch = function (state) {\n\t        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        if (index >= length) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(arrayLike[index]);\n\t        state.index = index + 1;\n\t        this.schedule(state);\n\t    };\n\t    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n\t        var length = arrayLike.length;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n\t                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            for (var i = 0; i < length && !subscriber.closed; i++) {\n\t                subscriber.next(arrayLike[i]);\n\t            }\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return ArrayLikeObservable;\n\t}(Observable_1.Observable));\n\texports.ArrayLikeObservable = ArrayLikeObservable;\n\t//# sourceMappingURL=ArrayLikeObservable.js.map\n\n/***/ },\n\n/***/ 86:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(11);\n\tvar ScalarObservable_1 = __webpack_require__(89);\n\tvar EmptyObservable_1 = __webpack_require__(87);\n\tvar isScheduler_1 = __webpack_require__(167);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ArrayObservable = (function (_super) {\n\t    __extends(ArrayObservable, _super);\n\t    function ArrayObservable(array, scheduler) {\n\t        _super.call(this);\n\t        this.array = array;\n\t        this.scheduler = scheduler;\n\t        if (!scheduler && array.length === 1) {\n\t            this._isScalar = true;\n\t            this.value = array[0];\n\t        }\n\t    }\n\t    ArrayObservable.create = function (array, scheduler) {\n\t        return new ArrayObservable(array, scheduler);\n\t    };\n\t    /**\n\t     * Creates an Observable that emits some values you specify as arguments,\n\t     * immediately one after the other, and then emits a complete notification.\n\t     *\n\t     * <span class=\"informal\">Emits the arguments you provide, then completes.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/of.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the arguments given, and the complete notification thereafter. It can\n\t     * be used for composing with other Observables, such as with {@link concat}.\n\t     * By default, it uses a `null` Scheduler, which means the `next`\n\t     * notifications are sent synchronously, although with a different Scheduler\n\t     * it is possible to determine when those notifications will be delivered.\n\t     *\n\t     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n\t     * var numbers = Rx.Observable.of(10, 20, 30);\n\t     * var letters = Rx.Observable.of('a', 'b', 'c');\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = numbers.concat(letters).concat(interval);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link empty}\n\t     * @see {@link never}\n\t     * @see {@link throw}\n\t     *\n\t     * @param {...T} values Arguments that represent `next` values to be emitted.\n\t     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n\t     * the emissions of the `next` notifications.\n\t     * @return {Observable<T>} An Observable that emits each given input value.\n\t     * @static true\n\t     * @name of\n\t     * @owner Observable\n\t     */\n\t    ArrayObservable.of = function () {\n\t        var array = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            array[_i - 0] = arguments[_i];\n\t        }\n\t        var scheduler = array[array.length - 1];\n\t        if (isScheduler_1.isScheduler(scheduler)) {\n\t            array.pop();\n\t        }\n\t        else {\n\t            scheduler = null;\n\t        }\n\t        var len = array.length;\n\t        if (len > 1) {\n\t            return new ArrayObservable(array, scheduler);\n\t        }\n\t        else if (len === 1) {\n\t            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n\t        }\n\t        else {\n\t            return new EmptyObservable_1.EmptyObservable(scheduler);\n\t        }\n\t    };\n\t    ArrayObservable.dispatch = function (state) {\n\t        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n\t        if (index >= count) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(array[index]);\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        state.index = index + 1;\n\t        this.schedule(state);\n\t    };\n\t    ArrayObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var array = this.array;\n\t        var count = array.length;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n\t                array: array, index: index, count: count, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            for (var i = 0; i < count && !subscriber.closed; i++) {\n\t                subscriber.next(array[i]);\n\t            }\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return ArrayObservable;\n\t}(Observable_1.Observable));\n\texports.ArrayObservable = ArrayObservable;\n\t//# sourceMappingURL=ArrayObservable.js.map\n\n/***/ },\n\n/***/ 87:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(11);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar EmptyObservable = (function (_super) {\n\t    __extends(EmptyObservable, _super);\n\t    function EmptyObservable(scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable that emits no items to the Observer and immediately\n\t     * emits a complete notification.\n\t     *\n\t     * <span class=\"informal\">Just emits 'complete', and nothing else.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/empty.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the complete notification. It can be used for composing with other\n\t     * Observables, such as in a {@link mergeMap}.\n\t     *\n\t     * @example <caption>Emit the number 7, then complete.</caption>\n\t     * var result = Rx.Observable.empty().startWith(7);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = interval.mergeMap(x =>\n\t     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n\t     * );\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link never}\n\t     * @see {@link of}\n\t     * @see {@link throw}\n\t     *\n\t     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n\t     * the emission of the complete notification.\n\t     * @return {Observable} An \"empty\" Observable: emits only the complete\n\t     * notification.\n\t     * @static true\n\t     * @name empty\n\t     * @owner Observable\n\t     */\n\t    EmptyObservable.create = function (scheduler) {\n\t        return new EmptyObservable(scheduler);\n\t    };\n\t    EmptyObservable.dispatch = function (arg) {\n\t        var subscriber = arg.subscriber;\n\t        subscriber.complete();\n\t    };\n\t    EmptyObservable.prototype._subscribe = function (subscriber) {\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n\t        }\n\t        else {\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return EmptyObservable;\n\t}(Observable_1.Observable));\n\texports.EmptyObservable = EmptyObservable;\n\t//# sourceMappingURL=EmptyObservable.js.map\n\n/***/ },\n\n/***/ 150:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isArray_1 = __webpack_require__(63);\n\tvar isPromise_1 = __webpack_require__(96);\n\tvar PromiseObservable_1 = __webpack_require__(88);\n\tvar IteratorObservable_1 = __webpack_require__(151);\n\tvar ArrayObservable_1 = __webpack_require__(86);\n\tvar ArrayLikeObservable_1 = __webpack_require__(149);\n\tvar iterator_1 = __webpack_require__(59);\n\tvar Observable_1 = __webpack_require__(11);\n\tvar observeOn_1 = __webpack_require__(162);\n\tvar observable_1 = __webpack_require__(60);\n\tvar isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar FromObservable = (function (_super) {\n\t    __extends(FromObservable, _super);\n\t    function FromObservable(ish, scheduler) {\n\t        _super.call(this, null);\n\t        this.ish = ish;\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable from an Array, an array-like object, a Promise, an\n\t     * iterable object, or an Observable-like object.\n\t     *\n\t     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n\t     *\n\t     * <img src=\"./img/from.png\" width=\"100%\">\n\t     *\n\t     * Convert various other objects and data types into Observables. `from`\n\t     * converts a Promise or an array-like or an\n\t     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n\t     * object into an Observable that emits the items in that promise or array or\n\t     * iterable. A String, in this context, is treated as an array of characters.\n\t     * Observable-like objects (contains a function named with the ES2015 Symbol\n\t     * for Observable) can also be converted through this operator.\n\t     *\n\t     * @example <caption>Converts an array to an Observable</caption>\n\t     * var array = [10, 20, 30];\n\t     * var result = Rx.Observable.from(array);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n\t     * function* generateDoubles(seed) {\n\t     *   var i = seed;\n\t     *   while (true) {\n\t     *     yield i;\n\t     *     i = 2 * i; // double it\n\t     *   }\n\t     * }\n\t     *\n\t     * var iterator = generateDoubles(3);\n\t     * var result = Rx.Observable.from(iterator).take(10);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link fromEvent}\n\t     * @see {@link fromEventPattern}\n\t     * @see {@link fromPromise}\n\t     *\n\t     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n\t     * Observable-like, an Array, an iterable or an array-like object to be\n\t     * converted.\n\t     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n\t     * emissions of values.\n\t     * @return {Observable<T>} The Observable whose values are originally from the\n\t     * input object that was converted.\n\t     * @static true\n\t     * @name from\n\t     * @owner Observable\n\t     */\n\t    FromObservable.create = function (ish, scheduler) {\n\t        if (ish != null) {\n\t            if (typeof ish[observable_1.$$observable] === 'function') {\n\t                if (ish instanceof Observable_1.Observable && !scheduler) {\n\t                    return ish;\n\t                }\n\t                return new FromObservable(ish, scheduler);\n\t            }\n\t            else if (isArray_1.isArray(ish)) {\n\t                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n\t            }\n\t            else if (isPromise_1.isPromise(ish)) {\n\t                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n\t            }\n\t            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {\n\t                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n\t            }\n\t            else if (isArrayLike(ish)) {\n\t                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n\t            }\n\t        }\n\t        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n\t    };\n\t    FromObservable.prototype._subscribe = function (subscriber) {\n\t        var ish = this.ish;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler == null) {\n\t            return ish[observable_1.$$observable]().subscribe(subscriber);\n\t        }\n\t        else {\n\t            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n\t        }\n\t    };\n\t    return FromObservable;\n\t}(Observable_1.Observable));\n\texports.FromObservable = FromObservable;\n\t//# sourceMappingURL=FromObservable.js.map\n\n/***/ },\n\n/***/ 151:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = __webpack_require__(26);\n\tvar Observable_1 = __webpack_require__(11);\n\tvar iterator_1 = __webpack_require__(59);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar IteratorObservable = (function (_super) {\n\t    __extends(IteratorObservable, _super);\n\t    function IteratorObservable(iterator, scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t        if (iterator == null) {\n\t            throw new Error('iterator cannot be null.');\n\t        }\n\t        this.iterator = getIterator(iterator);\n\t    }\n\t    IteratorObservable.create = function (iterator, scheduler) {\n\t        return new IteratorObservable(iterator, scheduler);\n\t    };\n\t    IteratorObservable.dispatch = function (state) {\n\t        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n\t        if (hasError) {\n\t            subscriber.error(state.error);\n\t            return;\n\t        }\n\t        var result = iterator.next();\n\t        if (result.done) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(result.value);\n\t        state.index = index + 1;\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        this.schedule(state);\n\t    };\n\t    IteratorObservable.prototype._subscribe = function (subscriber) {\n\t        var index = 0;\n\t        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n\t                index: index, iterator: iterator, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            do {\n\t                var result = iterator.next();\n\t                if (result.done) {\n\t                    subscriber.complete();\n\t                    break;\n\t                }\n\t                else {\n\t                    subscriber.next(result.value);\n\t                }\n\t                if (subscriber.closed) {\n\t                    break;\n\t                }\n\t            } while (true);\n\t        }\n\t    };\n\t    return IteratorObservable;\n\t}(Observable_1.Observable));\n\texports.IteratorObservable = IteratorObservable;\n\tvar StringIterator = (function () {\n\t    function StringIterator(str, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = str.length; }\n\t        this.str = str;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };\n\t    StringIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.str.charAt(this.idx++)\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return StringIterator;\n\t}());\n\tvar ArrayIterator = (function () {\n\t    function ArrayIterator(arr, idx, len) {\n\t        if (idx === void 0) { idx = 0; }\n\t        if (len === void 0) { len = toLength(arr); }\n\t        this.arr = arr;\n\t        this.idx = idx;\n\t        this.len = len;\n\t    }\n\t    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };\n\t    ArrayIterator.prototype.next = function () {\n\t        return this.idx < this.len ? {\n\t            done: false,\n\t            value: this.arr[this.idx++]\n\t        } : {\n\t            done: true,\n\t            value: undefined\n\t        };\n\t    };\n\t    return ArrayIterator;\n\t}());\n\tfunction getIterator(obj) {\n\t    var i = obj[iterator_1.$$iterator];\n\t    if (!i && typeof obj === 'string') {\n\t        return new StringIterator(obj);\n\t    }\n\t    if (!i && obj.length !== undefined) {\n\t        return new ArrayIterator(obj);\n\t    }\n\t    if (!i) {\n\t        throw new TypeError('object is not iterable');\n\t    }\n\t    return obj[iterator_1.$$iterator]();\n\t}\n\tvar maxSafeInteger = Math.pow(2, 53) - 1;\n\tfunction toLength(o) {\n\t    var len = +o.length;\n\t    if (isNaN(len)) {\n\t        return 0;\n\t    }\n\t    if (len === 0 || !numberIsFinite(len)) {\n\t        return len;\n\t    }\n\t    len = sign(len) * Math.floor(Math.abs(len));\n\t    if (len <= 0) {\n\t        return 0;\n\t    }\n\t    if (len > maxSafeInteger) {\n\t        return maxSafeInteger;\n\t    }\n\t    return len;\n\t}\n\tfunction numberIsFinite(value) {\n\t    return typeof value === 'number' && root_1.root.isFinite(value);\n\t}\n\tfunction sign(value) {\n\t    var valueAsNumber = +value;\n\t    if (valueAsNumber === 0) {\n\t        return valueAsNumber;\n\t    }\n\t    if (isNaN(valueAsNumber)) {\n\t        return valueAsNumber;\n\t    }\n\t    return valueAsNumber < 0 ? -1 : 1;\n\t}\n\t//# sourceMappingURL=IteratorObservable.js.map\n\n/***/ },\n\n/***/ 89:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(11);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar ScalarObservable = (function (_super) {\n\t    __extends(ScalarObservable, _super);\n\t    function ScalarObservable(value, scheduler) {\n\t        _super.call(this);\n\t        this.value = value;\n\t        this.scheduler = scheduler;\n\t        this._isScalar = true;\n\t        if (scheduler) {\n\t            this._isScalar = false;\n\t        }\n\t    }\n\t    ScalarObservable.create = function (value, scheduler) {\n\t        return new ScalarObservable(value, scheduler);\n\t    };\n\t    ScalarObservable.dispatch = function (state) {\n\t        var done = state.done, value = state.value, subscriber = state.subscriber;\n\t        if (done) {\n\t            subscriber.complete();\n\t            return;\n\t        }\n\t        subscriber.next(value);\n\t        if (subscriber.closed) {\n\t            return;\n\t        }\n\t        state.done = true;\n\t        this.schedule(state);\n\t    };\n\t    ScalarObservable.prototype._subscribe = function (subscriber) {\n\t        var value = this.value;\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n\t                done: false, value: value, subscriber: subscriber\n\t            });\n\t        }\n\t        else {\n\t            subscriber.next(value);\n\t            if (!subscriber.closed) {\n\t                subscriber.complete();\n\t            }\n\t        }\n\t    };\n\t    return ScalarObservable;\n\t}(Observable_1.Observable));\n\texports.ScalarObservable = ScalarObservable;\n\t//# sourceMappingURL=ScalarObservable.js.map\n\n/***/ },\n\n/***/ 152:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar FromObservable_1 = __webpack_require__(150);\n\texports.from = FromObservable_1.FromObservable.create;\n\t//# sourceMappingURL=from.js.map\n\n/***/ },\n\n/***/ 153:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ArrayObservable_1 = __webpack_require__(86);\n\texports.of = ArrayObservable_1.ArrayObservable.of;\n\t//# sourceMappingURL=of.js.map\n\n/***/ },\n\n/***/ 154:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = __webpack_require__(57);\n\tvar subscribeToResult_1 = __webpack_require__(64);\n\t/**\n\t * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n\t * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n\t *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n\t *  is returned by the `selector` will be used to continue the observable chain.\n\t * @return {Observable} an observable that originates from either the source or the observable returned by the\n\t *  catch `selector` function.\n\t * @method catch\n\t * @owner Observable\n\t */\n\tfunction _catch(selector) {\n\t    var operator = new CatchOperator(selector);\n\t    var caught = this.lift(operator);\n\t    return (operator.caught = caught);\n\t}\n\texports._catch = _catch;\n\tvar CatchOperator = (function () {\n\t    function CatchOperator(selector) {\n\t        this.selector = selector;\n\t    }\n\t    CatchOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n\t    };\n\t    return CatchOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar CatchSubscriber = (function (_super) {\n\t    __extends(CatchSubscriber, _super);\n\t    function CatchSubscriber(destination, selector, caught) {\n\t        _super.call(this, destination);\n\t        this.selector = selector;\n\t        this.caught = caught;\n\t    }\n\t    // NOTE: overriding `error` instead of `_error` because we don't want\n\t    // to have this flag this subscriber as `isStopped`.\n\t    CatchSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var result = void 0;\n\t            try {\n\t                result = this.selector(err, this.caught);\n\t            }\n\t            catch (err) {\n\t                this.destination.error(err);\n\t                return;\n\t            }\n\t            this.unsubscribe();\n\t            this.destination.remove(this);\n\t            subscribeToResult_1.subscribeToResult(this, result);\n\t        }\n\t    };\n\t    return CatchSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t//# sourceMappingURL=catch.js.map\n\n/***/ },\n\n/***/ 155:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar mergeAll_1 = __webpack_require__(91);\n\t/**\n\t * Converts a higher-order Observable into a first-order Observable by\n\t * concatenating the inner Observables in order.\n\t *\n\t * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n\t * inner Observable after the other.</span>\n\t *\n\t * <img src=\"./img/concatAll.png\" width=\"100%\">\n\t *\n\t * Joins every Observable emitted by the source (a higher-order Observable), in\n\t * a serial fashion. It subscribes to each inner Observable only after the\n\t * previous inner Observable has completed, and merges all of their values into\n\t * the returned observable.\n\t *\n\t * __Warning:__ If the source Observable emits Observables quickly and\n\t * endlessly, and the inner Observables it emits generally complete slower than\n\t * the source emits, you can run into memory issues as the incoming Observables\n\t * collect in an unbounded buffer.\n\t *\n\t * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n\t * to `1`.\n\t *\n\t * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n\t * var firstOrder = higherOrder.concatAll();\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @see {@link combineAll}\n\t * @see {@link concat}\n\t * @see {@link concatMap}\n\t * @see {@link concatMapTo}\n\t * @see {@link exhaust}\n\t * @see {@link mergeAll}\n\t * @see {@link switch}\n\t * @see {@link zipAll}\n\t *\n\t * @return {Observable} An Observable emitting values from all the inner\n\t * Observables concatenated.\n\t * @method concatAll\n\t * @owner Observable\n\t */\n\tfunction concatAll() {\n\t    return this.lift(new mergeAll_1.MergeAllOperator(1));\n\t}\n\texports.concatAll = concatAll;\n\t//# sourceMappingURL=concatAll.js.map\n\n/***/ },\n\n/***/ 156:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar mergeMap_1 = __webpack_require__(92);\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable, in a serialized fashion waiting for each one to complete before\n\t * merging the next.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link concatAll}.</span>\n\t *\n\t * <img src=\"./img/concatMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an (so-called \"inner\") Observable. Each new inner Observable is\n\t * concatenated with the previous inner Observable.\n\t *\n\t * __Warning:__ if source values arrive endlessly and faster than their\n\t * corresponding inner Observables can complete, it will result in memory issues\n\t * as inner Observables amass in an unbounded buffer waiting for their turn to\n\t * be subscribed to.\n\t *\n\t * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n\t * to `1`.\n\t *\n\t * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link concat}\n\t * @see {@link concatAll}\n\t * @see {@link concatMapTo}\n\t * @see {@link exhaustMap}\n\t * @see {@link mergeMap}\n\t * @see {@link switchMap}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @return {Observable} an observable of values merged from the projected\n\t * Observables as they were subscribed to, one at a time. Optionally, these\n\t * values may have been projected from a passed `projectResult` argument.\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and taking values from each projected inner\n\t * Observable sequentially.\n\t * @method concatMap\n\t * @owner Observable\n\t */\n\tfunction concatMap(project, resultSelector) {\n\t    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));\n\t}\n\texports.concatMap = concatMap;\n\t//# sourceMappingURL=concatMap.js.map\n\n/***/ },\n\n/***/ 157:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n\t * @param {function} predicate a function for determining if an item meets a specified condition.\n\t * @param {any} [thisArg] optional object to use for `this` in the callback\n\t * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.\n\t * @method every\n\t * @owner Observable\n\t */\n\tfunction every(predicate, thisArg) {\n\t    return this.lift(new EveryOperator(predicate, thisArg, this));\n\t}\n\texports.every = every;\n\tvar EveryOperator = (function () {\n\t    function EveryOperator(predicate, thisArg, source) {\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.source = source;\n\t    }\n\t    EveryOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n\t    };\n\t    return EveryOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar EverySubscriber = (function (_super) {\n\t    __extends(EverySubscriber, _super);\n\t    function EverySubscriber(destination, predicate, thisArg, source) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.source = source;\n\t        this.index = 0;\n\t        this.thisArg = thisArg || this;\n\t    }\n\t    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n\t        this.destination.next(everyValueMatch);\n\t        this.destination.complete();\n\t    };\n\t    EverySubscriber.prototype._next = function (value) {\n\t        var result = false;\n\t        try {\n\t            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (!result) {\n\t            this.notifyComplete(false);\n\t        }\n\t    };\n\t    EverySubscriber.prototype._complete = function () {\n\t        this.notifyComplete(true);\n\t    };\n\t    return EverySubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=every.js.map\n\n/***/ },\n\n/***/ 158:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * Filter items emitted by the source Observable by only emitting those that\n\t * satisfy a specified predicate.\n\t *\n\t * <span class=\"informal\">Like\n\t * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n\t * it only emits a value from the source if it passes a criterion function.</span>\n\t *\n\t * <img src=\"./img/filter.png\" width=\"100%\">\n\t *\n\t * Similar to the well-known `Array.prototype.filter` method, this operator\n\t * takes values from the source Observable, passes them through a `predicate`\n\t * function and only emits those values that yielded `true`.\n\t *\n\t * @example <caption>Emit only click events whose target was a DIV element</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n\t * clicksOnDivs.subscribe(x => console.log(x));\n\t *\n\t * @see {@link distinct}\n\t * @see {@link distinctKey}\n\t * @see {@link distinctUntilChanged}\n\t * @see {@link distinctUntilKeyChanged}\n\t * @see {@link ignoreElements}\n\t * @see {@link partition}\n\t * @see {@link skip}\n\t *\n\t * @param {function(value: T, index: number): boolean} predicate A function that\n\t * evaluates each value emitted by the source Observable. If it returns `true`,\n\t * the value is emitted, if `false` the value is not passed to the output\n\t * Observable. The `index` parameter is the number `i` for the i-th source\n\t * emission that has happened since the subscription, starting from the number\n\t * `0`.\n\t * @param {any} [thisArg] An optional argument to determine the value of `this`\n\t * in the `predicate` function.\n\t * @return {Observable} An Observable of values from the source that were\n\t * allowed by the `predicate` function.\n\t * @method filter\n\t * @owner Observable\n\t */\n\tfunction filter(predicate, thisArg) {\n\t    return this.lift(new FilterOperator(predicate, thisArg));\n\t}\n\texports.filter = filter;\n\tvar FilterOperator = (function () {\n\t    function FilterOperator(predicate, thisArg) {\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t    }\n\t    FilterOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n\t    };\n\t    return FilterOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar FilterSubscriber = (function (_super) {\n\t    __extends(FilterSubscriber, _super);\n\t    function FilterSubscriber(destination, predicate, thisArg) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.count = 0;\n\t        this.predicate = predicate;\n\t    }\n\t    // the try catch block below is left specifically for\n\t    // optimization and perf reasons. a tryCatcher is not necessary here.\n\t    FilterSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.predicate.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            this.destination.next(value);\n\t        }\n\t    };\n\t    return FilterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=filter.js.map\n\n/***/ },\n\n/***/ 159:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\tvar EmptyError_1 = __webpack_require__(62);\n\t/**\n\t * Emits only the first value (or the first value that meets some condition)\n\t * emitted by the source Observable.\n\t *\n\t * <span class=\"informal\">Emits only the first value. Or emits only the first\n\t * value that passes some test.</span>\n\t *\n\t * <img src=\"./img/first.png\" width=\"100%\">\n\t *\n\t * If called with no arguments, `first` emits the first value of the source\n\t * Observable, then completes. If called with a `predicate` function, `first`\n\t * emits the first value of the source that matches the specified condition. It\n\t * may also take a `resultSelector` function to produce the output value from\n\t * the input value, and a `defaultValue` to emit in case the source completes\n\t * before it is able to emit a valid value. Throws an error if `defaultValue`\n\t * was not provided and a matching element is not found.\n\t *\n\t * @example <caption>Emit only the first click that happens on the DOM</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.first();\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @example <caption>Emits the first click that happens on a DIV</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link filter}\n\t * @see {@link find}\n\t * @see {@link take}\n\t *\n\t * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n\t * callback if the Observable completes before any `next` notification was sent.\n\t *\n\t * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n\t * An optional function called with each item to test for condition matching.\n\t * @param {function(value: T, index: number): R} [resultSelector] A function to\n\t * produce the value on the output Observable based on the values\n\t * and the indices of the source Observable. The arguments passed to this\n\t * function are:\n\t * - `value`: the value that was emitted on the source.\n\t * - `index`: the \"index\" of the value from the source.\n\t * @param {R} [defaultValue] The default value emitted in case no valid value\n\t * was found on the source.\n\t * @return {Observable<T|R>} an Observable of the first item that matches the\n\t * condition.\n\t * @method first\n\t * @owner Observable\n\t */\n\tfunction first(predicate, resultSelector, defaultValue) {\n\t    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));\n\t}\n\texports.first = first;\n\tvar FirstOperator = (function () {\n\t    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t    }\n\t    FirstOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n\t    };\n\t    return FirstOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar FirstSubscriber = (function (_super) {\n\t    __extends(FirstSubscriber, _super);\n\t    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t        this.index = 0;\n\t        this.hasCompleted = false;\n\t    }\n\t    FirstSubscriber.prototype._next = function (value) {\n\t        var index = this.index++;\n\t        if (this.predicate) {\n\t            this._tryPredicate(value, index);\n\t        }\n\t        else {\n\t            this._emit(value, index);\n\t        }\n\t    };\n\t    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.predicate(value, index, this.source);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            this._emit(value, index);\n\t        }\n\t    };\n\t    FirstSubscriber.prototype._emit = function (value, index) {\n\t        if (this.resultSelector) {\n\t            this._tryResultSelector(value, index);\n\t            return;\n\t        }\n\t        this._emitFinal(value);\n\t    };\n\t    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this._emitFinal(result);\n\t    };\n\t    FirstSubscriber.prototype._emitFinal = function (value) {\n\t        var destination = this.destination;\n\t        destination.next(value);\n\t        destination.complete();\n\t        this.hasCompleted = true;\n\t    };\n\t    FirstSubscriber.prototype._complete = function () {\n\t        var destination = this.destination;\n\t        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n\t            destination.next(this.defaultValue);\n\t            destination.complete();\n\t        }\n\t        else if (!this.hasCompleted) {\n\t            destination.error(new EmptyError_1.EmptyError);\n\t        }\n\t    };\n\t    return FirstSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=first.js.map\n\n/***/ },\n\n/***/ 160:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\tvar EmptyError_1 = __webpack_require__(62);\n\t/**\n\t * Returns an Observable that emits only the last item emitted by the source Observable.\n\t * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n\t * the last item from the source Observable, the resulting Observable will emit the last item\n\t * from the source Observable that satisfies the predicate.\n\t *\n\t * <img src=\"./img/last.png\" width=\"100%\">\n\t *\n\t * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n\t * callback if the Observable completes before any `next` notification was sent.\n\t * @param {function} predicate - the condition any source emitted item has to satisfy.\n\t * @return {Observable} an Observable that emits only the last item satisfying the given condition\n\t * from the source, or an NoSuchElementException if no such items are emitted.\n\t * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n\t * @method last\n\t * @owner Observable\n\t */\n\tfunction last(predicate, resultSelector, defaultValue) {\n\t    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));\n\t}\n\texports.last = last;\n\tvar LastOperator = (function () {\n\t    function LastOperator(predicate, resultSelector, defaultValue, source) {\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t    }\n\t    LastOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n\t    };\n\t    return LastOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar LastSubscriber = (function (_super) {\n\t    __extends(LastSubscriber, _super);\n\t    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.resultSelector = resultSelector;\n\t        this.defaultValue = defaultValue;\n\t        this.source = source;\n\t        this.hasValue = false;\n\t        this.index = 0;\n\t        if (typeof defaultValue !== 'undefined') {\n\t            this.lastValue = defaultValue;\n\t            this.hasValue = true;\n\t        }\n\t    }\n\t    LastSubscriber.prototype._next = function (value) {\n\t        var index = this.index++;\n\t        if (this.predicate) {\n\t            this._tryPredicate(value, index);\n\t        }\n\t        else {\n\t            if (this.resultSelector) {\n\t                this._tryResultSelector(value, index);\n\t                return;\n\t            }\n\t            this.lastValue = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    LastSubscriber.prototype._tryPredicate = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.predicate(value, index, this.source);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            if (this.resultSelector) {\n\t                this._tryResultSelector(value, index);\n\t                return;\n\t            }\n\t            this.lastValue = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.lastValue = result;\n\t        this.hasValue = true;\n\t    };\n\t    LastSubscriber.prototype._complete = function () {\n\t        var destination = this.destination;\n\t        if (this.hasValue) {\n\t            destination.next(this.lastValue);\n\t            destination.complete();\n\t        }\n\t        else {\n\t            destination.error(new EmptyError_1.EmptyError);\n\t        }\n\t    };\n\t    return LastSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=last.js.map\n\n/***/ },\n\n/***/ 161:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * Applies a given `project` function to each value emitted by the source\n\t * Observable, and emits the resulting values as an Observable.\n\t *\n\t * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n\t * it passes each source value through a transformation function to get\n\t * corresponding output values.</span>\n\t *\n\t * <img src=\"./img/map.png\" width=\"100%\">\n\t *\n\t * Similar to the well known `Array.prototype.map` function, this operator\n\t * applies a projection to each value and emits that projection in the output\n\t * Observable.\n\t *\n\t * @example <caption>Map every every click to the clientX position of that click</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var positions = clicks.map(ev => ev.clientX);\n\t * positions.subscribe(x => console.log(x));\n\t *\n\t * @see {@link mapTo}\n\t * @see {@link pluck}\n\t *\n\t * @param {function(value: T, index: number): R} project The function to apply\n\t * to each `value` emitted by the source Observable. The `index` parameter is\n\t * the number `i` for the i-th emission that has happened since the\n\t * subscription, starting from the number `0`.\n\t * @param {any} [thisArg] An optional argument to define what `this` is in the\n\t * `project` function.\n\t * @return {Observable<R>} An Observable that emits the values from the source\n\t * Observable transformed by the given `project` function.\n\t * @method map\n\t * @owner Observable\n\t */\n\tfunction map(project, thisArg) {\n\t    if (typeof project !== 'function') {\n\t        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n\t    }\n\t    return this.lift(new MapOperator(project, thisArg));\n\t}\n\texports.map = map;\n\tvar MapOperator = (function () {\n\t    function MapOperator(project, thisArg) {\n\t        this.project = project;\n\t        this.thisArg = thisArg;\n\t    }\n\t    MapOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n\t    };\n\t    return MapOperator;\n\t}());\n\texports.MapOperator = MapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MapSubscriber = (function (_super) {\n\t    __extends(MapSubscriber, _super);\n\t    function MapSubscriber(destination, project, thisArg) {\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.count = 0;\n\t        this.thisArg = thisArg || this;\n\t    }\n\t    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n\t    // using try/catch optimizations.\n\t    MapSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.project.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    return MapSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=map.js.map\n\n/***/ },\n\n/***/ 91:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = __webpack_require__(57);\n\tvar subscribeToResult_1 = __webpack_require__(64);\n\t/**\n\t * Converts a higher-order Observable into a first-order Observable which\n\t * concurrently delivers all values that are emitted on the inner Observables.\n\t *\n\t * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n\t *\n\t * <img src=\"./img/mergeAll.png\" width=\"100%\">\n\t *\n\t * `mergeAll` subscribes to an Observable that emits Observables, also known as\n\t * a higher-order Observable. Each time it observes one of these emitted inner\n\t * Observables, it subscribes to that and delivers all the values from the\n\t * inner Observable on the output Observable. The output Observable only\n\t * completes once all inner Observables have completed. Any error delivered by\n\t * a inner Observable will be immediately emitted on the output Observable.\n\t *\n\t * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n\t * var firstOrder = higherOrder.mergeAll();\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n\t * var firstOrder = higherOrder.mergeAll(2);\n\t * firstOrder.subscribe(x => console.log(x));\n\t *\n\t * @see {@link combineAll}\n\t * @see {@link concatAll}\n\t * @see {@link exhaust}\n\t * @see {@link merge}\n\t * @see {@link mergeMap}\n\t * @see {@link mergeMapTo}\n\t * @see {@link mergeScan}\n\t * @see {@link switch}\n\t * @see {@link zipAll}\n\t *\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n\t * Observables being subscribed to concurrently.\n\t * @return {Observable} An Observable that emits values coming from all the\n\t * inner Observables emitted by the source Observable.\n\t * @method mergeAll\n\t * @owner Observable\n\t */\n\tfunction mergeAll(concurrent) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    return this.lift(new MergeAllOperator(concurrent));\n\t}\n\texports.mergeAll = mergeAll;\n\tvar MergeAllOperator = (function () {\n\t    function MergeAllOperator(concurrent) {\n\t        this.concurrent = concurrent;\n\t    }\n\t    MergeAllOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new MergeAllSubscriber(observer, this.concurrent));\n\t    };\n\t    return MergeAllOperator;\n\t}());\n\texports.MergeAllOperator = MergeAllOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MergeAllSubscriber = (function (_super) {\n\t    __extends(MergeAllSubscriber, _super);\n\t    function MergeAllSubscriber(destination, concurrent) {\n\t        _super.call(this, destination);\n\t        this.concurrent = concurrent;\n\t        this.hasCompleted = false;\n\t        this.buffer = [];\n\t        this.active = 0;\n\t    }\n\t    MergeAllSubscriber.prototype._next = function (observable) {\n\t        if (this.active < this.concurrent) {\n\t            this.active++;\n\t            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n\t        }\n\t        else {\n\t            this.buffer.push(observable);\n\t        }\n\t    };\n\t    MergeAllSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.active === 0 && this.buffer.length === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        else if (this.active === 0 && this.hasCompleted) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return MergeAllSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\texports.MergeAllSubscriber = MergeAllSubscriber;\n\t//# sourceMappingURL=mergeAll.js.map\n\n/***/ },\n\n/***/ 92:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar subscribeToResult_1 = __webpack_require__(64);\n\tvar OuterSubscriber_1 = __webpack_require__(57);\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link mergeAll}.</span>\n\t *\n\t * <img src=\"./img/mergeMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an Observable, and then merging those resulting Observables and\n\t * emitting the results of this merger.\n\t *\n\t * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n\t * var letters = Rx.Observable.of('a', 'b', 'c');\n\t * var result = letters.mergeMap(x =>\n\t *   Rx.Observable.interval(1000).map(i => x+i)\n\t * );\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link concatMap}\n\t * @see {@link exhaustMap}\n\t * @see {@link merge}\n\t * @see {@link mergeAll}\n\t * @see {@link mergeMapTo}\n\t * @see {@link mergeScan}\n\t * @see {@link switchMap}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n\t * Observables being subscribed to concurrently.\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and merging the results of the Observables obtained\n\t * from this transformation.\n\t * @method mergeMap\n\t * @owner Observable\n\t */\n\tfunction mergeMap(project, resultSelector, concurrent) {\n\t    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t    if (typeof resultSelector === 'number') {\n\t        concurrent = resultSelector;\n\t        resultSelector = null;\n\t    }\n\t    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n\t}\n\texports.mergeMap = mergeMap;\n\tvar MergeMapOperator = (function () {\n\t    function MergeMapOperator(project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t    }\n\t    MergeMapOperator.prototype.call = function (observer, source) {\n\t        return source._subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n\t    };\n\t    return MergeMapOperator;\n\t}());\n\texports.MergeMapOperator = MergeMapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MergeMapSubscriber = (function (_super) {\n\t    __extends(MergeMapSubscriber, _super);\n\t    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n\t        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.concurrent = concurrent;\n\t        this.hasCompleted = false;\n\t        this.buffer = [];\n\t        this.active = 0;\n\t        this.index = 0;\n\t    }\n\t    MergeMapSubscriber.prototype._next = function (value) {\n\t        if (this.active < this.concurrent) {\n\t            this._tryNext(value);\n\t        }\n\t        else {\n\t            this.buffer.push(value);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._tryNext = function (value) {\n\t        var result;\n\t        var index = this.index++;\n\t        try {\n\t            result = this.project(value, index);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.active++;\n\t        this._innerSub(result, value, index);\n\t    };\n\t    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n\t        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n\t    };\n\t    MergeMapSubscriber.prototype._complete = function () {\n\t        this.hasCompleted = true;\n\t        if (this.active === 0 && this.buffer.length === 0) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        if (this.resultSelector) {\n\t            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        else {\n\t            this.destination.next(innerValue);\n\t        }\n\t    };\n\t    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        var buffer = this.buffer;\n\t        this.remove(innerSub);\n\t        this.active--;\n\t        if (buffer.length > 0) {\n\t            this._next(buffer.shift());\n\t        }\n\t        else if (this.active === 0 && this.hasCompleted) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    return MergeMapSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\texports.MergeMapSubscriber = MergeMapSubscriber;\n\t//# sourceMappingURL=mergeMap.js.map\n\n/***/ },\n\n/***/ 162:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\tvar Notification_1 = __webpack_require__(146);\n\t/**\n\t * @see {@link Notification}\n\t *\n\t * @param scheduler\n\t * @param delay\n\t * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n\t * @method observeOn\n\t * @owner Observable\n\t */\n\tfunction observeOn(scheduler, delay) {\n\t    if (delay === void 0) { delay = 0; }\n\t    return this.lift(new ObserveOnOperator(scheduler, delay));\n\t}\n\texports.observeOn = observeOn;\n\tvar ObserveOnOperator = (function () {\n\t    function ObserveOnOperator(scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n\t    };\n\t    return ObserveOnOperator;\n\t}());\n\texports.ObserveOnOperator = ObserveOnOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ObserveOnSubscriber = (function (_super) {\n\t    __extends(ObserveOnSubscriber, _super);\n\t    function ObserveOnSubscriber(destination, scheduler, delay) {\n\t        if (delay === void 0) { delay = 0; }\n\t        _super.call(this, destination);\n\t        this.scheduler = scheduler;\n\t        this.delay = delay;\n\t    }\n\t    ObserveOnSubscriber.dispatch = function (arg) {\n\t        var notification = arg.notification, destination = arg.destination;\n\t        notification.observe(destination);\n\t    };\n\t    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n\t        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n\t    };\n\t    ObserveOnSubscriber.prototype._next = function (value) {\n\t        this.scheduleMessage(Notification_1.Notification.createNext(value));\n\t    };\n\t    ObserveOnSubscriber.prototype._error = function (err) {\n\t        this.scheduleMessage(Notification_1.Notification.createError(err));\n\t    };\n\t    ObserveOnSubscriber.prototype._complete = function () {\n\t        this.scheduleMessage(Notification_1.Notification.createComplete());\n\t    };\n\t    return ObserveOnSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.ObserveOnSubscriber = ObserveOnSubscriber;\n\tvar ObserveOnMessage = (function () {\n\t    function ObserveOnMessage(notification, destination) {\n\t        this.notification = notification;\n\t        this.destination = destination;\n\t    }\n\t    return ObserveOnMessage;\n\t}());\n\texports.ObserveOnMessage = ObserveOnMessage;\n\t//# sourceMappingURL=observeOn.js.map\n\n/***/ },\n\n/***/ 163:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(16);\n\t/**\n\t * Applies an accumulator function over the source Observable, and returns the\n\t * accumulated result when the source completes, given an optional seed value.\n\t *\n\t * <span class=\"informal\">Combines together all values emitted on the source,\n\t * using an accumulator function that knows how to join a new source value into\n\t * the accumulation from the past.</span>\n\t *\n\t * <img src=\"./img/reduce.png\" width=\"100%\">\n\t *\n\t * Like\n\t * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n\t * `reduce` applies an `accumulator` function against an accumulation and each\n\t * value of the source Observable (from the past) to reduce it to a single\n\t * value, emitted on the output Observable. Note that `reduce` will only emit\n\t * one value, only when the source Observable completes. It is equivalent to\n\t * applying operator {@link scan} followed by operator {@link last}.\n\t *\n\t * Returns an Observable that applies a specified `accumulator` function to each\n\t * item emitted by the source Observable. If a `seed` value is specified, then\n\t * that value will be used as the initial value for the accumulator. If no seed\n\t * value is specified, the first item of the source is used as the seed.\n\t *\n\t * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n\t * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n\t *   .takeUntil(Rx.Observable.interval(5000));\n\t * var ones = clicksInFiveSeconds.mapTo(1);\n\t * var seed = 0;\n\t * var count = ones.reduce((acc, one) => acc + one, seed);\n\t * count.subscribe(x => console.log(x));\n\t *\n\t * @see {@link count}\n\t * @see {@link expand}\n\t * @see {@link mergeScan}\n\t * @see {@link scan}\n\t *\n\t * @param {function(acc: R, value: T): R} accumulator The accumulator function\n\t * called on each source value.\n\t * @param {R} [seed] The initial accumulation value.\n\t * @return {Observable<R>} An observable of the accumulated values.\n\t * @return {Observable<R>} An Observable that emits a single value that is the\n\t * result of accumulating the values emitted by the source Observable.\n\t * @method reduce\n\t * @owner Observable\n\t */\n\tfunction reduce(accumulator, seed) {\n\t    return this.lift(new ReduceOperator(accumulator, seed));\n\t}\n\texports.reduce = reduce;\n\tvar ReduceOperator = (function () {\n\t    function ReduceOperator(accumulator, seed) {\n\t        this.accumulator = accumulator;\n\t        this.seed = seed;\n\t    }\n\t    ReduceOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed));\n\t    };\n\t    return ReduceOperator;\n\t}());\n\texports.ReduceOperator = ReduceOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar ReduceSubscriber = (function (_super) {\n\t    __extends(ReduceSubscriber, _super);\n\t    function ReduceSubscriber(destination, accumulator, seed) {\n\t        _super.call(this, destination);\n\t        this.accumulator = accumulator;\n\t        this.hasValue = false;\n\t        this.acc = seed;\n\t        this.accumulator = accumulator;\n\t        this.hasSeed = typeof seed !== 'undefined';\n\t    }\n\t    ReduceSubscriber.prototype._next = function (value) {\n\t        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n\t            this._tryReduce(value);\n\t        }\n\t        else {\n\t            this.acc = value;\n\t            this.hasValue = true;\n\t        }\n\t    };\n\t    ReduceSubscriber.prototype._tryReduce = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.accumulator(this.acc, value);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.acc = result;\n\t    };\n\t    ReduceSubscriber.prototype._complete = function () {\n\t        if (this.hasValue || this.hasSeed) {\n\t            this.destination.next(this.acc);\n\t        }\n\t        this.destination.complete();\n\t    };\n\t    return ReduceSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.ReduceSubscriber = ReduceSubscriber;\n\t//# sourceMappingURL=reduce.js.map\n\n/***/ },\n\n/***/ 59:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(26);\n\tvar Symbol = root_1.root.Symbol;\n\tif (typeof Symbol === 'function') {\n\t    if (Symbol.iterator) {\n\t        exports.$$iterator = Symbol.iterator;\n\t    }\n\t    else if (typeof Symbol.for === 'function') {\n\t        exports.$$iterator = Symbol.for('iterator');\n\t    }\n\t}\n\telse {\n\t    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {\n\t        // Bug for mozilla version\n\t        exports.$$iterator = '@@iterator';\n\t    }\n\t    else if (root_1.root.Map) {\n\t        // es6-shim specific logic\n\t        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            var key = keys[i];\n\t            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {\n\t                exports.$$iterator = key;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t    else {\n\t        exports.$$iterator = '@@iterator';\n\t    }\n\t}\n\t//# sourceMappingURL=iterator.js.map\n\n/***/ },\n\n/***/ 62:\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * An error thrown when an Observable or a sequence was queried but has no\n\t * elements.\n\t *\n\t * @see {@link first}\n\t * @see {@link last}\n\t * @see {@link single}\n\t *\n\t * @class EmptyError\n\t */\n\tvar EmptyError = (function (_super) {\n\t    __extends(EmptyError, _super);\n\t    function EmptyError() {\n\t        var err = _super.call(this, 'no elements in sequence');\n\t        this.name = err.name = 'EmptyError';\n\t        this.stack = err.stack;\n\t        this.message = err.message;\n\t    }\n\t    return EmptyError;\n\t}(Error));\n\texports.EmptyError = EmptyError;\n\t//# sourceMappingURL=EmptyError.js.map\n\n/***/ },\n\n/***/ 96:\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isPromise(value) {\n\t    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n\t}\n\texports.isPromise = isPromise;\n\t//# sourceMappingURL=isPromise.js.map\n\n/***/ },\n\n/***/ 167:\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isScheduler(value) {\n\t    return value && typeof value.schedule === 'function';\n\t}\n\texports.isScheduler = isScheduler;\n\t//# sourceMappingURL=isScheduler.js.map\n\n/***/ },\n\n/***/ 64:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(26);\n\tvar isArray_1 = __webpack_require__(63);\n\tvar isPromise_1 = __webpack_require__(96);\n\tvar Observable_1 = __webpack_require__(11);\n\tvar iterator_1 = __webpack_require__(59);\n\tvar InnerSubscriber_1 = __webpack_require__(145);\n\tvar observable_1 = __webpack_require__(60);\n\tfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n\t    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\t    if (destination.closed) {\n\t        return null;\n\t    }\n\t    if (result instanceof Observable_1.Observable) {\n\t        if (result._isScalar) {\n\t            destination.next(result.value);\n\t            destination.complete();\n\t            return null;\n\t        }\n\t        else {\n\t            return result.subscribe(destination);\n\t        }\n\t    }\n\t    if (isArray_1.isArray(result)) {\n\t        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n\t            destination.next(result[i]);\n\t        }\n\t        if (!destination.closed) {\n\t            destination.complete();\n\t        }\n\t    }\n\t    else if (isPromise_1.isPromise(result)) {\n\t        result.then(function (value) {\n\t            if (!destination.closed) {\n\t                destination.next(value);\n\t                destination.complete();\n\t            }\n\t        }, function (err) { return destination.error(err); })\n\t            .then(null, function (err) {\n\t            // Escaping the Promise trap: globally throw unhandled errors\n\t            root_1.root.setTimeout(function () { throw err; });\n\t        });\n\t        return destination;\n\t    }\n\t    else if (typeof result[iterator_1.$$iterator] === 'function') {\n\t        var iterator = result[iterator_1.$$iterator]();\n\t        do {\n\t            var item = iterator.next();\n\t            if (item.done) {\n\t                destination.complete();\n\t                break;\n\t            }\n\t            destination.next(item.value);\n\t            if (destination.closed) {\n\t                break;\n\t            }\n\t        } while (true);\n\t    }\n\t    else if (typeof result[observable_1.$$observable] === 'function') {\n\t        var obs = result[observable_1.$$observable]();\n\t        if (typeof obs.subscribe !== 'function') {\n\t            destination.error(new Error('invalid observable'));\n\t        }\n\t        else {\n\t            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n\t        }\n\t    }\n\t    else {\n\t        destination.error(new TypeError('unknown type returned'));\n\t    }\n\t    return null;\n\t}\n\texports.subscribeToResult = subscribeToResult;\n\t//# sourceMappingURL=subscribeToResult.js.map\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** main.3779b4e91740181a7157.bundle.js\n **/","/// <reference path=\"../lib/vs/index.d.ts\" />\r\nexport * from './timeline/index';\r\nexport * from './network/index';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/index.ts\n **/","import * as Vis from 'vis';\r\n\r\nimport { VisDataSetOptions, VisDataSetQueueOptions, VisId } from '../timeline/index';\r\n\r\nexport { VisId } from '../timeline/index';\r\nexport type VisNetworkEvents = Vis.NetworkEvents;\r\nexport interface VisClusterOptions extends Vis.IClusterOptions {}\r\nexport interface VisOpenClusterOptions extends Vis.IOpenClusterOptions {}\r\nexport interface VisNetworkData extends Vis.IData {}\r\nexport interface VisNode extends Vis.INode {}\r\nexport interface VisEdge extends Vis.IEdge {}\r\nexport interface VisNodeSelectionOptions extends Vis.DataSelectionOptions<VisNode> {}\r\nexport interface VisEdgeSelectionOptions extends Vis.DataSelectionOptions<VisEdge> {}\r\nexport interface VisFitOptions extends Vis.IFitOptions {}\r\nexport interface VisNetworkOptions extends Vis.IOptions {}\r\nexport interface VisEdgeOptions extends Vis.IEdgeOptions {}\r\nexport class VisNetwork extends Vis.Network {}\r\nexport interface VisNodeOptions extends Vis.INodeOptions {}\r\n\r\nexport class VisNodes extends Vis.DataSet<VisNode> {\r\n    public constructor(data?: VisNode[], options?: VisDataSetOptions) {\r\n        super(data, options);\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this.length;\r\n    }\r\n\r\n    public add(data: VisNode | VisNode[], senderId?: VisId): VisId[] {\r\n        return super.add(data, senderId);\r\n    }\r\n\r\n    public clear(senderId?: VisId): VisId[] {\r\n        return super.clear(senderId);\r\n    }\r\n\r\n    public distinct(field: string): any[] {\r\n        return super.distinct(field);\r\n    }\r\n\r\n    public flush(): void {\r\n        super.flush();\r\n    }\r\n\r\n    public forEach(callback: (item: VisNode, id: VisId) => void, options?: VisNodeSelectionOptions): void {\r\n        super.forEach(callback, options);\r\n    }\r\n\r\n    public getAll(options?: VisNodeSelectionOptions): VisNode[] {\r\n        return super.get(options);\r\n    }\r\n\r\n    public getById(id: VisId, options?: VisNodeSelectionOptions): VisNode {\r\n        return super.get(id, options);\r\n    }\r\n\r\n    public getByIds(ids: VisId[], options?: VisNodeSelectionOptions): VisNode[] {\r\n        return super.get(ids, options);\r\n    }\r\n\r\n    public getDataSet(): VisNodes {\r\n        return super.getDataSet() as VisNodes;\r\n    }\r\n\r\n    public getIds(options?: VisNodeSelectionOptions): VisId[] {\r\n        return super.getIds(options);\r\n    }\r\n\r\n    public map(callback: (item: VisNode, id: VisId) => any, options?: VisNodeSelectionOptions): any[] {\r\n        return super.map(callback, options);\r\n    }\r\n\r\n    public max(field: string): VisNode {\r\n        return super.max(field);\r\n    }\r\n\r\n    public min(field: string): VisNode {\r\n        return super.min(field);\r\n    }\r\n\r\n    public on(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.on(event, callback);\r\n    }\r\n\r\n    public off(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.off(event, callback);\r\n    }\r\n\r\n    public removeItems(ids: VisId[], senderId?: VisId): VisId[] {\r\n        return super.remove(ids, senderId);\r\n    }\r\n\r\n    public setOptions(options?: VisDataSetQueueOptions): void {\r\n        super.setOptions(options);\r\n    }\r\n\r\n    public update(data: VisNode[], senderId?: VisId): VisId[] {\r\n        return super.update(data, senderId);\r\n    }\r\n}\r\n\r\nexport class VisEdges extends Vis.DataSet<VisEdge> {\r\n    public constructor(data?: VisEdge[], options?: VisDataSetOptions) {\r\n        super(data, options);\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this.length;\r\n    }\r\n\r\n    public add(data: VisEdge | VisEdge[], senderId?: VisId): VisId[] {\r\n        return super.add(data, senderId);\r\n    }\r\n\r\n    public clear(senderId?: VisId): VisId[] {\r\n        return super.clear(senderId);\r\n    }\r\n\r\n    public distinct(field: string): any[] {\r\n        return super.distinct(field);\r\n    }\r\n\r\n    public flush(): void {\r\n        super.flush();\r\n    }\r\n\r\n    public forEach(callback: (item: VisEdge, id: VisId) => void, options?: VisEdgeSelectionOptions): void {\r\n        super.forEach(callback, options);\r\n    }\r\n\r\n    public getAll(options?: VisEdgeSelectionOptions): VisEdge[] {\r\n        return super.get(options);\r\n    }\r\n\r\n    public getById(id: VisId, options?: VisEdgeSelectionOptions): VisEdge {\r\n        return super.get(id, options);\r\n    }\r\n\r\n    public getByIds(ids: VisId[], options?: VisEdgeSelectionOptions): VisEdge[] {\r\n        return super.get(ids, options);\r\n    }\r\n\r\n    public getDataSet(): VisEdges {\r\n        return super.getDataSet() as VisEdges;\r\n    }\r\n\r\n    public getIds(options?: VisEdgeSelectionOptions): VisId[] {\r\n        return super.getIds(options);\r\n    }\r\n\r\n    public map(callback: (item: VisEdge, id: VisId) => any, options?: VisEdgeSelectionOptions): any[] {\r\n        return super.map(callback, options);\r\n    }\r\n\r\n    public max(field: string): VisEdge {\r\n        return super.max(field);\r\n    }\r\n\r\n    public min(field: string): VisEdge {\r\n        return super.min(field);\r\n    }\r\n\r\n    public on(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.on(event, callback);\r\n    }\r\n\r\n    public off(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.off(event, callback);\r\n    }\r\n\r\n    public removeItems(ids: VisId[], senderId?: VisId): VisId[] {\r\n        return super.remove(ids, senderId);\r\n    }\r\n\r\n    public setOptions(options?: VisDataSetQueueOptions): void {\r\n        super.setOptions(options);\r\n    }\r\n\r\n    public update(data: VisEdge[], senderId?: VisId): VisId[] {\r\n        return super.update(data, senderId);\r\n    }\r\n}\r\n\r\nexport * from './vis-network.directive';\r\nexport * from './vis-network.service';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/network/index.ts\n **/","import {\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Input,\r\n  OnChanges,\r\n  OnDestroy,\r\n  OnInit,\r\n  Output,\r\n  SimpleChange } from '@angular/core';\r\n\r\nimport { VisNetworkService } from './vis-network.service';\r\n\r\nimport {\r\n  VisNetworkData,\r\n  VisNetworkOptions,\r\n} from './index';\r\n\r\n/**\r\n * Use this directive with a div container to show network data.\r\n * \r\n * @export\r\n * @class VisNetworkDirective\r\n * @implements {OnInit}\r\n * @implements {OnDestroy}\r\n * @implements {OnChanges}\r\n */\r\n@Directive({\r\n  selector: '[visNetwork]',\r\n})\r\nexport class VisNetworkDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n  /**\r\n   * The name or identifier of the network (must be unique in your application).\r\n   * This property is used once on init and must not be changed.\r\n   * \r\n   * @type {string}\r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  @Input('visNetwork')\r\n  public visNetwork: string;\r\n\r\n  /**\r\n   * The data that will be used to create the network.\r\n   * Changes to the nodes or edges property won't be detected but\r\n   * changes to the reference of this object.\r\n   * Changes lead to a call to setData of this network instance.\r\n   * \r\n   * @type {VisNetworkData}\r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  @Input()\r\n  public visNetworkData: VisNetworkData;\r\n\r\n  /**\r\n   * The options that will be used with this network instance.\r\n   * Only reference changes to the whole options object will be detected\r\n   * but not changes to properties.\r\n   * Changes lead to a call to setOptions of the network instance.\r\n   * \r\n   * @type {VisNetworkOptions}\r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  @Input()\r\n  public visNetworkOptions: VisNetworkOptions;\r\n\r\n  /**\r\n   * This event will be raised when the network is initialized.\r\n   * At this point of time the network is successfully registered\r\n   * with the VisNetworkService and you can register to events.\r\n   * The event data is the name of the network as a string.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  @Output()\r\n  public initialized: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  private visNetworkContainer: any;\r\n  private isInitialized: boolean = false;\r\n\r\n  /**\r\n   * Creates an instance of VisNetworkDirective.\r\n   * \r\n   * @param {ElementRef} elementRef The HTML element reference.\r\n   * @param {VisNetworkService} visNetworkService The VisNetworkService.\r\n   * \r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  public constructor(private elementRef: ElementRef, private visNetworkService: VisNetworkService) {\r\n    this.visNetworkContainer = elementRef.nativeElement;\r\n  }\r\n\r\n  /**\r\n   * Create the network when at least visNetwork and visNetworkData\r\n   * are defined. \r\n   * \r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  public ngOnInit(): void {\r\n    if (!this.isInitialized && this.visNetwork && this.visNetworkData) {\r\n      this.createNetwork();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the network data or options on reference changes to\r\n   * the visNetworkData or visNetworkOptions properties.\r\n   * \r\n   * @param {{[propName: string]: SimpleChange}} changes\r\n   * \r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  public ngOnChanges(changes: {[propName: string]: SimpleChange}): void {\r\n\r\n    if (!this.isInitialized && this.visNetwork && this.visNetworkData) {\r\n      this.createNetwork();\r\n    }\r\n\r\n    for (let propertyName in changes) {\r\n      if (changes.hasOwnProperty(propertyName)) {\r\n        let change = changes[propertyName];\r\n        if (!change.isFirstChange()) {\r\n          if (propertyName === 'visNetworkData') {\r\n            this.visNetworkService.setData(this.visNetwork, changes[propertyName].currentValue);\r\n          }\r\n          if (propertyName === 'visNetworkOptions') {\r\n            this.visNetworkService.setOptions(this.visNetwork, changes[propertyName].currentValue);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calls the destroy function for this network instance.\r\n   * \r\n   * \r\n   * @memberOf VisNetworkDirective\r\n   */\r\n  public ngOnDestroy(): void {\r\n    this.isInitialized = false;\r\n    this.visNetworkService.destroy(this.visNetwork);\r\n  }\r\n\r\n  private createNetwork(): void {\r\n    this.visNetworkService.create(\r\n      this.visNetwork,\r\n      this.visNetworkContainer,\r\n      this.visNetworkData,\r\n      this.visNetworkOptions);\r\n    this.isInitialized = true;\r\n    this.initialized.emit(this.visNetwork);\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/network/vis-network.directive.ts\n **/","import { EventEmitter, Injectable } from '@angular/core';\r\n\r\nimport {\r\n  VisClusterOptions,\r\n  VisEdgeOptions,\r\n  VisFitOptions,\r\n  VisId,\r\n  VisNetwork,\r\n  VisNetworkData,\r\n  VisNetworkEvents,\r\n  VisNetworkOptions,\r\n  VisNodeOptions,\r\n  VisOpenClusterOptions } from './index';\r\n\r\n/**\r\n * A service to create, manage and control VisNetwork instances.\r\n * \r\n * @export\r\n * @class VisNetworkService\r\n */\r\n@Injectable()\r\nexport class VisNetworkService {\r\n\r\n  /**\r\n   * Fired when the user clicks the mouse or taps on a touchscreen device.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public click: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the user double clicks the mouse or double taps on a touchscreen device.\r\n   * Since a double click is in fact 2 clicks, 2 click events are fired, followed by a double click event.\r\n   * If you do not want to use the click events if a double click event is fired,\r\n   * just check the time between click events before processing them.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public doubleClick: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the user click on the canvas with the right mouse button.\r\n   * The right mouse button does not select by default.\r\n   * You can use the method getNodeAt to select the node if you want.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public oncontext: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the user clicks and holds the mouse or taps and holds on a touchscreen device.\r\n   * A click event is also fired in this case.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public hold: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired after drawing on the canvas has been completed.\r\n   * Can be used to draw on top of the network.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public release: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the selection has changed by user action.\r\n   * This means a node or edge has been selected, added to the selection or deselected.\r\n   * All select events are only triggered on click and hold.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public select: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a node has been selected by the user.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public selectNode: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a edge has been selected by the user.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public selectEdge: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a node (or nodes) has (or have) been deselected by the user.\r\n   * The previous selection is the list of nodes and edges that were selected before the last user event.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public deselectNode: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a edge (or edges) has (or have) been deselected by the user.\r\n   * The previous selection is the list of nodes and edges that were selected before the last user event.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public deselectEdge: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when starting a drag.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public dragStart: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when dragging node(s) or the view.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public dragging: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the drag has finished.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public dragEnd: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over a node.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public hoverNode: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired if the option interaction:{hover:true} is enabled and\r\n   * the mouse moved away from a node it was hovering over before.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public blurNode: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over an edge.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public hoverEdge: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired if the option interaction:{hover:true} is enabled and\r\n   * the mouse moved away from an edge it was hovering over before.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public blurEdge: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the user zooms in or out.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public zoom: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the popup (tooltip) is shown.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public showPopup: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the popup (tooltip) is hidden.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public hidePopup: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when stabilization starts.\r\n   * This is also the case when you drag a node and the physics\r\n   * simulation restarts to stabilize again.\r\n   * Stabilization does not neccesarily imply 'without showing'.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public startStabilizing: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a multiple of the updateInterval number of iterations is reached.\r\n   * This only occurs in the 'hidden' stabilization.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public stabilizationProgress: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the 'hidden' stabilization finishes.\r\n   * This does not necessarily mean the network is stabilized;\r\n   * it could also mean that the amount of iterations defined in the options has been reached.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public stabilizationIterationsDone: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the 'hidden' stabilization finishes.\r\n   * This does not necessarily mean the network is stabilized;\r\n   * it could also mean that the amount of iterations defined in the options has been reached.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public stabilized: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when the size of the canvas has been resized,\r\n   * either by a redraw call when the container div has changed in size,\r\n   * a setSize() call with new values or a setOptions() with new width and/or height values.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public resize: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired before the redrawing begins.\r\n   * The simulation step has completed at this point.\r\n   * Can be used to move custom elements before starting drawing the new frame.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public initRedraw: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired after the canvas has been cleared, scaled and translated to\r\n   * the viewing position but before all edges and nodes are drawn.\r\n   * Can be used to draw behind the network.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public beforeDrawing: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired after drawing on the canvas has been completed.\r\n   * Can be used to draw on top of the network.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public afterDrawing: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when an animation is finished.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public animationFinished: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  /**\r\n   * Fired when a user changes any option in the configurator.\r\n   * The options object can be used with the setOptions method or stringified using JSON.stringify().\r\n   * You do not have to manually put the options into the network: this is done automatically.\r\n   * You can use the event to store user options in the database.\r\n   * \r\n   * @type {EventEmitter<any>}\r\n   * @memberOf VisNetworkService\r\n   */\r\n  public configChange: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n  private networks: {[id: string]: VisNetwork} = {};\r\n\r\n  /**\r\n   * Creates a new network instance.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {HTMLElement} container The HTML element that contains the network view.\r\n   * @param {VisNetworkData} data The initial network nodes and edges.\r\n   * @param {VisNetworkOptions} [options] The network options.\r\n   * \r\n   * @throws {Error} Thrown when a network with the same name already exists.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public create(\r\n    visNetwork: string,\r\n    container: HTMLElement,\r\n    data: VisNetworkData,\r\n    options?: VisNetworkOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      throw new Error(`Network with id ${visNetwork} already exists.`);\r\n    }\r\n\r\n    this.networks[visNetwork] = new VisNetwork(container, data, options);\r\n  }\r\n\r\n  /**\r\n   * Remove the network from the DOM and remove all Hammer bindings and references.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public destroy(visNetwork: string): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].destroy();\r\n      delete this.networks[visNetwork];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activates an event.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisNetworkEvents} eventName The event name.\r\n   * @param {boolean} preventDefault Stops the default behavior of the event.\r\n   * @returns {boolean} Returns true when the event was activated.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public on(visNetwork: string, eventName: VisNetworkEvents, preventDefault?: boolean): boolean {\r\n    if (this.networks[visNetwork]) {\r\n      let that: {[index: string]: any} = this;\r\n      this.networks[visNetwork].on(eventName, (params: any) => {\r\n        let emitter = that[eventName] as EventEmitter<any>;\r\n        if (emitter) {\r\n          emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\r\n        }\r\n        if (preventDefault && params.event) {\r\n          params.event.preventDefault();\r\n        }\r\n      });\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Deactivates an event.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisNetworkEvents} eventName The event name.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public off(visNetwork: string, eventName: VisNetworkEvents): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].off(eventName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activates an event listener only once.\r\n   * After it has taken place, the event listener will be removed.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisNetworkEvents} eventName The event name.\r\n   * @returns {boolean} Returns true when the event was activated.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public once(visNetwork: string, eventName: VisNetworkEvents): boolean {\r\n    if (this.networks[visNetwork]) {\r\n      let that: {[index: string]: any} = this;\r\n      this.networks[visNetwork].on(eventName, (params: any) => {\r\n        let emitter = that[eventName] as EventEmitter<any>;\r\n        if (emitter) {\r\n          emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\r\n          this.off(visNetwork, eventName);\r\n        }\r\n      });\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Override all the data in the network.\r\n   * If stabilization is enabled in the physics module,\r\n   * the network will stabilize again.\r\n   * This method is also performed when first initializing the network.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisNetworkData} data The network data.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public setData(visNetwork: string, data: VisNetworkData): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].setData(data);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the options.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisNetworkOptions} options The network options.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public setOptions(visNetwork: string, options: VisNetworkOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].setOptions(options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Selects the nodes corresponding to the id's in the input array.\r\n   * This method unselects all other objects before selecting its own objects.\r\n   * Does not fire events.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId[]} nodeIds The node ids that should be selected.\r\n   * @param {boolean} [highlightEdges] If highlightEdges is true or undefined,\r\n   *                                   the neighbouring edges will also be selected.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public selectNodes(visNetwork: string, nodeIds: VisId[], highlightEdges?: boolean): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].selectNodes(nodeIds, highlightEdges);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an object with selected nodes and edges ids.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @returns {{ nodes: VisId[], edges: VisId[] }}\r\n   * The selected node and edge ids or undefined when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getSelection(visNetwork: string): { nodes: VisId[], edges: VisId[] } {\r\n    if (this.networks[visNetwork]) {\r\n      return this.networks[visNetwork].getSelection();\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of selected node ids.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @returns {VisId[]} The selected node ids or undefined when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getSelectedNodes(visNetwork: string): VisId[] {\r\n    if (this.networks[visNetwork]) {\r\n      return this.networks[visNetwork].getSelectedNodes();\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of selected edge ids.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @returns {VisId[]} The selected edge ids or undefined when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getSelectedEdges(visNetwork: string): VisId[] {\r\n    if (this.networks[visNetwork]) {\r\n      return this.networks[visNetwork].getSelectedEdges();\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Unselect all objects.\r\n   * Does not fire events.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public unselectAll(visNetwork: string): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].unselectAll();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Zooms out so all nodes fit on the canvas.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisFitOptions} [options] Options to customize.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public fit(visNetwork: string, options?: VisFitOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].fit(options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Redraw the network.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public redraw(visNetwork: string): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].redraw();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Programatically enable the edit mode.\r\n   * Similar effect to pressing the edit button.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public enableEditMode(visNetwork: string): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].enableEditMode();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Go into addEdge mode.\r\n   * The explaination from addNodeMode applies here as well.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public addEdgeMode(visNetwork: string): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].addEdgeMode();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Programatically disable the edit mode.\r\n   * Similar effect to pressing the close icon\r\n   * (small cross in the corner of the toolbar).\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public disableEditMode(visNetwork: string): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].disableEditMode();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete selected.\r\n   * Having edit mode or manipulation enabled is not required.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public deleteSelected(visNetwork: string): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].deleteSelected();\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Makes a cluster.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisClusterOptions} [options] The joinCondition function is presented with all nodes.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public cluster(visNetwork: string, options?: VisClusterOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].cluster(options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method looks at the provided node and makes a cluster of it and all it's connected nodes.\r\n   * The behaviour can be customized by proving the options object.\r\n   * All options of this object are explained below.\r\n   * The joinCondition is only presented with the connected nodes.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId} nodeId the id of the node\r\n   * @param {VisClusterOptions} [options] the cluster options\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public clusterByConnection(visNetwork: string, nodeId: VisId, options?: VisClusterOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].clusterByConnection(nodeId, options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method checks all nodes in the network and those with a equal or higher\r\n   * amount of edges than specified with the hubsize qualify.\r\n   * If a hubsize is not defined, the hubsize will be determined as the average\r\n   * value plus two standard deviations. \r\n   * For all qualifying nodes, clusterByConnection is performed on each of them.\r\n   * The options object is described for clusterByConnection and does the same here.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {number} [hubsize] optional hubsize\r\n   * @param {VisClusterOptions} [options] optional cluster options\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public clusterByHubsize(visNetwork: string, hubsize?: number, options?: VisClusterOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].clusterByHubsize(hubsize, options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method will cluster all nodes with 1 edge with their respective connected node.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisClusterOptions} [options] optional cluster options\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public clusterOutliers(visNetwork: string, options?: VisClusterOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].clusterOutliers(options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Nodes can be in clusters.\r\n   * Clusters can also be in clusters.\r\n   * This function returns an array of nodeIds showing where the node is. \r\n   *\r\n   * Example:\r\n   * cluster 'A' contains cluster 'B', cluster 'B' contains cluster 'C',\r\n   * cluster 'C' contains node 'fred'.\r\n   * \r\n   * network.clustering.findNode('fred') will return ['A','B','C','fred'].\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId} nodeId the node id.\r\n   * @returns {VisId[]} an array of nodeIds showing where the node is\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public findNode(visNetwork: string, nodeId: VisId): VisId[] {\r\n    if (this.networks[visNetwork]) {\r\n      return this.networks[visNetwork].findNode(nodeId);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Similar to findNode in that it returns all the edge ids that were\r\n   * created from the provided edge during clustering.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId} baseEdgeId the base edge id\r\n   * @returns {VisId[]} an array of edgeIds\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getClusteredEdges(visNetwork: string, baseEdgeId: VisId): VisId[] {\r\n    if (this.networks[visNetwork]) {\r\n      return this.networks[visNetwork].getClusteredEdges(baseEdgeId);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * When a clusteredEdgeId is available, this method will return the original\r\n   * baseEdgeId provided in data.edges ie.\r\n   * After clustering the 'SelectEdge' event is fired but provides only the clustered edge.\r\n   * This method can then be used to return the baseEdgeId.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId} clusteredEdgeId\r\n   * @returns {VisId} \r\n   * \r\n   * @memberOf VisNetworkService\r\n   * \r\n   */\r\n  public getBaseEdge(visNetwork: string, clusteredEdgeId: VisId): VisId {\r\n    if (this.networks[visNetwork]) {\r\n      return this.networks[visNetwork].getBaseEdge(clusteredEdgeId);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Visible edges between clustered nodes are not the same edge as the ones provided\r\n   * in data.edges passed on network creation. With each layer of clustering, copies of\r\n   * the edges between clusters are created and the previous edges are hidden,\r\n   * until the cluster is opened. This method takes an edgeId (ie. a base edgeId from data.edges)\r\n   * and applys the options to it and any edges that were created from it while clustering.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId} startEdgeId\r\n   * @param {VisEdgeOptions} [options]\r\n   * \r\n   * @memberOf VisNetworkService\r\n   * \r\n   */\r\n  public updateEdge(visNetwork: string, startEdgeId: VisId, options?: VisEdgeOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].updateEdge(startEdgeId, options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clustered Nodes when created are not contained in the original data.nodes \r\n   * passed on network creation. This method updates the cluster node.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId} clusteredNodeId \r\n   * @param {VisNodeOptions} options\r\n   * \r\n   * @memberOf VisNetworkService\r\n   * \r\n   */\r\n  public updateClusteredNode(visNetwork: string, clusteredNodeId: VisId, options?: VisNodeOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].updateClusteredNode(clusteredNodeId, options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an array of all nodeIds of the nodes that\r\n   * would be released if you open the cluster.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId} clusterNodeId the id of the cluster node\r\n   * @returns {VisId[]}\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getNodesInCluster(visNetwork: string, clusterNodeId: VisId): VisId[] {\r\n    if (this.networks[visNetwork]) {\r\n      return this.networks[visNetwork].getNodesInCluster(clusterNodeId);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Opens the cluster, releases the contained nodes and edges,\r\n   * removing the cluster node and cluster edges.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId} nodeId The node id that represents the cluster.\r\n   * @param {VisOpenClusterOptions} [options] Cluster options.\r\n   * \r\n   * @throws {Error} Thrown when the network does not exist.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public openCluster(visNetwork: string, nodeId: VisId, options?: VisOpenClusterOptions): void {\r\n    if (this.networks[visNetwork]) {\r\n      this.networks[visNetwork].openCluster(nodeId, options);\r\n    } else {\r\n      throw new Error(`Network with id ${visNetwork} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the node whose ID has been supplied is a cluster.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @param {VisId} nodeId The associated node id.\r\n   * @returns {boolean} True if the node whose ID has been supplied is a cluster.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public isCluster(visNetwork: string, nodeId: VisId): boolean {\r\n    if (this.networks[visNetwork]) {\r\n      return this.networks[visNetwork].isCluster(nodeId);\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * If you like the layout of your network and would like it to start in the same way next time,\r\n   * ask for the seed using this method and put it in the layout.randomSeed option.\r\n   * \r\n   * @param {string} visNetwork The network name/identifier.\r\n   * @returns {number} The seed of the current network or -1 when the network is not defined.\r\n   * \r\n   * @memberOf VisNetworkService\r\n   */\r\n  public getSeed(visNetwork: string): number {\r\n    if (this.networks[visNetwork]) {\r\n      return this.networks[visNetwork].getSeed();\r\n    }\r\n\r\n    return -1;\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/network/vis-network.service.ts\n **/","import * as Vis from 'vis';\r\n\r\nexport type VisId = Vis.IdType;\r\nexport interface VisTimelineItem extends Vis.DataItem {}\r\nexport interface VisTimelineGroup extends Vis.DataGroup {}\r\nexport interface VisDataSetOptions extends Vis.DataSetOptions {}\r\nexport interface VisTimelineOptions extends Vis.TimelineOptions {}\r\nexport class VisTimelineItems extends Vis.DataSet<VisTimelineItem> {\r\n    public constructor(data?: VisTimelineItem[], options?: VisDataSetOptions) {\r\n        super(data, options);\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this.length;\r\n    }\r\n\r\n    public add(data: VisTimelineItem | VisTimelineItem[], senderId?: VisId): VisId[] {\r\n        return super.add(data, senderId);\r\n    }\r\n\r\n    public clear(senderId?: VisId): VisId[] {\r\n        return super.clear(senderId);\r\n    }\r\n\r\n    public distinct(field: string): any[] {\r\n        return super.distinct(field);\r\n    }\r\n\r\n    public flush(): void {\r\n        super.flush();\r\n    }\r\n\r\n    public forEach(callback: (item: VisTimelineItem, id: VisId) => void, options?: VisItemSelectionOptions): void {\r\n        super.forEach(callback, options);\r\n    }\r\n\r\n    public getAll(options?: VisItemSelectionOptions): VisTimelineItem[] {\r\n        return super.get(options);\r\n    }\r\n\r\n    public getById(id: VisId, options?: VisItemSelectionOptions): VisTimelineItem {\r\n        return super.get(id, options);\r\n    }\r\n\r\n    public getByIds(ids: VisId[], options?: VisItemSelectionOptions): VisTimelineItem[] {\r\n        return super.get(ids, options);\r\n    }\r\n\r\n    public getDataSet(): VisTimelineItems {\r\n        return super.getDataSet() as VisTimelineItems;\r\n    }\r\n\r\n    public getIds(options?: VisItemSelectionOptions): VisId[] {\r\n        return super.getIds(options);\r\n    }\r\n\r\n    public map(callback: (item: VisTimelineItem, id: VisId) => any, options?: VisItemSelectionOptions): any[] {\r\n        return super.map(callback, options);\r\n    }\r\n\r\n    public max(field: string): VisTimelineItem {\r\n        return super.max(field);\r\n    }\r\n\r\n    public min(field: string): VisTimelineItem {\r\n        return super.min(field);\r\n    }\r\n\r\n    public on(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.on(event, callback);\r\n    }\r\n\r\n    public off(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.off(event, callback);\r\n    }\r\n\r\n    public removeItems(ids: VisId[], senderId?: VisId): VisId[] {\r\n        return super.remove(ids, senderId);\r\n    }\r\n\r\n    public setOptions(options?: VisDataSetQueueOptions): void {\r\n        super.setOptions(options);\r\n    }\r\n\r\n    public update(data: VisTimelineItem[], senderId?: VisId): VisId[] {\r\n        return super.update(data, senderId);\r\n    }\r\n}\r\nexport class VisTimelineGroups extends Vis.DataSet<VisTimelineGroup> {\r\n    public constructor(data?: VisTimelineGroup[], options?: VisDataSetOptions) {\r\n        super(data, options);\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this.length;\r\n    }\r\n\r\n    public add(data: VisTimelineGroup | VisTimelineGroup[], senderId?: VisId): VisId[] {\r\n        return super.add(data, senderId);\r\n    }\r\n\r\n    public clear(senderId?: VisId): VisId[] {\r\n        return super.clear(senderId);\r\n    }\r\n\r\n    public distinct(field: string): any[] {\r\n        return super.distinct(field);\r\n    }\r\n\r\n    public flush(): void {\r\n        super.flush();\r\n    }\r\n\r\n    public forEach(callback: (item: VisTimelineGroup, id: VisId) => void, options?: VisGroupSelectionOptions): void {\r\n        super.forEach(callback, options);\r\n    }\r\n\r\n    public getAll(options?: VisGroupSelectionOptions): VisTimelineGroup[] {\r\n        return super.get(options);\r\n    }\r\n\r\n    public getById(id: VisId, options?: VisGroupSelectionOptions): VisTimelineGroup {\r\n        return super.get(id, options);\r\n    }\r\n\r\n    public getByIds(ids: VisId[], options?: VisGroupSelectionOptions): VisTimelineGroup[] {\r\n        return super.get(ids, options);\r\n    }\r\n\r\n    public getDataSet(): VisTimelineGroups {\r\n        return super.getDataSet() as VisTimelineGroups;\r\n    }\r\n\r\n    public getIds(options?: VisGroupSelectionOptions): VisId[] {\r\n        return super.getIds(options);\r\n    }\r\n\r\n    public map(callback: (item: VisTimelineGroup, id: VisId) => any, options?: VisGroupSelectionOptions): any[] {\r\n        return super.map(callback, options);\r\n    }\r\n\r\n    public max(field: string): VisTimelineGroup {\r\n        return super.max(field);\r\n    }\r\n\r\n    public min(field: string): VisTimelineGroup {\r\n        return super.min(field);\r\n    }\r\n\r\n    public on(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.on(event, callback);\r\n    }\r\n\r\n    public off(event: string, callback: (event: string, properties: any, senderId: VisId) => void): void {\r\n        super.off(event, callback);\r\n    }\r\n\r\n    public removeItems(ids: VisId[], senderId?: VisId): VisId[] {\r\n        return super.remove(ids, senderId);\r\n    }\r\n\r\n    public setOptions(options?: VisDataSetQueueOptions): void {\r\n        super.setOptions(options);\r\n    }\r\n\r\n    public update(data: VisTimelineGroup[], senderId?: VisId): VisId[] {\r\n        return super.update(data, senderId);\r\n    }\r\n}\r\n\r\nexport interface VisDataSetQueueOptions extends Vis.DataSetQueueOptions {}\r\nexport interface VisItemSelectionOptions extends Vis.DataSelectionOptions<VisTimelineItem> {}\r\nexport interface VisGroupSelectionOptions extends Vis.DataSelectionOptions<VisTimelineGroup> {}\r\nexport type VisDate = Vis.DateType;\r\nexport type VisTimelineEvents = Vis.TimelineEvents;\r\nexport interface VisTimelineFitOptions extends Vis.TimelineFitOptions {}\r\nexport interface VisTimelineEventPropertiesResult extends  Vis.TimelineEventPropertiesResult {}\r\n\r\nexport class VisTimeline extends Vis.Timeline {}\r\n\r\nexport * from './vis-timeline.service';\r\nexport * from './vis-timeline.directive';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/timeline/index.ts\n **/","import {\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Input,\r\n  OnChanges,\r\n  OnDestroy,\r\n  OnInit,\r\n  Output,\r\n  SimpleChange } from '@angular/core';\r\n\r\nimport { VisTimelineService } from './vis-timeline.service';\r\n\r\nimport {\r\n    VisTimelineGroups,\r\n    VisTimelineItems,\r\n    VisTimelineOptions } from './index';\r\n\r\n/**\r\n * Use this directive with a div container to show timeline data.\r\n * \r\n * @export\r\n * @class VisTimelineDirective\r\n * @implements {OnInit}\r\n * @implements {OnDestroy}\r\n * @implements {OnChanges}\r\n */\r\n@Directive({\r\n  selector: '[visTimeline]',\r\n})\r\nexport class VisTimelineDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n    /**\r\n     * The name or identifier of the timeline (must be unique in your application).\r\n     * This property is used once on init and must not be changed.\r\n     * \r\n     * @type {string}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Input('visTimeline')\r\n    public visTimeline: string;\r\n\r\n    /**\r\n     * The data that will be used to create the timeline.\r\n     * Changes will be detected. If the reference changes then\r\n     * setData will be called on this timeline instance.\r\n     * \r\n     * @type {VisTimelineItems}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Input()\r\n    public visTimelineItems: VisTimelineItems;\r\n\r\n    /**\r\n     * The groups that will be used to create the timeline.\r\n     * Changes will be detected. If the reference changes then\r\n     * setGroups will be called on this timeline instance.\r\n     * \r\n     * @type {VisTimelineGroups}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Input()\r\n    public visTimelineGroups: VisTimelineGroups;\r\n\r\n    /**\r\n     * The options that will be used with this timeline.\r\n     * Changes will be detected. If the reference changes then\r\n     * setOptions will be called on this timeline instance.\r\n     * \r\n     * @type {VisTimelineOptions}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Input()\r\n    public visTimelineOptions: VisTimelineOptions;\r\n\r\n    /**\r\n     * This event will be raised when the timline is initialized.\r\n     * At this point of time the timeline is successfully registered\r\n     * with the VisNetworkService and you can register to events.\r\n     * The event data is the name of the timeline as a string.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    @Output()\r\n    public initialized: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    private visTimelineContainer: any;\r\n    private isInitialized: boolean = false;\r\n\r\n    /**\r\n     * Creates an instance of VisTimelineDirective.\r\n     * \r\n     * @param {ElementRef} elementRef The HTML element reference.\r\n     * @param {VisTimelineService} visTimelineService The VisTimelineService.\r\n     * \r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    public constructor(private elementRef: ElementRef, private visTimelineService: VisTimelineService) {\r\n        this.visTimelineContainer = elementRef.nativeElement;\r\n    }\r\n\r\n    /**\r\n     * Create the timeline when at least visNetwork and visNetworkData\r\n     * are defined.\r\n     * \r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    public ngOnInit(): void {\r\n        if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {\r\n            this.createTimeline();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the timeline data, groups or options on reference changes to\r\n     * the visTimelineItems, visTimelineGroups or visTimelineOptions properties.\r\n     * \r\n     * @param {{[propName: string]: SimpleChange}} changes\r\n     * \r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    public ngOnChanges(changes: {[propName: string]: SimpleChange}): void {\r\n        if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {\r\n            this.createTimeline();\r\n        }\r\n\r\n        for (let propertyName in changes) {\r\n          if (changes.hasOwnProperty(propertyName)) {\r\n            let change = changes[propertyName];\r\n            if (!change.isFirstChange()) {\r\n              if (propertyName === 'visTimelineItems') {\r\n                  this.visTimelineService.setItems(this.visTimeline, changes[propertyName].currentValue);\r\n              }\r\n              if (propertyName === 'visTimelineOptions') {\r\n                  this.visTimelineService.setOptions(this.visTimeline, changes[propertyName].currentValue);\r\n              }\r\n              if (propertyName === 'visTimelineGroups') {\r\n                  this.visTimelineService.setGroups(this.visTimeline, changes[propertyName].currentValue);\r\n              }\r\n            }\r\n          }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calls the destroy function for this timeline instance.\r\n     * \r\n     * \r\n     * @memberOf VisTimelineDirective\r\n     */\r\n    public ngOnDestroy(): void {\r\n        this.isInitialized = false;\r\n        this.visTimelineService.destroy(this.visTimeline);\r\n    }\r\n\r\n    private createTimeline(): void {\r\n        if (this.visTimelineGroups) {\r\n            this.visTimelineService.createWithItemsAndGroups(\r\n                this.visTimeline,\r\n                this.visTimelineContainer,\r\n                this.visTimelineItems,\r\n                this.visTimelineGroups,\r\n                this.visTimelineOptions);\r\n        } else {\r\n            this.visTimelineService.createWithItems(\r\n                this.visTimeline,\r\n                this.visTimelineContainer,\r\n                this.visTimelineItems,\r\n                this.visTimelineOptions);\r\n        }\r\n        this.isInitialized = true;\r\n        this.initialized.emit(this.visTimeline);\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/timeline/vis-timeline.directive.ts\n **/","import { EventEmitter, Injectable } from '@angular/core';\r\nimport {\r\n    VisDate,\r\n    VisId,\r\n    VisTimeline,\r\n    VisTimelineEventPropertiesResult,\r\n    VisTimelineEvents,\r\n    VisTimelineFitOptions,\r\n    VisTimelineGroups,\r\n    VisTimelineItems,\r\n    VisTimelineOptions } from './index';\r\n\r\n/**\r\n * A service to create, manage and control VisTimeline instances.\r\n * \r\n * @export\r\n * @class VisTimelineService\r\n */\r\n@Injectable()\r\nexport class VisTimelineService {\r\n    /**\r\n     * Fired when the current time bar redraws.\r\n     * The rate depends on the zoom level.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public currentTimeTick: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when clicked inside the Timeline.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public click: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when right-clicked inside the Timeline.\r\n     * Note that in order to prevent the context menu from showing up,\r\n     * default behavior of the event must be stopped.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public contextmenu: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when double clicked inside the Timeline.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public doubleClick: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * \tFired after the dragging of a group is finished.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public groupDragged: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired once after each graph redraw.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public changed: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired repeatedly when the timeline window is being changed.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public rangechange: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired once after the timeline window has been changed.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public rangechanged: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired after the user selects or deselects items by tapping or holding them.\r\n     * When a use taps an already selected item, the select event is fired again.\r\n     * Not fired when the method setSelectionis executed.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public select: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when the user moves the mouse over an item.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public itemover: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired when the user moves the mouse out of an item.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public itemout: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired repeatedly when the user is dragging the custom time bar.\r\n     * Only available when the custom time bar is enabled.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public timechange: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Fired once after the user has dragged the custom time bar.\r\n     * Only available when the custom time bar is enabled.\r\n     * \r\n     * @type {EventEmitter<any>}\r\n     * @memberOf VisTimelineService\r\n     */\r\n    public timechanged: EventEmitter<any> = new EventEmitter<any>();\r\n\r\n    private timelines: {[id: string]: VisTimeline} = {};\r\n\r\n    /**\r\n     * Creates a new timeline instance.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {HTMLElement} container The HTML element that contains the timeline view.\r\n     * @param {VisTimelineItems} items The initial timeline items.\r\n     * @param {VisTimelineOptions} [options] The timeline options.\r\n     * \r\n     * @throws {Error} Thrown when timeline already exists.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public createWithItems(\r\n        visTimeline: string,\r\n        container: HTMLElement,\r\n        items: VisTimelineItems,\r\n        options?: VisTimelineOptions): void {\r\n        if (this.timelines[visTimeline]) {\r\n            throw new Error(this.alreadyExistsError(visTimeline));\r\n        }\r\n\r\n        this.timelines[visTimeline] = new VisTimeline(container, items, options);\r\n    }\r\n\r\n    /**\r\n     * Creates a new timeline instance.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {HTMLElement} container The HTML element that contains the timeline view.\r\n     * @param {VisTimelineItems} items The initial timeline items.\r\n     * @param {VisTimelineGroups} groups The initial timeline groups.\r\n     * @param {VisTimelineOptions} [options] The timeline options.\r\n     * \r\n     * @throws {Error} Thrown when timeline already exists.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public createWithItemsAndGroups(\r\n        visTimeline: string,\r\n        container: HTMLElement,\r\n        items: VisTimelineItems,\r\n        groups: VisTimelineGroups,\r\n        options?: VisTimelineOptions): void {\r\n        if (this.timelines[visTimeline]) {\r\n            throw new Error(this.alreadyExistsError(visTimeline));\r\n        }\r\n\r\n        this.timelines[visTimeline] = new VisTimeline(container, items, groups, options);\r\n    }\r\n\r\n    /**\r\n     * Add new vertical bar representing a custom time that can be dragged by the user.\r\n     * The id is added as CSS class name of the custom time bar,\r\n     * allowing to style multiple time bars differently.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} time Parameter time can be a Date, Number, or String, and is new Date() by default.\r\n     * @param {VisId} [id] Parameter id can be Number or String and is undefined by default. \r\n     * @returns {VisId} The method returns id of the created bar.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public addCustomTime(visTimeline: string, time: VisDate, id?: VisId): VisId {\r\n        if (this.timelines[visTimeline]) {\r\n            return this.timelines[visTimeline].addCustomTime(time, id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adjust the visible window such that it fits all items.\r\n     * See also function focus(id).\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineFitOptions} [options] Optional options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public fit(visTimeline: string, options?: VisTimelineFitOptions): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].fit(options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adjust the visible window such that the selected item is centered on screen. \r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId} id The id of the item.\r\n     * @param {VisTimelineFitOptions} [options] Options options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public focusOnId(visTimeline: string, id: VisId, options?: VisTimelineFitOptions): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].focus(id, options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adjust the visible window such that the selected items are centered on screen. \r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId[]} ids The item ids.\r\n     * @param {VisTimelineFitOptions} [options] Optional options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public focusOnIds(visTimeline: string, ids: VisId[], options?: VisTimelineFitOptions): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].focus(ids, options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current time.\r\n     * Only applicable when option showCurrentTime is true.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {Date} The current time.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getCurrentTime(visTimeline: string): Date {\r\n        if (this.timelines[visTimeline]) {\r\n            return this.timelines[visTimeline].getCurrentTime();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieve the custom time from the custom time bar with given id.\r\n     * Id is undefined by default.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId} [id] The time bar id.\r\n     * @returns {Date} The custom time.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getCustomTime(visTimeline: string, id?: VisId): Date {\r\n        if (this.timelines[visTimeline]) {\r\n            return this.timelines[visTimeline].getCustomTime(id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an Object with relevant properties from an event.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {Event} event The event.\r\n     * @returns {VisTimelineEventPropertiesResult} Properties of an event\r\n     *  \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getEventProperties(visTimeline: string, event: Event): VisTimelineEventPropertiesResult {\r\n        if (this.timelines[visTimeline]) {\r\n            return this.timelines[visTimeline].getEventProperties(event);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the range of all the items as an object containing min: Date and max: Date.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {{ min: Date, max: Date }} The min and max dates.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getItemRange(visTimeline: string): { min: Date, max: Date } {\r\n        if (this.timelines[visTimeline]) {\r\n            return this.timelines[visTimeline].getItemRange();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get an array with the ids of the currently selected items.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {VisId[]} The currently selected items.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getSelection(visTimeline: string): VisId[] {\r\n        if (this.timelines[visTimeline]) {\r\n            return this.timelines[visTimeline].getSelection();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get an array with the ids of the currently visible items.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {VisId[]} The currently visible items.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getVisibleItems(visTimeline: string): VisId[] {\r\n        if (this.timelines[visTimeline]) {\r\n            return this.timelines[visTimeline].getVisibleItems();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current visible window.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @returns {{ start: Date, end: Date }} Returns an object with properties start: Date and end: Date.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public getWindow(visTimeline: string): { start: Date, end: Date } {\r\n        if (this.timelines[visTimeline]) {\r\n            return this.timelines[visTimeline].getWindow();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \tMove the window such that given time is centered on screen.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} time Parameter time can be a Date, Number, or String.\r\n     * @param {VisTimelineFitOptions} [options] Optional options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public moveTo(visTimeline: string, time: VisDate, options?: VisTimelineFitOptions): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].moveTo(time, options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force a redraw of the Timeline.\r\n     * The size of all items will be recalculated.\r\n     * Can be useful to manually redraw when option autoResize=false and the window has been resized,\r\n     * or when the items CSS has been changed.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public redraw(visTimeline: string): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].redraw();\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove vertical bars previously added to the timeline via addCustomTime method.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId} id Parameter id is the ID of the custom vertical bar returned by addCustomTime method.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public removeCustomTime(visTimeline: string, id: VisId): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].removeCustomTime(id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a current time.\r\n     * This can be used for example to ensure that a client's time is synchronized\r\n     * with a shared server time.\r\n     * Only applicable when option showCurrentTime is true.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} time time can be a Date object, numeric timestamp, or ISO date string.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setCurrentTime(visTimeline: string, time: VisDate): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setCurrentTime(time);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \tAdjust the time of a custom time bar.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} time Parameter time can be a Date object, numeric timestamp, or ISO date string.\r\n     * @param {VisId} [id] Parameter id is the id of the custom time bar, and is undefined by default.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setCustomTime(visTimeline: string, time: VisDate, id?: VisId): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setCustomTime(time, id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adjust the title attribute of a custom time bar.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {string} title Parameter title is the string to be set as title.\r\n     *                       Use empty string to hide the title completely.\r\n     * @param {VisId} [id] Parameter id is the id of the custom time bar, and is undefined by default.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setCustomTimeTitle(visTimeline: string, title: string, id?: VisId): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setCustomTimeTitle(title, id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set both groups and items at once.\r\n     * Both properties are optional.\r\n     * This is a convenience method for individually calling both setItems(items) and setGroups(groups).\r\n     * Both items and groups can be an Array with Objects, a DataSet (offering 2 way data binding),\r\n     * or a DataView (offering 1 way data binding).\r\n     * For each of the groups, the items of the timeline are filtered on the property group,\r\n     * which must correspond with the id of the group.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {{ groups?: VisTimelineGroups; items?: VisTimelineItems }} data The new timline data.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setData(visTimeline: string, data: { groups?: VisTimelineGroups; items?: VisTimelineItems }): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setData(data);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a data set with groups for the Timeline.\r\n     * For each of the groups, the items of the timeline are filtered on the property group,\r\n     * which must correspond with the id of the group.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineGroups} groups a DataSet (offering 2 way data binding)\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setGroups(visTimeline: string, groups: VisTimelineGroups): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setGroups(groups);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a data set with items for the Timeline.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineItems} items can be an Array with Objects, a DataSet (offering 2 way data binding)\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setItems(visTimeline: string, items: VisTimelineItems): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setItems(items);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set or update options.\r\n     * It is possible to change any option of the timeline at any time.\r\n     * You can for example switch orientation on the fly.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineOptions} options The new options of the timeline.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setOptions(visTimeline: string, options: VisTimelineOptions): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setOptions(options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select one item by its id.#\r\n     * The currently selected items will be unselected.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId} id The id of the item that should be selected.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setSelectionToId(visTimeline: string, id: VisId): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setSelection(id);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select multiple items by their id.\r\n     * The currently selected items will be unselected.\r\n     * To unselect all selected items, call `setSelection([])`.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisId[]} ids The ids of the irems that should be selected.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setSelectionToIds(visTimeline: string, ids: VisId[]): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setSelection(ids);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the current visible window.\r\n     * \r\n     * If the parameter value of start or end is null, the parameter will be left unchanged.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisDate} start The parameters start can be a Date, Number, or String.\r\n     * @param {VisDate} end The parameters end can be a Date, Number, or String.\r\n     * @param {VisTimelineFitOptions} [options] Optional options.\r\n     * \r\n     * @throws {Error} Thrown when timeline does not exist.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public setWindow(visTimeline: string, start: VisDate, end: VisDate, options?: VisTimelineFitOptions): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].setWindow(start, end, options);\r\n        } else {\r\n            throw new Error(this.doesNotExistError(visTimeline));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the Timeline.\r\n     * The timeline is removed from memory.\r\n     * All DOM elements and event listeners are cleaned up.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public destroy(visTimeline: string): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].destroy();\r\n            delete this.timelines[visTimeline];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Activates an event.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineEvents} eventName The event name.\r\n     * @param {boolean} preventDefault Stops the default behavior of the event.\r\n     * @returns {boolean} Returns true when the event was activated.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public on(visTimeline: string, eventName: VisTimelineEvents, preventDefault?: boolean): boolean {\r\n        if (this.timelines[visTimeline]) {\r\n            let that: {[index: string]: any} = this;\r\n            this.timelines[visTimeline].on(eventName, (params: any) => {\r\n                let emitter = that[eventName] as EventEmitter<any>;\r\n                if (emitter) {\r\n                    emitter.emit(params ? [visTimeline].concat(params) : visTimeline);\r\n                }\r\n                if (preventDefault && params.event) {\r\n                    params.event.preventDefault();\r\n                }\r\n            });\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Deactivates an event.\r\n     * \r\n     * @param {string} visTimeline The timeline name/identifier.\r\n     * @param {VisTimelineEvents} eventName The event name.\r\n     * \r\n     * @memberOf VisTimelineService\r\n     */\r\n    public off(visTimeline: string, eventName: VisTimelineEvents): void {\r\n        if (this.timelines[visTimeline]) {\r\n            this.timelines[visTimeline].off(eventName, undefined);\r\n        }\r\n    }\r\n\r\n    private doesNotExistError(visTimeline: string): string {\r\n        return `Timeline with id ${visTimeline} does not exist.`;\r\n    }\r\n\r\n    private alreadyExistsError(visTimeline: string): string {\r\n        return `Timeline with id ${visTimeline} already exists.`;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/timeline/vis-timeline.service.ts\n **/","module.exports = \"<div class=\\\"container\\\">\\r\\n  <div class=\\\"header clearfix\\\">\\r\\n    <nav>\\r\\n      <ul class=\\\"nav nav-pills pull-right\\\">\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/home\\\">Home</a></li>\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/network\\\">Network</a></li>\\r\\n        <li role=\\\"presentation\\\" routerLinkActive=\\\"active\\\"><a routerLink=\\\"/timeline\\\">Timeline</a></li>\\r\\n      </ul>\\r\\n    </nav>\\r\\n    <h3 class=\\\"text-muted\\\">ng2-vis - an angular2 vis.js wrapper</h3>\\r\\n  </div>\\r\\n  <router-outlet></router-outlet>\\r\\n</div>\\r\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/demo.component.html\n ** module id = 138\n ** module chunks = 1\n **/","import { Component } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'example-app',\r\n  template: require('./demo.component.html'),\r\n})\r\nexport class DemoComponent {\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo/demo.component.ts\n **/","import { NgModule } from '@angular/core';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { BrowserModule } from '@angular/platform-browser';\r\nimport { CommonModule } from '@angular/common';\r\nimport { RouterModule }   from '@angular/router';\r\n\r\nimport { VisNetworkExampleComponent } from './network/network-example.component';\r\nimport { VisTimelineExampleComponent } from './timeline/timeline-example.component';\r\nimport { VisModule } from '../ng2-vis';\r\nimport { DemoComponent } from './demo.component';\r\nimport { HomeComponent } from './home/home.component';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    DemoComponent,\r\n    HomeComponent,\r\n    VisNetworkExampleComponent,\r\n    VisTimelineExampleComponent\r\n  ],\r\n  imports: [\r\n    BrowserModule,\r\n    FormsModule,\r\n    VisModule,\r\n    CommonModule,\r\n    RouterModule.forRoot([\r\n      { path: 'timeline', component: VisTimelineExampleComponent },\r\n      { path: '', redirectTo: '/home', pathMatch: 'full' },\r\n      { path: 'home', component: HomeComponent },\r\n      { path: 'network', component: VisNetworkExampleComponent },\r\n      { path: '**', component: HomeComponent }\r\n    ])\r\n  ],\r\n  providers: [],\r\n  bootstrap: [DemoComponent]\r\n})\r\nexport class VisDemoModule {\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo/demo.module.ts\n **/","module.exports = \"<div class=\\\"jumbotron\\\">\\r\\n  <h1>ng2-vis</h1>\\r\\n  <p class=\\\"lead\\\"><strong>Note:</strong> these examples mimic the ones for <code>vis</code>, but using <code>ng2-vis</code>.</p>\\r\\n  <p>\\r\\n    <a class=\\\"btn btn-lg btn-success\\\" href=\\\"https://github.com/seveves/ng2-vis\\\" role=\\\"button\\\">Get it on GitHub</a>\\r\\n    <a class=\\\"btn btn-lg btn-success\\\" href=\\\"http://visjs.org\\\" role=\\\"button\\\">Check out visjs.org</a>\\r\\n  </p>\\r\\n</div>\\r\\n<h2>Examples</h2>\\r\\n<div class=\\\"row\\\">\\r\\n  <div class=\\\"col-sm-6 col-md-4\\\">\\r\\n    <div class=\\\"thumbnail\\\">\\r\\n      <img src=\\\"http://visjs.org/images/network.png\\\" alt=\\\"Network Examples\\\">\\r\\n      <div class=\\\"caption\\\">\\r\\n        <h3>Network</h3>\\r\\n        <p>Display dynamic, automatically organised, customizable network views.</p>\\r\\n        <p><a routerLink=\\\"/network\\\" class=\\\"btn btn-primary\\\" role=\\\"button\\\">Examples</a></p>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n  <div class=\\\"col-sm-6 col-md-4\\\">\\r\\n    <div class=\\\"thumbnail\\\">\\r\\n      <img src=\\\"http://visjs.org/images/timeline.png\\\" alt=\\\"Timeline Examples\\\">\\r\\n      <div class=\\\"caption\\\">\\r\\n        <h3>Timeline</h3>\\r\\n        <p>Create a fully customizable, interactive timeline with items and ranges.</p>\\r\\n        <p><a routerLink=\\\"/timeline\\\" class=\\\"btn btn-primary\\\" role=\\\"button\\\">Examples</a></p>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n</div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/home/home.component.html\n ** module id = 139\n ** module chunks = 1\n **/","import { Component } from '@angular/core';\r\n\r\n@Component({\r\n    selector: 'home-example',\r\n    template: require('./home.component.html'),\r\n})\r\nexport class HomeComponent {}\n\n\n/** WEBPACK FOOTER **\n ** ./demo/home/home.component.ts\n **/","import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n\r\nimport { VisDemoModule } from './demo.module';\r\nplatformBrowserDynamic().bootstrapModule(VisDemoModule);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo/index.ts\n **/","module.exports = \".network-canvas {\\r\\n    width: 100%;\\r\\n    height: 400px;\\r\\n    border: 1px solid lightgray;\\r\\n}\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/network/network-example.component.css\n ** module id = 140\n ** module chunks = 1\n **/","module.exports = \"<h2>Network</h2>\\r\\n<h3>Basic usage</h3>\\r\\n<div class=\\\"network-canvas\\\" [visNetwork]=\\\"visNetwork\\\" [visNetworkData]=\\\"visNetworkData\\\" [visNetworkOptions]=\\\"visNetworkOptions\\\" (initialized)=\\\"networkInitialized()\\\"></div>\\r\\n<button type=\\\"button\\\" class=\\\"btn btn-default\\\" (click)=\\\"addNode()\\\">Add node</button>\\r\\n<p><strong>Note:</strong> Open your dev tools to see the console output when the network receives click events.</p>\\r\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/network/network-example.component.html\n ** module id = 141\n ** module chunks = 1\n **/","import { Component, OnInit, OnDestroy } from '@angular/core';\r\n\r\nimport {\r\n    VisNode,\r\n    VisNodes,\r\n    VisEdges,\r\n    VisNetworkService,\r\n    VisNetworkData,\r\n    VisNetworkOptions } from '../../components/network';\r\n\r\nclass ExampleNetworkData implements VisNetworkData {\r\n    public nodes: VisNodes;\r\n    public edges: VisEdges;\r\n}\r\n\r\n@Component({\r\n    selector: 'network-example',\r\n    template: require('./network-example.component.html'),\r\n    styles: [\r\n        require('./network-example.component.css')\r\n    ]\r\n})\r\nexport class VisNetworkExampleComponent implements OnInit, OnDestroy {\r\n\r\n    public visNetwork: string = 'networkId1';\r\n    public visNetworkData: ExampleNetworkData;\r\n    public visNetworkOptions: VisNetworkOptions;\r\n\r\n    public constructor(private visNetworkService: VisNetworkService) { }\r\n\r\n    public addNode(): void {\r\n        let newId = this.visNetworkData.nodes.getLength() + 1;\r\n        this.visNetworkData.nodes.add({ id: newId.toString(), label: 'Node ' + newId });\r\n        this.visNetworkService.fit(this.visNetwork);\r\n    }\r\n\r\n    public networkInitialized(): void {\r\n        // now we can use the service to register on events\r\n        this.visNetworkService.on(this.visNetwork, 'click');\r\n\r\n        // open your console/dev tools to see the click params\r\n        this.visNetworkService.click\r\n            .subscribe((eventData: any[]) => {\r\n                if (eventData[0] === this.visNetwork) {\r\n                    console.log(eventData[1]);\r\n                }\r\n            });\r\n    }\r\n\r\n    public ngOnInit(): void {\r\n        let nodes = new VisNodes([\r\n            { id: '1', label: 'Node 1' },\r\n            { id: '2', label: 'Node 2' },\r\n            { id: '3', label: 'Node 3' },\r\n            { id: '4', label: 'Node 4' },\r\n            { id: '5', label: 'Node 5', title: 'Title of Node 5' }]);\r\n\r\n        let edges = new VisEdges([\r\n            { from: '1', to: '3' },\r\n            { from: '1', to: '2' },\r\n            { from: '2', to: '4' },\r\n            { from: '2', to: '5' }]);\r\n\r\n        this.visNetworkData = {\r\n            nodes: nodes,\r\n            edges: edges\r\n        };\r\n\r\n        this.visNetworkOptions = {};\r\n    }\r\n\r\n    public ngOnDestroy(): void {\r\n        this.visNetworkService.off(this.visNetwork, 'click');\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo/network/network-example.component.ts\n **/","module.exports = \"\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/timeline/timeline-example.component.css\n ** module id = 142\n ** module chunks = 1\n **/","module.exports = \"<h2>Timeline</h2>\\r\\n<h3>Basic usage</h3>\\r\\n<div [visTimeline]=\\\"visTimeline\\\" [visTimelineItems]=\\\"visTimelineItems\\\" (initialized)=\\\"timelineInitialized()\\\"></div>\\r\\n<button type=\\\"button\\\" class=\\\"btn btn-default\\\" (click)=\\\"addItem()\\\">Add and focus</button>\\r\\n<p><strong>Note:</strong> Open your dev tools to see the console output when the timeline receives click events.</p>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/timeline/timeline-example.component.html\n ** module id = 143\n ** module chunks = 1\n **/","import { Component, OnInit, OnDestroy } from '@angular/core';\r\n\r\nimport { VisTimelineService, VisTimelineItems } from '../../components/timeline';\r\n\r\n@Component({\r\n    selector: 'timeline-example',\r\n    template: require('./timeline-example.component.html'),\r\n    styles: [\r\n        require('./timeline-example.component.css')\r\n    ]\r\n})\r\nexport class VisTimelineExampleComponent implements OnInit, OnDestroy {\r\n\r\n    public visTimeline: string = 'timelineId1';\r\n    public visTimelineItems: VisTimelineItems;\r\n\r\n    public constructor(private visTimelineService: VisTimelineService) {}\r\n\r\n    public timelineInitialized(): void {\r\n        console.log('timeline initialized');\r\n\r\n        // now we can use the service to register on events\r\n        this.visTimelineService.on(this.visTimeline, 'click');\r\n\r\n        // open your console/dev tools to see the click params\r\n        this.visTimelineService.click\r\n            .subscribe((eventData: any[]) => {\r\n                if (eventData[0] === this.visTimeline) {\r\n                    console.log(eventData[1]);\r\n                }\r\n            });\r\n    }\r\n\r\n    public addItem(): void {\r\n        let newLength = this.visTimelineItems.getLength() + 1;\r\n        this.visTimelineItems.add(\r\n            {id: newLength, content: 'item ' + newLength, start: Date.now() }\r\n        );\r\n        this.visTimelineService.focusOnIds(this.visTimeline, [1, newLength]);\r\n    }\r\n\r\n    public ngOnInit(): void {\r\n        this.visTimelineItems = new VisTimelineItems([\r\n            {id: 1, content: 'item 1', start: '2016-04-20'},\r\n            {id: 2, content: 'item 2', start: '2016-04-14'},\r\n            {id: 3, content: 'item 3', start: '2016-04-18'},\r\n            {id: 4, content: 'item 4', start: '2016-04-16', end: '2016-04-19'},\r\n            {id: 5, content: 'item 5', start: '2016-04-25'},\r\n            {id: 6, content: 'item 6', start: '2016-04-27', type: 'point'}\r\n        ]);\r\n    }\r\n\r\n    public ngOnDestroy(): void {\r\n        this.visTimelineService.off(this.visTimeline, 'click');\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./demo/timeline/timeline-example.component.ts\n **/","import { NgModule } from '@angular/core';\r\n\r\nimport { VisNetworkDirective, VisNetworkService } from './components/network/index';\r\nimport { VisTimelineDirective, VisTimelineService } from './components/timeline/index';\r\n\r\nexport * from './components/index';\r\n\r\n@NgModule({\r\n  declarations: [VisNetworkDirective, VisTimelineDirective],\r\n  exports: [VisNetworkDirective, VisTimelineDirective],\r\n  providers: [VisNetworkService, VisTimelineService],\r\n})\r\nexport class VisModule { }\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ng2-vis.ts\n **/","/**\n * @license Angular v3.2.4\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('rxjs/BehaviorSubject'), require('rxjs/Subject'), require('rxjs/observable/from'), require('rxjs/observable/of'), require('rxjs/operator/concatMap'), require('rxjs/operator/every'), require('rxjs/operator/first'), require('rxjs/operator/map'), require('rxjs/operator/mergeMap'), require('rxjs/operator/reduce'), require('rxjs/Observable'), require('rxjs/operator/catch'), require('rxjs/operator/concatAll'), require('rxjs/util/EmptyError'), require('rxjs/observable/fromPromise'), require('rxjs/operator/last'), require('rxjs/operator/mergeAll'), require('@angular/platform-browser'), require('rxjs/operator/filter')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', 'rxjs/BehaviorSubject', 'rxjs/Subject', 'rxjs/observable/from', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/every', 'rxjs/operator/first', 'rxjs/operator/map', 'rxjs/operator/mergeMap', 'rxjs/operator/reduce', 'rxjs/Observable', 'rxjs/operator/catch', 'rxjs/operator/concatAll', 'rxjs/util/EmptyError', 'rxjs/observable/fromPromise', 'rxjs/operator/last', 'rxjs/operator/mergeAll', '@angular/platform-browser', 'rxjs/operator/filter'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.router = global.ng.router || {}),global.ng.common,global.ng.core,global.Rx,global.Rx,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.platformBrowser,global.Rx.Observable.prototype));\n}(this, function (exports,_angular_common,_angular_core,rxjs_BehaviorSubject,rxjs_Subject,rxjs_observable_from,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_every,rxjs_operator_first,rxjs_operator_map,rxjs_operator_mergeMap,rxjs_operator_reduce,rxjs_Observable,rxjs_operator_catch,rxjs_operator_concatAll,rxjs_util_EmptyError,rxjs_observable_fromPromise,l,rxjs_operator_mergeAll,_angular_platformBrowser,rxjs_operator_filter) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @whatItDoes Name of the primary outlet.\n     *\n     * @stable\n     */\n    var PRIMARY_OUTLET = 'primary';\n    var NavigationCancelingError = (function (_super) {\n        __extends(NavigationCancelingError, _super);\n        function NavigationCancelingError(message) {\n            _super.call(this, message);\n            this.message = message;\n            this.stack = (new Error(message)).stack;\n        }\n        NavigationCancelingError.prototype.toString = function () { return this.message; };\n        return NavigationCancelingError;\n    }(Error));\n    function defaultUrlMatcher(segments, segmentGroup, route) {\n        var path = route.path;\n        var parts = path.split('/');\n        var posParams = {};\n        var consumed = [];\n        var currentIndex = 0;\n        for (var i = 0; i < parts.length; ++i) {\n            if (currentIndex >= segments.length)\n                return null;\n            var current = segments[currentIndex];\n            var p = parts[i];\n            var isPosParam = p.startsWith(':');\n            if (!isPosParam && p !== current.path)\n                return null;\n            if (isPosParam) {\n                posParams[p.substring(1)] = current;\n            }\n            consumed.push(current);\n            currentIndex++;\n        }\n        if (route.pathMatch === 'full' &&\n            (segmentGroup.hasChildren() || currentIndex < segments.length)) {\n            return null;\n        }\n        else {\n            return { consumed: consumed, posParams: posParams };\n        }\n    }\n\n    function shallowEqualArrays(a, b) {\n        if (a.length !== b.length)\n            return false;\n        for (var i = 0; i < a.length; ++i) {\n            if (!shallowEqual(a[i], b[i]))\n                return false;\n        }\n        return true;\n    }\n    function shallowEqual(a, b) {\n        var k1 = Object.keys(a);\n        var k2 = Object.keys(b);\n        if (k1.length != k2.length) {\n            return false;\n        }\n        var key;\n        for (var i = 0; i < k1.length; i++) {\n            key = k1[i];\n            if (a[key] !== b[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function flatten(a) {\n        var target = [];\n        for (var i = 0; i < a.length; ++i) {\n            for (var j = 0; j < a[i].length; ++j) {\n                target.push(a[i][j]);\n            }\n        }\n        return target;\n    }\n    function last(a) {\n        return a.length > 0 ? a[a.length - 1] : null;\n    }\n    function merge(m1, m2) {\n        var m = {};\n        for (var attr in m1) {\n            if (m1.hasOwnProperty(attr)) {\n                m[attr] = m1[attr];\n            }\n        }\n        for (var attr in m2) {\n            if (m2.hasOwnProperty(attr)) {\n                m[attr] = m2[attr];\n            }\n        }\n        return m;\n    }\n    function forEach(map, callback) {\n        for (var prop in map) {\n            if (map.hasOwnProperty(prop)) {\n                callback(map[prop], prop);\n            }\n        }\n    }\n    function waitForMap(obj, fn) {\n        var waitFor = [];\n        var res = {};\n        forEach(obj, function (a, k) {\n            if (k === PRIMARY_OUTLET) {\n                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n                    res[k] = _;\n                    return _;\n                }));\n            }\n        });\n        forEach(obj, function (a, k) {\n            if (k !== PRIMARY_OUTLET) {\n                waitFor.push(rxjs_operator_map.map.call(fn(k, a), function (_) {\n                    res[k] = _;\n                    return _;\n                }));\n            }\n        });\n        if (waitFor.length > 0) {\n            var concatted$ = rxjs_operator_concatAll.concatAll.call(rxjs_observable_of.of.apply(void 0, waitFor));\n            var last$ = l.last.call(concatted$);\n            return rxjs_operator_map.map.call(last$, function () { return res; });\n        }\n        else {\n            return rxjs_observable_of.of(res);\n        }\n    }\n    function andObservables(observables) {\n        var merged$ = rxjs_operator_mergeAll.mergeAll.call(observables);\n        return rxjs_operator_every.every.call(merged$, function (result) { return result === true; });\n    }\n    function wrapIntoObservable(value) {\n        if (value instanceof rxjs_Observable.Observable) {\n            return value;\n        }\n        else if (value instanceof Promise) {\n            return rxjs_observable_fromPromise.fromPromise(value);\n        }\n        else {\n            return rxjs_observable_of.of(value);\n        }\n    }\n\n    /**\n     * @experimental\n     */\n    var ROUTES = new _angular_core.OpaqueToken('ROUTES');\n    var LoadedRouterConfig = (function () {\n        function LoadedRouterConfig(routes, injector, factoryResolver, injectorFactory) {\n            this.routes = routes;\n            this.injector = injector;\n            this.factoryResolver = factoryResolver;\n            this.injectorFactory = injectorFactory;\n        }\n        return LoadedRouterConfig;\n    }());\n    var RouterConfigLoader = (function () {\n        function RouterConfigLoader(loader, compiler) {\n            this.loader = loader;\n            this.compiler = compiler;\n        }\n        RouterConfigLoader.prototype.load = function (parentInjector, loadChildren) {\n            return rxjs_operator_map.map.call(this.loadModuleFactory(loadChildren), function (r) {\n                var ref = r.create(parentInjector);\n                var injectorFactory = function (parent) { return r.create(parent).injector; };\n                return new LoadedRouterConfig(flatten(ref.injector.get(ROUTES)), ref.injector, ref.componentFactoryResolver, injectorFactory);\n            });\n        };\n        RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {\n            var _this = this;\n            if (typeof loadChildren === 'string') {\n                return rxjs_observable_fromPromise.fromPromise(this.loader.load(loadChildren));\n            }\n            else {\n                var offlineMode_1 = this.compiler instanceof _angular_core.Compiler;\n                return rxjs_operator_mergeMap.mergeMap.call(wrapIntoObservable(loadChildren()), function (t) { return offlineMode_1 ? rxjs_observable_of.of(t) : rxjs_observable_fromPromise.fromPromise(_this.compiler.compileModuleAsync(t)); });\n            }\n        };\n        return RouterConfigLoader;\n    }());\n\n    function createEmptyUrlTree() {\n        return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n    }\n    function containsTree(container, containee, exact) {\n        if (exact) {\n            return equalQueryParams(container.queryParams, containee.queryParams) &&\n                equalSegmentGroups(container.root, containee.root);\n        }\n        else {\n            return containsQueryParams(container.queryParams, containee.queryParams) &&\n                containsSegmentGroup(container.root, containee.root);\n        }\n    }\n    function equalQueryParams(container, containee) {\n        return shallowEqual(container, containee);\n    }\n    function equalSegmentGroups(container, containee) {\n        if (!equalPath(container.segments, containee.segments))\n            return false;\n        if (container.numberOfChildren !== containee.numberOfChildren)\n            return false;\n        for (var c in containee.children) {\n            if (!container.children[c])\n                return false;\n            if (!equalSegmentGroups(container.children[c], containee.children[c]))\n                return false;\n        }\n        return true;\n    }\n    function containsQueryParams(container, containee) {\n        return Object.keys(containee) <= Object.keys(container) &&\n            Object.keys(containee).every(function (key) { return containee[key] === container[key]; });\n    }\n    function containsSegmentGroup(container, containee) {\n        return containsSegmentGroupHelper(container, containee, containee.segments);\n    }\n    function containsSegmentGroupHelper(container, containee, containeePaths) {\n        if (container.segments.length > containeePaths.length) {\n            var current = container.segments.slice(0, containeePaths.length);\n            if (!equalPath(current, containeePaths))\n                return false;\n            if (containee.hasChildren())\n                return false;\n            return true;\n        }\n        else if (container.segments.length === containeePaths.length) {\n            if (!equalPath(container.segments, containeePaths))\n                return false;\n            for (var c in containee.children) {\n                if (!container.children[c])\n                    return false;\n                if (!containsSegmentGroup(container.children[c], containee.children[c]))\n                    return false;\n            }\n            return true;\n        }\n        else {\n            var current = containeePaths.slice(0, container.segments.length);\n            var next = containeePaths.slice(container.segments.length);\n            if (!equalPath(container.segments, current))\n                return false;\n            if (!container.children[PRIMARY_OUTLET])\n                return false;\n            return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n        }\n    }\n    /**\n     * @whatItDoes Represents the parsed URL.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'template.html'})\n     * class MyComponent {\n     *   constructor(router: Router) {\n     *     const tree: UrlTree =\n     * router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n     *     const f = tree.fragment; // return 'fragment'\n     *     const q = tree.queryParams; // returns {debug: 'true'}\n     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n     *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n     *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n     *     g.children['support'].segments; // return 1 segment 'help'\n     *   }\n     * }\n     * ```\n     *\n     * @description\n     *\n     * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n     * serialized tree.\n     * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n     *\n     * @stable\n     */\n    var UrlTree = (function () {\n        /**\n         * @internal\n         */\n        function UrlTree(\n            /**\n            * The root segment group of the URL tree.\n             */\n            root, \n            /**\n             * The query params of the URL.\n             */\n            queryParams, \n            /**\n             * The fragment of the URL.\n             */\n            fragment) {\n            this.root = root;\n            this.queryParams = queryParams;\n            this.fragment = fragment;\n        }\n        /**\n         * @docsNotRequired\n         */\n        UrlTree.prototype.toString = function () { return new DefaultUrlSerializer().serialize(this); };\n        return UrlTree;\n    }());\n    /**\n     * @whatItDoes Represents the parsed URL segment.\n     *\n     * See {@link UrlTree} for more information.\n     *\n     * @stable\n     */\n    var UrlSegmentGroup = (function () {\n        function UrlSegmentGroup(\n            /**\n             * The URL segments of this group. See {@link UrlSegment} for more information.\n             */\n            segments, \n            /**\n             * The list of children of this group.\n             */\n            children) {\n            var _this = this;\n            this.segments = segments;\n            this.children = children;\n            /**\n             * The parent node in the url tree.\n             */\n            this.parent = null;\n            forEach(children, function (v, k) { return v.parent = _this; });\n        }\n        /**\n         * Return true if the segment has child segments\n         */\n        UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };\n        Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\n            /**\n             * Returns the number of child sements.\n             */\n            get: function () { return Object.keys(this.children).length; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @docsNotRequired\n         */\n        UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };\n        return UrlSegmentGroup;\n    }());\n    /**\n     * @whatItDoes Represents a single URL segment.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'template.html'})\n     * class MyComponent {\n     *   constructor(router: Router) {\n     *     const tree: UrlTree = router.parseUrl('/team;id=33');\n     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n     *     const s: UrlSegment[] = g.segments;\n     *     s[0].path; // returns 'team'\n     *     s[0].parameters; // returns {id: 33}\n     *   }\n     * }\n     * ```\n     *\n     * @description\n     *\n     * A UrlSegment is a part of a URL between the two slashes. It contains a path and\n     * the matrix parameters associated with the segment.\n     *\n     * @stable\n     */\n    var UrlSegment = (function () {\n        function UrlSegment(\n            /**\n             * The path part of a URL segment.\n             */\n            path, \n            /**\n             * The matrix parameters associated with a segment.\n             */\n            parameters) {\n            this.path = path;\n            this.parameters = parameters;\n        }\n        /**\n         * @docsNotRequired\n         */\n        UrlSegment.prototype.toString = function () { return serializePath(this); };\n        return UrlSegment;\n    }());\n    function equalSegments(a, b) {\n        if (a.length !== b.length)\n            return false;\n        for (var i = 0; i < a.length; ++i) {\n            if (a[i].path !== b[i].path)\n                return false;\n            if (!shallowEqual(a[i].parameters, b[i].parameters))\n                return false;\n        }\n        return true;\n    }\n    function equalPath(a, b) {\n        if (a.length !== b.length)\n            return false;\n        for (var i = 0; i < a.length; ++i) {\n            if (a[i].path !== b[i].path)\n                return false;\n        }\n        return true;\n    }\n    function mapChildrenIntoArray(segment, fn) {\n        var res = [];\n        forEach(segment.children, function (child, childOutlet) {\n            if (childOutlet === PRIMARY_OUTLET) {\n                res = res.concat(fn(child, childOutlet));\n            }\n        });\n        forEach(segment.children, function (child, childOutlet) {\n            if (childOutlet !== PRIMARY_OUTLET) {\n                res = res.concat(fn(child, childOutlet));\n            }\n        });\n        return res;\n    }\n    /**\n     * @whatItDoes Serializes and deserializes a URL string into a URL tree.\n     *\n     * @description The url serialization strategy is customizable. You can\n     * make all URLs case insensitive by providing a custom UrlSerializer.\n     *\n     * See {@link DefaultUrlSerializer} for an example of a URL serializer.\n     *\n     * @stable\n     */\n    var UrlSerializer = (function () {\n        function UrlSerializer() {\n        }\n        return UrlSerializer;\n    }());\n    /**\n     * @whatItDoes A default implementation of the {@link UrlSerializer}.\n     *\n     * @description\n     *\n     * Example URLs:\n     *\n     * ```\n     * /inbox/33(popup:compose)\n     * /inbox/33;open=true/messages/44\n     * ```\n     *\n     * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n     * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n     * specify route specific parameters.\n     *\n     * @stable\n     */\n    var DefaultUrlSerializer = (function () {\n        function DefaultUrlSerializer() {\n        }\n        /**\n         * Parse a url into a {@link UrlTree}.\n         */\n        DefaultUrlSerializer.prototype.parse = function (url) {\n            var p = new UrlParser(url);\n            return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n        };\n        /**\n         * Converts a {@link UrlTree} into a url.\n         */\n        DefaultUrlSerializer.prototype.serialize = function (tree) {\n            var segment = \"/\" + serializeSegment(tree.root, true);\n            var query = serializeQueryParams(tree.queryParams);\n            var fragment = tree.fragment !== null && tree.fragment !== undefined ? \"#\" + encodeURI(tree.fragment) : '';\n            return \"\" + segment + query + fragment;\n        };\n        return DefaultUrlSerializer;\n    }());\n    function serializePaths(segment) {\n        return segment.segments.map(function (p) { return serializePath(p); }).join('/');\n    }\n    function serializeSegment(segment, root) {\n        if (segment.hasChildren() && root) {\n            var primary = segment.children[PRIMARY_OUTLET] ?\n                serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n                '';\n            var children_1 = [];\n            forEach(segment.children, function (v, k) {\n                if (k !== PRIMARY_OUTLET) {\n                    children_1.push(k + \":\" + serializeSegment(v, false));\n                }\n            });\n            if (children_1.length > 0) {\n                return primary + \"(\" + children_1.join('//') + \")\";\n            }\n            else {\n                return \"\" + primary;\n            }\n        }\n        else if (segment.hasChildren() && !root) {\n            var children = mapChildrenIntoArray(segment, function (v, k) {\n                if (k === PRIMARY_OUTLET) {\n                    return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n                }\n                else {\n                    return [(k + \":\" + serializeSegment(v, false))];\n                }\n            });\n            return serializePaths(segment) + \"/(\" + children.join('//') + \")\";\n        }\n        else {\n            return serializePaths(segment);\n        }\n    }\n    function encode(s) {\n        return encodeURIComponent(s);\n    }\n    function decode(s) {\n        return decodeURIComponent(s);\n    }\n    function serializePath(path) {\n        return \"\" + encode(path.path) + serializeParams(path.parameters);\n    }\n    function serializeParams(params) {\n        return pairs(params).map(function (p) { return (\";\" + encode(p.first) + \"=\" + encode(p.second)); }).join('');\n    }\n    function serializeQueryParams(params) {\n        var strs = pairs(params).map(function (p) { return (encode(p.first) + \"=\" + encode(p.second)); });\n        return strs.length > 0 ? \"?\" + strs.join(\"&\") : '';\n    }\n    var Pair = (function () {\n        function Pair(first, second) {\n            this.first = first;\n            this.second = second;\n        }\n        return Pair;\n    }());\n    function pairs(obj) {\n        var res = [];\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                res.push(new Pair(prop, obj[prop]));\n            }\n        }\n        return res;\n    }\n    var SEGMENT_RE = /^[^\\/\\(\\)\\?;=&#]+/;\n    function matchSegments(str) {\n        SEGMENT_RE.lastIndex = 0;\n        var match = str.match(SEGMENT_RE);\n        return match ? match[0] : '';\n    }\n    var QUERY_PARAM_RE = /^[^=\\?&#]+/;\n    function matchQueryParams(str) {\n        QUERY_PARAM_RE.lastIndex = 0;\n        var match = str.match(SEGMENT_RE);\n        return match ? match[0] : '';\n    }\n    var QUERY_PARAM_VALUE_RE = /^[^\\?&#]+/;\n    function matchUrlQueryParamValue(str) {\n        QUERY_PARAM_VALUE_RE.lastIndex = 0;\n        var match = str.match(QUERY_PARAM_VALUE_RE);\n        return match ? match[0] : '';\n    }\n    var UrlParser = (function () {\n        function UrlParser(url) {\n            this.url = url;\n            this.remaining = url;\n        }\n        UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };\n        UrlParser.prototype.capture = function (str) {\n            if (!this.remaining.startsWith(str)) {\n                throw new Error(\"Expected \\\"\" + str + \"\\\".\");\n            }\n            this.remaining = this.remaining.substring(str.length);\n        };\n        UrlParser.prototype.parseRootSegment = function () {\n            if (this.remaining.startsWith('/')) {\n                this.capture('/');\n            }\n            if (this.remaining === '' || this.remaining.startsWith('?') || this.remaining.startsWith('#')) {\n                return new UrlSegmentGroup([], {});\n            }\n            else {\n                return new UrlSegmentGroup([], this.parseChildren());\n            }\n        };\n        UrlParser.prototype.parseChildren = function () {\n            if (this.remaining.length == 0) {\n                return {};\n            }\n            if (this.peekStartsWith('/')) {\n                this.capture('/');\n            }\n            var paths = [];\n            if (!this.peekStartsWith('(')) {\n                paths.push(this.parseSegments());\n            }\n            while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n                this.capture('/');\n                paths.push(this.parseSegments());\n            }\n            var children = {};\n            if (this.peekStartsWith('/(')) {\n                this.capture('/');\n                children = this.parseParens(true);\n            }\n            var res = {};\n            if (this.peekStartsWith('(')) {\n                res = this.parseParens(false);\n            }\n            if (paths.length > 0 || Object.keys(children).length > 0) {\n                res[PRIMARY_OUTLET] = new UrlSegmentGroup(paths, children);\n            }\n            return res;\n        };\n        UrlParser.prototype.parseSegments = function () {\n            var path = matchSegments(this.remaining);\n            if (path === '' && this.peekStartsWith(';')) {\n                throw new Error(\"Empty path url segment cannot have parameters: '\" + this.remaining + \"'.\");\n            }\n            this.capture(path);\n            var matrixParams = {};\n            if (this.peekStartsWith(';')) {\n                matrixParams = this.parseMatrixParams();\n            }\n            return new UrlSegment(decode(path), matrixParams);\n        };\n        UrlParser.prototype.parseQueryParams = function () {\n            var params = {};\n            if (this.peekStartsWith('?')) {\n                this.capture('?');\n                this.parseQueryParam(params);\n                while (this.remaining.length > 0 && this.peekStartsWith('&')) {\n                    this.capture('&');\n                    this.parseQueryParam(params);\n                }\n            }\n            return params;\n        };\n        UrlParser.prototype.parseFragment = function () {\n            if (this.peekStartsWith('#')) {\n                return decodeURI(this.remaining.substring(1));\n            }\n            else {\n                return null;\n            }\n        };\n        UrlParser.prototype.parseMatrixParams = function () {\n            var params = {};\n            while (this.remaining.length > 0 && this.peekStartsWith(';')) {\n                this.capture(';');\n                this.parseParam(params);\n            }\n            return params;\n        };\n        UrlParser.prototype.parseParam = function (params) {\n            var key = matchSegments(this.remaining);\n            if (!key) {\n                return;\n            }\n            this.capture(key);\n            var value = '';\n            if (this.peekStartsWith('=')) {\n                this.capture('=');\n                var valueMatch = matchSegments(this.remaining);\n                if (valueMatch) {\n                    value = valueMatch;\n                    this.capture(value);\n                }\n            }\n            params[decode(key)] = decode(value);\n        };\n        UrlParser.prototype.parseQueryParam = function (params) {\n            var key = matchQueryParams(this.remaining);\n            if (!key) {\n                return;\n            }\n            this.capture(key);\n            var value = '';\n            if (this.peekStartsWith('=')) {\n                this.capture('=');\n                var valueMatch = matchUrlQueryParamValue(this.remaining);\n                if (valueMatch) {\n                    value = valueMatch;\n                    this.capture(value);\n                }\n            }\n            params[decode(key)] = decode(value);\n        };\n        UrlParser.prototype.parseParens = function (allowPrimary) {\n            var segments = {};\n            this.capture('(');\n            while (!this.peekStartsWith(')') && this.remaining.length > 0) {\n                var path = matchSegments(this.remaining);\n                var next = this.remaining[path.length];\n                // if is is not one of these characters, then the segment was unescaped\n                // or the group was not closed\n                if (next !== '/' && next !== ')' && next !== ';') {\n                    throw new Error(\"Cannot parse url '\" + this.url + \"'\");\n                }\n                var outletName = void 0;\n                if (path.indexOf(':') > -1) {\n                    outletName = path.substr(0, path.indexOf(':'));\n                    this.capture(outletName);\n                    this.capture(':');\n                }\n                else if (allowPrimary) {\n                    outletName = PRIMARY_OUTLET;\n                }\n                var children = this.parseChildren();\n                segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n                    new UrlSegmentGroup([], children);\n                if (this.peekStartsWith('//')) {\n                    this.capture('//');\n                }\n            }\n            this.capture(')');\n            return segments;\n        };\n        return UrlParser;\n    }());\n\n    var NoMatch = (function () {\n        function NoMatch(segmentGroup) {\n            if (segmentGroup === void 0) { segmentGroup = null; }\n            this.segmentGroup = segmentGroup;\n        }\n        return NoMatch;\n    }());\n    var AbsoluteRedirect = (function () {\n        function AbsoluteRedirect(urlTree) {\n            this.urlTree = urlTree;\n        }\n        return AbsoluteRedirect;\n    }());\n    function noMatch(segmentGroup) {\n        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });\n    }\n    function absoluteRedirect(newTree) {\n        return new rxjs_Observable.Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });\n    }\n    function namedOutletsRedirect(redirectTo) {\n        return new rxjs_Observable.Observable(function (obs) { return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\" + redirectTo + \"'\")); });\n    }\n    function canLoadFails(route) {\n        return new rxjs_Observable.Observable(function (obs) { return obs.error(new NavigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\" + route.path + \"'\\\" returned false\")); });\n    }\n    function applyRedirects(injector, configLoader, urlSerializer, urlTree, config) {\n        return new ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config).apply();\n    }\n    var ApplyRedirects = (function () {\n        function ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config) {\n            this.injector = injector;\n            this.configLoader = configLoader;\n            this.urlSerializer = urlSerializer;\n            this.urlTree = urlTree;\n            this.config = config;\n            this.allowRedirects = true;\n        }\n        ApplyRedirects.prototype.apply = function () {\n            var _this = this;\n            var expanded$ = this.expandSegmentGroup(this.injector, this.config, this.urlTree.root, PRIMARY_OUTLET);\n            var urlTrees$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, _this.urlTree.fragment); });\n            return rxjs_operator_catch._catch.call(urlTrees$, function (e) {\n                if (e instanceof AbsoluteRedirect) {\n                    // after an absolute redirect we do not apply any more redirects!\n                    _this.allowRedirects = false;\n                    // we need to run matching, so we can fetch all lazy-loaded modules\n                    return _this.match(e.urlTree);\n                }\n                else if (e instanceof NoMatch) {\n                    throw _this.noMatchError(e);\n                }\n                else {\n                    throw e;\n                }\n            });\n        };\n        ApplyRedirects.prototype.match = function (tree) {\n            var _this = this;\n            var expanded$ = this.expandSegmentGroup(this.injector, this.config, tree.root, PRIMARY_OUTLET);\n            var mapped$ = rxjs_operator_map.map.call(expanded$, function (rootSegmentGroup) {\n                return _this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment);\n            });\n            return rxjs_operator_catch._catch.call(mapped$, function (e) {\n                if (e instanceof NoMatch) {\n                    throw _this.noMatchError(e);\n                }\n                else {\n                    throw e;\n                }\n            });\n        };\n        ApplyRedirects.prototype.noMatchError = function (e) {\n            return new Error(\"Cannot match any routes. URL Segment: '\" + e.segmentGroup + \"'\");\n        };\n        ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {\n            var root = rootCandidate.segments.length > 0 ?\n                new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\n                rootCandidate;\n            return new UrlTree(root, queryParams, fragment);\n            var _a;\n        };\n        ApplyRedirects.prototype.expandSegmentGroup = function (injector, routes, segmentGroup, outlet) {\n            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n                return rxjs_operator_map.map.call(this.expandChildren(injector, routes, segmentGroup), function (children) { return new UrlSegmentGroup([], children); });\n            }\n            else {\n                return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);\n            }\n        };\n        ApplyRedirects.prototype.expandChildren = function (injector, routes, segmentGroup) {\n            var _this = this;\n            return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(injector, routes, child, childOutlet); });\n        };\n        ApplyRedirects.prototype.expandSegment = function (injector, segmentGroup, routes, segments, outlet, allowRedirects) {\n            var _this = this;\n            var routes$ = rxjs_observable_of.of.apply(void 0, routes);\n            var processedRoutes$ = rxjs_operator_map.map.call(routes$, function (r) {\n                var expanded$ = _this.expandSegmentAgainstRoute(injector, segmentGroup, routes, r, segments, outlet, allowRedirects);\n                return rxjs_operator_catch._catch.call(expanded$, function (e) {\n                    if (e instanceof NoMatch)\n                        return rxjs_observable_of.of(null);\n                    else\n                        throw e;\n                });\n            });\n            var concattedProcessedRoutes$ = rxjs_operator_concatAll.concatAll.call(processedRoutes$);\n            var first$ = rxjs_operator_first.first.call(concattedProcessedRoutes$, function (s) { return !!s; });\n            return rxjs_operator_catch._catch.call(first$, function (e, _) {\n                if (e instanceof rxjs_util_EmptyError.EmptyError) {\n                    if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n                        return rxjs_observable_of.of(new UrlSegmentGroup([], {}));\n                    }\n                    else {\n                        throw new NoMatch(segmentGroup);\n                    }\n                }\n                else {\n                    throw e;\n                }\n            });\n        };\n        ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\n            return segments.length === 0 && !segmentGroup.children[outlet];\n        };\n        ApplyRedirects.prototype.expandSegmentAgainstRoute = function (injector, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n            if (getOutlet$1(route) !== outlet)\n                return noMatch(segmentGroup);\n            if (route.redirectTo !== undefined && !(allowRedirects && this.allowRedirects))\n                return noMatch(segmentGroup);\n            if (route.redirectTo === undefined) {\n                return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths);\n            }\n            else {\n                return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, paths, outlet);\n            }\n        };\n        ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n            if (route.path === '**') {\n                return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet);\n            }\n            else {\n                return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet);\n            }\n        };\n        ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (injector, routes, route, outlet) {\n            var _this = this;\n            var newTree = this.applyRedirectCommands([], route.redirectTo, {});\n            if (route.redirectTo.startsWith('/')) {\n                return absoluteRedirect(newTree);\n            }\n            else {\n                return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n                    var group = new UrlSegmentGroup(newSegments, {});\n                    return _this.expandSegment(injector, group, routes, newSegments, outlet, false);\n                });\n            }\n        };\n        ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (injector, segmentGroup, routes, route, segments, outlet) {\n            var _this = this;\n            var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\n            if (!matched)\n                return noMatch(segmentGroup);\n            var newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);\n            if (route.redirectTo.startsWith('/')) {\n                return absoluteRedirect(newTree);\n            }\n            else {\n                return rxjs_operator_mergeMap.mergeMap.call(this.lineralizeSegments(route, newTree), function (newSegments) {\n                    return _this.expandSegment(injector, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n                });\n            }\n        };\n        ApplyRedirects.prototype.matchSegmentAgainstRoute = function (injector, rawSegmentGroup, route, segments) {\n            var _this = this;\n            if (route.path === '**') {\n                if (route.loadChildren) {\n                    return rxjs_operator_map.map.call(this.configLoader.load(injector, route.loadChildren), function (r) {\n                        route._loadedConfig = r;\n                        return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n                    });\n                }\n                else {\n                    return rxjs_observable_of.of(new UrlSegmentGroup(segments, {}));\n                }\n            }\n            else {\n                var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments_1 = _a.consumedSegments, lastChild = _a.lastChild;\n                if (!matched)\n                    return noMatch(rawSegmentGroup);\n                var rawSlicedSegments_1 = segments.slice(lastChild);\n                var childConfig$ = this.getChildConfig(injector, route);\n                return rxjs_operator_mergeMap.mergeMap.call(childConfig$, function (routerConfig) {\n                    var childInjector = routerConfig.injector;\n                    var childConfig = routerConfig.routes;\n                    var _a = split(rawSegmentGroup, consumedSegments_1, rawSlicedSegments_1, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\n                    if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                        var expanded$ = _this.expandChildren(childInjector, childConfig, segmentGroup);\n                        return rxjs_operator_map.map.call(expanded$, function (children) { return new UrlSegmentGroup(consumedSegments_1, children); });\n                    }\n                    else if (childConfig.length === 0 && slicedSegments.length === 0) {\n                        return rxjs_observable_of.of(new UrlSegmentGroup(consumedSegments_1, {}));\n                    }\n                    else {\n                        var expanded$ = _this.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n                        return rxjs_operator_map.map.call(expanded$, function (cs) { return new UrlSegmentGroup(consumedSegments_1.concat(cs.segments), cs.children); });\n                    }\n                });\n            }\n        };\n        ApplyRedirects.prototype.getChildConfig = function (injector, route) {\n            var _this = this;\n            if (route.children) {\n                return rxjs_observable_of.of(new LoadedRouterConfig(route.children, injector, null, null));\n            }\n            else if (route.loadChildren) {\n                return rxjs_operator_mergeMap.mergeMap.call(runGuards(injector, route), function (shouldLoad) {\n                    if (shouldLoad) {\n                        if (route._loadedConfig) {\n                            return rxjs_observable_of.of(route._loadedConfig);\n                        }\n                        else {\n                            return rxjs_operator_map.map.call(_this.configLoader.load(injector, route.loadChildren), function (r) {\n                                route._loadedConfig = r;\n                                return r;\n                            });\n                        }\n                    }\n                    else {\n                        return canLoadFails(route);\n                    }\n                });\n            }\n            else {\n                return rxjs_observable_of.of(new LoadedRouterConfig([], injector, null, null));\n            }\n        };\n        ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {\n            var res = [];\n            var c = urlTree.root;\n            while (true) {\n                res = res.concat(c.segments);\n                if (c.numberOfChildren === 0) {\n                    return rxjs_observable_of.of(res);\n                }\n                else if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n                    return namedOutletsRedirect(route.redirectTo);\n                }\n                else {\n                    c = c.children[PRIMARY_OUTLET];\n                }\n            }\n        };\n        ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {\n            var t = this.urlSerializer.parse(redirectTo);\n            return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n        };\n        ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {\n            var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n            return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n        };\n        ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {\n            var res = {};\n            forEach(redirectToParams, function (v, k) {\n                if (v.startsWith(':')) {\n                    res[k] = actualParams[v.substring(1)];\n                }\n                else {\n                    res[k] = v;\n                }\n            });\n            return res;\n        };\n        ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {\n            var _this = this;\n            var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n            var children = {};\n            forEach(group.children, function (child, name) {\n                children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);\n            });\n            return new UrlSegmentGroup(updatedSegments, children);\n        };\n        ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {\n            var _this = this;\n            return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :\n                _this.findOrReturn(s, actualSegments); });\n        };\n        ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {\n            var pos = posParams[redirectToUrlSegment.path.substring(1)];\n            if (!pos)\n                throw new Error(\"Cannot redirect to '\" + redirectTo + \"'. Cannot find '\" + redirectToUrlSegment.path + \"'.\");\n            return pos;\n        };\n        ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {\n            var idx = 0;\n            for (var _i = 0, actualSegments_1 = actualSegments; _i < actualSegments_1.length; _i++) {\n                var s = actualSegments_1[_i];\n                if (s.path === redirectToUrlSegment.path) {\n                    actualSegments.splice(idx);\n                    return s;\n                }\n                idx++;\n            }\n            return redirectToUrlSegment;\n        };\n        return ApplyRedirects;\n    }());\n    function runGuards(injector, route) {\n        var canLoad = route.canLoad;\n        if (!canLoad || canLoad.length === 0)\n            return rxjs_observable_of.of(true);\n        var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canLoad), function (c) {\n            var guard = injector.get(c);\n            if (guard.canLoad) {\n                return wrapIntoObservable(guard.canLoad(route));\n            }\n            else {\n                return wrapIntoObservable(guard(route));\n            }\n        });\n        return andObservables(obs);\n    }\n    function match(segmentGroup, route, segments) {\n        var noMatch = { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n        if (route.path === '') {\n            if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n                return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n            }\n            else {\n                return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\n            }\n        }\n        var matcher = route.matcher || defaultUrlMatcher;\n        var res = matcher(segments, segmentGroup, route);\n        if (!res)\n            return noMatch;\n        return {\n            matched: true,\n            consumedSegments: res.consumed,\n            lastChild: res.consumed.length,\n            positionalParamSegments: res.posParams\n        };\n    }\n    function split(segmentGroup, consumedSegments, slicedSegments, config) {\n        if (slicedSegments.length > 0 &&\n            containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\n        }\n        else if (slicedSegments.length === 0 &&\n            containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\n        }\n        else {\n            return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\n        }\n    }\n    function mergeTrivialChildren(s) {\n        if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n            var c = s.children[PRIMARY_OUTLET];\n            return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n        }\n        else {\n            return s;\n        }\n    }\n    function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n        var res = {};\n        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n            var r = routes_1[_i];\n            if (emptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n            }\n        }\n        return merge(children, res);\n    }\n    function createChildrenForEmptySegments(routes, primarySegmentGroup) {\n        var res = {};\n        res[PRIMARY_OUTLET] = primarySegmentGroup;\n        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n            var r = routes_2[_i];\n            if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n                res[getOutlet$1(r)] = new UrlSegmentGroup([], {});\n            }\n        }\n        return res;\n    }\n    function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n        return routes\n            .filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r) &&\n            getOutlet$1(r) !== PRIMARY_OUTLET; })\n            .length > 0;\n    }\n    function containsEmptyPathRedirects(segmentGroup, slicedSegments, routes) {\n        return routes.filter(function (r) { return emptyPathRedirect(segmentGroup, slicedSegments, r); }).length > 0;\n    }\n    function emptyPathRedirect(segmentGroup, slicedSegments, r) {\n        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n            return false;\n        return r.path === '' && r.redirectTo !== undefined;\n    }\n    function getOutlet$1(route) {\n        return route.outlet ? route.outlet : PRIMARY_OUTLET;\n    }\n\n    function validateConfig(config) {\n        // forEach doesn't iterate undefined values\n        for (var i = 0; i < config.length; i++) {\n            validateNode(config[i]);\n        }\n    }\n    function validateNode(route) {\n        if (!route) {\n            throw new Error(\"\\n      Invalid route configuration: Encountered undefined route.\\n      The reason might be an extra comma.\\n       \\n      Example: \\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \");\n        }\n        if (Array.isArray(route)) {\n            throw new Error(\"Invalid route configuration: Array cannot be specified\");\n        }\n        if (route.component === undefined && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n            throw new Error(\"Invalid route configuration of route '\" + route.path + \"': a componentless route cannot have a named outlet set\");\n        }\n        if (!!route.redirectTo && !!route.children) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and children cannot be used together\");\n        }\n        if (!!route.redirectTo && !!route.loadChildren) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and loadChildren cannot be used together\");\n        }\n        if (!!route.children && !!route.loadChildren) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': children and loadChildren cannot be used together\");\n        }\n        if (!!route.redirectTo && !!route.component) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': redirectTo and component cannot be used together\");\n        }\n        if (!!route.path && !!route.matcher) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': path and matcher cannot be used together\");\n        }\n        if (route.redirectTo === undefined && !route.component && !route.children &&\n            !route.loadChildren) {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': one of the following must be provided (component or redirectTo or children or loadChildren)\");\n        }\n        if (route.path === undefined) {\n            throw new Error(\"Invalid route configuration: routes must have path specified\");\n        }\n        if (route.path.startsWith('/')) {\n            throw new Error(\"Invalid route configuration of route '\" + route.path + \"': path cannot start with a slash\");\n        }\n        if (route.path === '' && route.redirectTo !== undefined && route.pathMatch === undefined) {\n            var exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n            throw new Error(\"Invalid route configuration of route '{path: \\\"\" + route.path + \"\\\", redirectTo: \\\"\" + route.redirectTo + \"\\\"}': please provide 'pathMatch'. \" + exp);\n        }\n        if (route.pathMatch !== undefined && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n            throw new Error(\"Invalid configuration of route '\" + route.path + \"': pathMatch can only be set to 'prefix' or 'full'\");\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var Tree = (function () {\n        function Tree(root) {\n            this._root = root;\n        }\n        Object.defineProperty(Tree.prototype, \"root\", {\n            get: function () { return this._root.value; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @internal\n         */\n        Tree.prototype.parent = function (t) {\n            var p = this.pathFromRoot(t);\n            return p.length > 1 ? p[p.length - 2] : null;\n        };\n        /**\n         * @internal\n         */\n        Tree.prototype.children = function (t) {\n            var n = findNode(t, this._root);\n            return n ? n.children.map(function (t) { return t.value; }) : [];\n        };\n        /**\n         * @internal\n         */\n        Tree.prototype.firstChild = function (t) {\n            var n = findNode(t, this._root);\n            return n && n.children.length > 0 ? n.children[0].value : null;\n        };\n        /**\n         * @internal\n         */\n        Tree.prototype.siblings = function (t) {\n            var p = findPath(t, this._root, []);\n            if (p.length < 2)\n                return [];\n            var c = p[p.length - 2].children.map(function (c) { return c.value; });\n            return c.filter(function (cc) { return cc !== t; });\n        };\n        /**\n         * @internal\n         */\n        Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root, []).map(function (s) { return s.value; }); };\n        return Tree;\n    }());\n    function findNode(expected, c) {\n        if (expected === c.value)\n            return c;\n        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n            var cc = _a[_i];\n            var r = findNode(expected, cc);\n            if (r)\n                return r;\n        }\n        return null;\n    }\n    function findPath(expected, c, collected) {\n        collected.push(c);\n        if (expected === c.value)\n            return collected;\n        for (var _i = 0, _a = c.children; _i < _a.length; _i++) {\n            var cc = _a[_i];\n            var cloned = collected.slice(0);\n            var r = findPath(expected, cc, cloned);\n            if (r.length > 0)\n                return r;\n        }\n        return [];\n    }\n    var TreeNode = (function () {\n        function TreeNode(value, children) {\n            this.value = value;\n            this.children = children;\n        }\n        TreeNode.prototype.toString = function () { return \"TreeNode(\" + this.value + \")\"; };\n        return TreeNode;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @whatItDoes Represents the state of the router.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'template.html'})\n     * class MyComponent {\n     *   constructor(router: Router) {\n     *     const state: RouterState = router.routerState;\n     *     const root: ActivatedRoute = state.root;\n     *     const child = root.firstChild;\n     *     const id: Observable<string> = child.params.map(p => p.id);\n     *     //...\n     *   }\n     * }\n     * ```\n     *\n     * @description\n     * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n     * segments,\n     * the extracted parameters, and the resolved data.\n     *\n     * See {@link ActivatedRoute} for more information.\n     *\n     * @stable\n     */\n    var RouterState = (function (_super) {\n        __extends$1(RouterState, _super);\n        /**\n         * @internal\n         */\n        function RouterState(root, \n            /**\n             * The current snapshot of the router state.\n             */\n            snapshot) {\n            _super.call(this, root);\n            this.snapshot = snapshot;\n            setRouterStateSnapshot(this, root);\n        }\n        RouterState.prototype.toString = function () { return this.snapshot.toString(); };\n        return RouterState;\n    }(Tree));\n    function createEmptyState(urlTree, rootComponent) {\n        var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n        var emptyUrl = new rxjs_BehaviorSubject.BehaviorSubject([new UrlSegment('', {})]);\n        var emptyParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n        var emptyData = new rxjs_BehaviorSubject.BehaviorSubject({});\n        var emptyQueryParams = new rxjs_BehaviorSubject.BehaviorSubject({});\n        var fragment = new rxjs_BehaviorSubject.BehaviorSubject('');\n        var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n        activated.snapshot = snapshot.root;\n        return new RouterState(new TreeNode(activated, []), snapshot);\n    }\n    function createEmptyStateSnapshot(urlTree, rootComponent) {\n        var emptyParams = {};\n        var emptyData = {};\n        var emptyQueryParams = {};\n        var fragment = '';\n        var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n        return new RouterStateSnapshot('', new TreeNode(activated, []));\n    }\n    /**\n     * @whatItDoes Contains the information about a route associated with a component loaded in an\n     * outlet.\n     * ActivatedRoute can also be used to traverse the router state tree.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'./my-component.html'})\n     * class MyComponent {\n     *   constructor(route: ActivatedRoute) {\n     *     const id: Observable<string> = route.params.map(p => p.id);\n     *     const url: Observable<string> = route.url.map(s => s.join(''));\n     *     const user = route.data.map(d => d.user); //includes `data` and `resolve`\n     *   }\n     * }\n     * ```\n     *\n     * @stable\n     */\n    var ActivatedRoute = (function () {\n        /**\n         * @internal\n         */\n        function ActivatedRoute(\n            /**\n             *  The URL segments matched by this route. The observable will emit a new value when\n             *  the array of segments changes.\n             */\n            url, \n            /**\n             * The matrix parameters scoped to this route. The observable will emit a new value when\n             * the set of the parameters changes.\n             */\n            params, \n            /**\n             * The query parameters shared by all the routes. The observable will emit a new value when\n             * the set of the parameters changes.\n             */\n            queryParams, \n            /**\n             * The URL fragment shared by all the routes. The observable will emit a new value when\n             * the URL fragment changes.\n             */\n            fragment, \n            /**\n             * The static and resolved data of this route. The observable will emit a new value when\n             * any of the resolvers returns a new object.\n             */\n            data, \n            /**\n             * The outlet name of the route. It's a constant.\n             */\n            outlet, \n            /**\n             * The component of the route. It's a constant.\n             */\n            component, // TODO: vsavkin: remove |string\n            futureSnapshot) {\n            this.url = url;\n            this.params = params;\n            this.queryParams = queryParams;\n            this.fragment = fragment;\n            this.data = data;\n            this.outlet = outlet;\n            this.component = component;\n            this._futureSnapshot = futureSnapshot;\n        }\n        Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\n            /**\n             * The configuration used to match this route.\n             */\n            get: function () { return this._futureSnapshot.routeConfig; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"root\", {\n            /**\n             * The root of the router state.\n             */\n            get: function () { return this._routerState.root; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\n            /**\n             * The parent of this route in the router state tree.\n             */\n            get: function () { return this._routerState.parent(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\n            /**\n             * The first child of this route in the router state tree.\n             */\n            get: function () { return this._routerState.firstChild(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"children\", {\n            /**\n             * The children of this route in the router state tree.\n             */\n            get: function () { return this._routerState.children(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\n            /**\n             * The path from the root of the router state tree to this route.\n             */\n            get: function () { return this._routerState.pathFromRoot(this); },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @docsNotRequired\n         */\n        ActivatedRoute.prototype.toString = function () {\n            return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\n        };\n        return ActivatedRoute;\n    }());\n    /**\n     * @internal\n     */\n    function inheritedParamsDataResolve(route) {\n        var pathToRoot = route.pathFromRoot;\n        var inhertingStartingFrom = pathToRoot.length - 1;\n        while (inhertingStartingFrom >= 1) {\n            var current = pathToRoot[inhertingStartingFrom];\n            var parent_1 = pathToRoot[inhertingStartingFrom - 1];\n            // current route is an empty path => inherits its parent's params and data\n            if (current.routeConfig && current.routeConfig.path === '') {\n                inhertingStartingFrom--;\n            }\n            else if (!parent_1.component) {\n                inhertingStartingFrom--;\n            }\n            else {\n                break;\n            }\n        }\n        return pathToRoot.slice(inhertingStartingFrom).reduce(function (res, curr) {\n            var params = merge(res.params, curr.params);\n            var data = merge(res.data, curr.data);\n            var resolve = merge(res.resolve, curr._resolvedData);\n            return { params: params, data: data, resolve: resolve };\n        }, { params: {}, data: {}, resolve: {} });\n    }\n    /**\n     * @whatItDoes Contains the information about a route associated with a component loaded in an\n     * outlet\n     * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router\n     * state tree.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'./my-component.html'})\n     * class MyComponent {\n     *   constructor(route: ActivatedRoute) {\n     *     const id: string = route.snapshot.params.id;\n     *     const url: string = route.snapshot.url.join('');\n     *     const user = route.snapshot.data.user;\n     *   }\n     * }\n     * ```\n     *\n     * @stable\n     */\n    var ActivatedRouteSnapshot = (function () {\n        /**\n         * @internal\n         */\n        function ActivatedRouteSnapshot(\n            /**\n             *  The URL segments matched by this route.\n             */\n            url, \n            /**\n             * The matrix parameters scoped to this route.\n             */\n            params, \n            /**\n             * The query parameters shared by all the routes.\n             */\n            queryParams, \n            /**\n             * The URL fragment shared by all the routes.\n             */\n            fragment, \n            /**\n             * The static and resolved data of this route.\n             */\n            data, \n            /**\n             * The outlet name of the route.\n             */\n            outlet, \n            /**\n             * The component of the route.\n             */\n            component, routeConfig, urlSegment, lastPathIndex, resolve) {\n            this.url = url;\n            this.params = params;\n            this.queryParams = queryParams;\n            this.fragment = fragment;\n            this.data = data;\n            this.outlet = outlet;\n            this.component = component;\n            this._routeConfig = routeConfig;\n            this._urlSegment = urlSegment;\n            this._lastPathIndex = lastPathIndex;\n            this._resolve = resolve;\n        }\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"routeConfig\", {\n            /**\n             * The configuration used to match this route.\n             */\n            get: function () { return this._routeConfig; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\n            /**\n             * The root of the router state.\n             */\n            get: function () { return this._routerState.root; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\n            /**\n             * The parent of this route in the router state tree.\n             */\n            get: function () { return this._routerState.parent(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\n            /**\n             * The first child of this route in the router state tree.\n             */\n            get: function () { return this._routerState.firstChild(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\n            /**\n             * The children of this route in the router state tree.\n             */\n            get: function () { return this._routerState.children(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\n            /**\n             * The path from the root of the router state tree to this route.\n             */\n            get: function () { return this._routerState.pathFromRoot(this); },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @docsNotRequired\n         */\n        ActivatedRouteSnapshot.prototype.toString = function () {\n            var url = this.url.map(function (s) { return s.toString(); }).join('/');\n            var matched = this._routeConfig ? this._routeConfig.path : '';\n            return \"Route(url:'\" + url + \"', path:'\" + matched + \"')\";\n        };\n        return ActivatedRouteSnapshot;\n    }());\n    /**\n     * @whatItDoes Represents the state of the router at a moment in time.\n     *\n     * @howToUse\n     *\n     * ```\n     * @Component({templateUrl:'template.html'})\n     * class MyComponent {\n     *   constructor(router: Router) {\n     *     const state: RouterState = router.routerState;\n     *     const snapshot: RouterStateSnapshot = state.snapshot;\n     *     const root: ActivatedRouteSnapshot = snapshot.root;\n     *     const child = root.firstChild;\n     *     const id: Observable<string> = child.params.map(p => p.id);\n     *     //...\n     *   }\n     * }\n     * ```\n     *\n     * @description\n     * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about\n     * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n     *\n     * @stable\n     */\n    var RouterStateSnapshot = (function (_super) {\n        __extends$1(RouterStateSnapshot, _super);\n        /**\n         * @internal\n         */\n        function RouterStateSnapshot(\n            /** The url from which this snapshot was created */\n            url, root) {\n            _super.call(this, root);\n            this.url = url;\n            setRouterStateSnapshot(this, root);\n        }\n        RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };\n        return RouterStateSnapshot;\n    }(Tree));\n    function setRouterStateSnapshot(state, node) {\n        node.value._routerState = state;\n        node.children.forEach(function (c) { return setRouterStateSnapshot(state, c); });\n    }\n    function serializeNode(node) {\n        var c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(\", \") + \" } \" : '';\n        return \"\" + node.value + c;\n    }\n    /**\n     * The expectation is that the activate route is created with the right set of parameters.\n     * So we push new values into the observables only when they are not the initial values.\n     * And we detect that by checking if the snapshot field is set.\n     */\n    function advanceActivatedRoute(route) {\n        if (route.snapshot) {\n            if (!shallowEqual(route.snapshot.queryParams, route._futureSnapshot.queryParams)) {\n                route.queryParams.next(route._futureSnapshot.queryParams);\n            }\n            if (route.snapshot.fragment !== route._futureSnapshot.fragment) {\n                route.fragment.next(route._futureSnapshot.fragment);\n            }\n            if (!shallowEqual(route.snapshot.params, route._futureSnapshot.params)) {\n                route.params.next(route._futureSnapshot.params);\n            }\n            if (!shallowEqualArrays(route.snapshot.url, route._futureSnapshot.url)) {\n                route.url.next(route._futureSnapshot.url);\n            }\n            if (!equalParamsAndUrlSegments(route.snapshot, route._futureSnapshot)) {\n                route.data.next(route._futureSnapshot.data);\n            }\n            route.snapshot = route._futureSnapshot;\n        }\n        else {\n            route.snapshot = route._futureSnapshot;\n            // this is for resolved data\n            route.data.next(route._futureSnapshot.data);\n        }\n    }\n    function equalParamsAndUrlSegments(a, b) {\n        return shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n    }\n\n    function createRouterState(curr, prevState) {\n        var root = createNode(curr._root, prevState ? prevState._root : undefined);\n        return new RouterState(root, curr);\n    }\n    function createNode(curr, prevState) {\n        if (prevState && equalRouteSnapshots(prevState.value.snapshot, curr.value)) {\n            var value = prevState.value;\n            value._futureSnapshot = curr.value;\n            var children = createOrReuseChildren(curr, prevState);\n            return new TreeNode(value, children);\n        }\n        else {\n            var value = createActivatedRoute(curr.value);\n            var children = curr.children.map(function (c) { return createNode(c); });\n            return new TreeNode(value, children);\n        }\n    }\n    function createOrReuseChildren(curr, prevState) {\n        return curr.children.map(function (child) {\n            for (var _i = 0, _a = prevState.children; _i < _a.length; _i++) {\n                var p = _a[_i];\n                if (equalRouteSnapshots(p.value.snapshot, child.value)) {\n                    return createNode(child, p);\n                }\n            }\n            return createNode(child);\n        });\n    }\n    function createActivatedRoute(c) {\n        return new ActivatedRoute(new rxjs_BehaviorSubject.BehaviorSubject(c.url), new rxjs_BehaviorSubject.BehaviorSubject(c.params), new rxjs_BehaviorSubject.BehaviorSubject(c.queryParams), new rxjs_BehaviorSubject.BehaviorSubject(c.fragment), new rxjs_BehaviorSubject.BehaviorSubject(c.data), c.outlet, c.component, c);\n    }\n    function equalRouteSnapshots(a, b) {\n        return a._routeConfig === b._routeConfig;\n    }\n\n    function createUrlTree(route, urlTree, commands, queryParams, fragment) {\n        if (commands.length === 0) {\n            return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n        }\n        var normalizedCommands = normalizeCommands(commands);\n        validateCommands(normalizedCommands);\n        if (navigateToRoot(normalizedCommands)) {\n            return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n        }\n        var startingPosition = findStartingPosition(normalizedCommands, urlTree, route);\n        var segmentGroup = startingPosition.processChildren ?\n            updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, normalizedCommands.commands) :\n            updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, normalizedCommands.commands);\n        return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n    }\n    function validateCommands(n) {\n        if (n.isAbsolute && n.commands.length > 0 && isMatrixParams(n.commands[0])) {\n            throw new Error('Root segment cannot have matrix parameters');\n        }\n        var c = n.commands.filter(function (c) { return typeof c === 'object' && c.outlets !== undefined; });\n        if (c.length > 0 && c[0] !== n.commands[n.commands.length - 1]) {\n            throw new Error('{outlets:{}} has to be the last command');\n        }\n    }\n    function isMatrixParams(command) {\n        return typeof command === 'object' && command.outlets === undefined &&\n            command.segmentPath === undefined;\n    }\n    function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n        if (urlTree.root === oldSegmentGroup) {\n            return new UrlTree(newSegmentGroup, stringify(queryParams), fragment);\n        }\n        else {\n            return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), stringify(queryParams), fragment);\n        }\n    }\n    function replaceSegment(current, oldSegment, newSegment) {\n        var children = {};\n        forEach(current.children, function (c, outletName) {\n            if (c === oldSegment) {\n                children[outletName] = newSegment;\n            }\n            else {\n                children[outletName] = replaceSegment(c, oldSegment, newSegment);\n            }\n        });\n        return new UrlSegmentGroup(current.segments, children);\n    }\n    function navigateToRoot(normalizedChange) {\n        return normalizedChange.isAbsolute && normalizedChange.commands.length === 1 &&\n            normalizedChange.commands[0] == '/';\n    }\n    var NormalizedNavigationCommands = (function () {\n        function NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, commands) {\n            this.isAbsolute = isAbsolute;\n            this.numberOfDoubleDots = numberOfDoubleDots;\n            this.commands = commands;\n        }\n        return NormalizedNavigationCommands;\n    }());\n    function normalizeCommands(commands) {\n        if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] == '/') {\n            return new NormalizedNavigationCommands(true, 0, commands);\n        }\n        var numberOfDoubleDots = 0;\n        var isAbsolute = false;\n        var res = [];\n        var _loop_1 = function(i) {\n            var c = commands[i];\n            if (typeof c === 'object' && c.outlets !== undefined) {\n                var r_1 = {};\n                forEach(c.outlets, function (commands, name) {\n                    if (typeof commands === 'string') {\n                        r_1[name] = commands.split('/');\n                    }\n                    else {\n                        r_1[name] = commands;\n                    }\n                });\n                res.push({ outlets: r_1 });\n                return \"continue\";\n            }\n            if (typeof c === 'object' && c.segmentPath !== undefined) {\n                res.push(c.segmentPath);\n                return \"continue\";\n            }\n            if (!(typeof c === 'string')) {\n                res.push(c);\n                return \"continue\";\n            }\n            if (i === 0) {\n                var parts = c.split('/');\n                for (var j = 0; j < parts.length; ++j) {\n                    var cc = parts[j];\n                    if (j == 0 && cc == '.') {\n                    }\n                    else if (j == 0 && cc == '') {\n                        isAbsolute = true;\n                    }\n                    else if (cc == '..') {\n                        numberOfDoubleDots++;\n                    }\n                    else if (cc != '') {\n                        res.push(cc);\n                    }\n                }\n            }\n            else {\n                res.push(c);\n            }\n        };\n        for (var i = 0; i < commands.length; ++i) {\n            _loop_1(i);\n        }\n        return new NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, res);\n    }\n    var Position = (function () {\n        function Position(segmentGroup, processChildren, index) {\n            this.segmentGroup = segmentGroup;\n            this.processChildren = processChildren;\n            this.index = index;\n        }\n        return Position;\n    }());\n    function findStartingPosition(normalizedChange, urlTree, route) {\n        if (normalizedChange.isAbsolute) {\n            return new Position(urlTree.root, true, 0);\n        }\n        else if (route.snapshot._lastPathIndex === -1) {\n            return new Position(route.snapshot._urlSegment, true, 0);\n        }\n        else {\n            var modifier = isMatrixParams(normalizedChange.commands[0]) ? 0 : 1;\n            var index = route.snapshot._lastPathIndex + modifier;\n            return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, normalizedChange.numberOfDoubleDots);\n        }\n    }\n    function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n        var g = group;\n        var ci = index;\n        var dd = numberOfDoubleDots;\n        while (dd > ci) {\n            dd -= ci;\n            g = g.parent;\n            if (!g) {\n                throw new Error('Invalid number of \\'../\\'');\n            }\n            ci = g.segments.length;\n        }\n        return new Position(g, false, ci - dd);\n    }\n    function getPath(command) {\n        if (typeof command === 'object' && command.outlets)\n            return command.outlets[PRIMARY_OUTLET];\n        return \"\" + command;\n    }\n    function getOutlets(commands) {\n        if (!(typeof commands[0] === 'object'))\n            return (_a = {}, _a[PRIMARY_OUTLET] = commands, _a);\n        if (commands[0].outlets === undefined)\n            return (_b = {}, _b[PRIMARY_OUTLET] = commands, _b);\n        return commands[0].outlets;\n        var _a, _b;\n    }\n    function updateSegmentGroup(segmentGroup, startIndex, commands) {\n        if (!segmentGroup) {\n            segmentGroup = new UrlSegmentGroup([], {});\n        }\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n        }\n        var m = prefixedWith(segmentGroup, startIndex, commands);\n        var slicedCommands = commands.slice(m.commandIndex);\n        if (m.match && m.pathIndex < segmentGroup.segments.length) {\n            var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n            g.children[PRIMARY_OUTLET] =\n                new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n            return updateSegmentGroupChildren(g, 0, slicedCommands);\n        }\n        else if (m.match && slicedCommands.length === 0) {\n            return new UrlSegmentGroup(segmentGroup.segments, {});\n        }\n        else if (m.match && !segmentGroup.hasChildren()) {\n            return createNewSegmentGroup(segmentGroup, startIndex, commands);\n        }\n        else if (m.match) {\n            return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n        }\n        else {\n            return createNewSegmentGroup(segmentGroup, startIndex, commands);\n        }\n    }\n    function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n        if (commands.length === 0) {\n            return new UrlSegmentGroup(segmentGroup.segments, {});\n        }\n        else {\n            var outlets_1 = getOutlets(commands);\n            var children_1 = {};\n            forEach(outlets_1, function (commands, outlet) {\n                if (commands !== null) {\n                    children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n                }\n            });\n            forEach(segmentGroup.children, function (child, childOutlet) {\n                if (outlets_1[childOutlet] === undefined) {\n                    children_1[childOutlet] = child;\n                }\n            });\n            return new UrlSegmentGroup(segmentGroup.segments, children_1);\n        }\n    }\n    function prefixedWith(segmentGroup, startIndex, commands) {\n        var currentCommandIndex = 0;\n        var currentPathIndex = startIndex;\n        var noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n        while (currentPathIndex < segmentGroup.segments.length) {\n            if (currentCommandIndex >= commands.length)\n                return noMatch;\n            var path = segmentGroup.segments[currentPathIndex];\n            var curr = getPath(commands[currentCommandIndex]);\n            var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n            if (currentPathIndex > 0 && curr === undefined)\n                break;\n            if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n                if (!compare(curr, next, path))\n                    return noMatch;\n                currentCommandIndex += 2;\n            }\n            else {\n                if (!compare(curr, {}, path))\n                    return noMatch;\n                currentCommandIndex++;\n            }\n            currentPathIndex++;\n        }\n        return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n    }\n    function createNewSegmentGroup(segmentGroup, startIndex, commands) {\n        var paths = segmentGroup.segments.slice(0, startIndex);\n        var i = 0;\n        while (i < commands.length) {\n            if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n                var children = createNewSegmentChldren(commands[i].outlets);\n                return new UrlSegmentGroup(paths, children);\n            }\n            // if we start with an object literal, we need to reuse the path part from the segment\n            if (i === 0 && isMatrixParams(commands[0])) {\n                var p = segmentGroup.segments[startIndex];\n                paths.push(new UrlSegment(p.path, commands[0]));\n                i++;\n                continue;\n            }\n            var curr = getPath(commands[i]);\n            var next = (i < commands.length - 1) ? commands[i + 1] : null;\n            if (curr && next && isMatrixParams(next)) {\n                paths.push(new UrlSegment(curr, stringify(next)));\n                i += 2;\n            }\n            else {\n                paths.push(new UrlSegment(curr, {}));\n                i++;\n            }\n        }\n        return new UrlSegmentGroup(paths, {});\n    }\n    function createNewSegmentChldren(outlets) {\n        var children = {};\n        forEach(outlets, function (commands, outlet) {\n            if (commands !== null) {\n                children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n            }\n        });\n        return children;\n    }\n    function stringify(params) {\n        var res = {};\n        forEach(params, function (v, k) { return res[k] = \"\" + v; });\n        return res;\n    }\n    function compare(path, params, segment) {\n        return path == segment.path && shallowEqual(params, segment.parameters);\n    }\n\n    var NoMatch$1 = (function () {\n        function NoMatch() {\n        }\n        return NoMatch;\n    }());\n    function recognize(rootComponentType, config, urlTree, url) {\n        return new Recognizer(rootComponentType, config, urlTree, url).recognize();\n    }\n    var Recognizer = (function () {\n        function Recognizer(rootComponentType, config, urlTree, url) {\n            this.rootComponentType = rootComponentType;\n            this.config = config;\n            this.urlTree = urlTree;\n            this.url = url;\n        }\n        Recognizer.prototype.recognize = function () {\n            try {\n                var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config).segmentGroup;\n                var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n                var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n                var rootNode = new TreeNode(root, children);\n                var routeState = new RouterStateSnapshot(this.url, rootNode);\n                this.inheriteParamsAndData(routeState._root);\n                return rxjs_observable_of.of(routeState);\n            }\n            catch (e) {\n                return new rxjs_Observable.Observable(function (obs) { return obs.error(e); });\n            }\n        };\n        Recognizer.prototype.inheriteParamsAndData = function (routeNode) {\n            var _this = this;\n            var route = routeNode.value;\n            var i = inheritedParamsDataResolve(route);\n            route.params = Object.freeze(i.params);\n            route.data = Object.freeze(i.data);\n            routeNode.children.forEach(function (n) { return _this.inheriteParamsAndData(n); });\n        };\n        Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {\n            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n                return this.processChildren(config, segmentGroup);\n            }\n            else {\n                return this.processSegment(config, segmentGroup, 0, segmentGroup.segments, outlet);\n            }\n        };\n        Recognizer.prototype.processChildren = function (config, segmentGroup) {\n            var _this = this;\n            var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\n            checkOutletNameUniqueness(children);\n            sortActivatedRouteSnapshots(children);\n            return children;\n        };\n        Recognizer.prototype.processSegment = function (config, segmentGroup, pathIndex, segments, outlet) {\n            for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {\n                var r = config_1[_i];\n                try {\n                    return this.processSegmentAgainstRoute(r, segmentGroup, pathIndex, segments, outlet);\n                }\n                catch (e) {\n                    if (!(e instanceof NoMatch$1))\n                        throw e;\n                }\n            }\n            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n                return [];\n            }\n            else {\n                throw new NoMatch$1();\n            }\n        };\n        Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\n            return segments.length === 0 && !segmentGroup.children[outlet];\n        };\n        Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, pathIndex, segments, outlet) {\n            if (route.redirectTo)\n                throw new NoMatch$1();\n            if ((route.outlet ? route.outlet : PRIMARY_OUTLET) !== outlet)\n                throw new NoMatch$1();\n            if (route.path === '**') {\n                var params = segments.length > 0 ? last(segments).parameters : {};\n                var snapshot_1 = new ActivatedRouteSnapshot(segments, params, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n                return [new TreeNode(snapshot_1, [])];\n            }\n            var _a = match$1(rawSegment, route, segments), consumedSegments = _a.consumedSegments, parameters = _a.parameters, lastChild = _a.lastChild;\n            var rawSlicedSegments = segments.slice(lastChild);\n            var childConfig = getChildConfig(route);\n            var _b = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _b.segmentGroup, slicedSegments = _b.slicedSegments;\n            var snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(this.urlTree.queryParams), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                var children = this.processChildren(childConfig, segmentGroup);\n                return [new TreeNode(snapshot, children)];\n            }\n            else if (childConfig.length === 0 && slicedSegments.length === 0) {\n                return [new TreeNode(snapshot, [])];\n            }\n            else {\n                var children = this.processSegment(childConfig, segmentGroup, pathIndex + lastChild, slicedSegments, PRIMARY_OUTLET);\n                return [new TreeNode(snapshot, children)];\n            }\n        };\n        return Recognizer;\n    }());\n    function sortActivatedRouteSnapshots(nodes) {\n        nodes.sort(function (a, b) {\n            if (a.value.outlet === PRIMARY_OUTLET)\n                return -1;\n            if (b.value.outlet === PRIMARY_OUTLET)\n                return 1;\n            return a.value.outlet.localeCompare(b.value.outlet);\n        });\n    }\n    function getChildConfig(route) {\n        if (route.children) {\n            return route.children;\n        }\n        else if (route.loadChildren) {\n            return route._loadedConfig.routes;\n        }\n        else {\n            return [];\n        }\n    }\n    function match$1(segmentGroup, route, segments) {\n        if (route.path === '') {\n            if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n                throw new NoMatch$1();\n            }\n            else {\n                return { consumedSegments: [], lastChild: 0, parameters: {} };\n            }\n        }\n        var matcher = route.matcher || defaultUrlMatcher;\n        var res = matcher(segments, segmentGroup, route);\n        if (!res)\n            throw new NoMatch$1();\n        var posParams = {};\n        forEach(res.posParams, function (v, k) { posParams[k] = v.path; });\n        var parameters = merge(posParams, res.consumed[res.consumed.length - 1].parameters);\n        return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };\n    }\n    function checkOutletNameUniqueness(nodes) {\n        var names = {};\n        nodes.forEach(function (n) {\n            var routeWithSameOutletName = names[n.value.outlet];\n            if (routeWithSameOutletName) {\n                var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');\n                var c = n.value.url.map(function (s) { return s.toString(); }).join('/');\n                throw new Error(\"Two segments cannot have the same outlet name: '\" + p + \"' and '\" + c + \"'.\");\n            }\n            names[n.value.outlet] = n.value;\n        });\n    }\n    function getSourceSegmentGroup(segmentGroup) {\n        var s = segmentGroup;\n        while (s._sourceSegment) {\n            s = s._sourceSegment;\n        }\n        return s;\n    }\n    function getPathIndexShift(segmentGroup) {\n        var s = segmentGroup;\n        var res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n        while (s._sourceSegment) {\n            s = s._sourceSegment;\n            res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n        }\n        return res - 1;\n    }\n    function split$1(segmentGroup, consumedSegments, slicedSegments, config) {\n        if (slicedSegments.length > 0 &&\n            containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = consumedSegments.length;\n            return { segmentGroup: s, slicedSegments: [] };\n        }\n        else if (slicedSegments.length === 0 &&\n            containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = consumedSegments.length;\n            return { segmentGroup: s, slicedSegments: slicedSegments };\n        }\n        else {\n            var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n            s._sourceSegment = segmentGroup;\n            s._segmentIndexShift = consumedSegments.length;\n            return { segmentGroup: s, slicedSegments: slicedSegments };\n        }\n    }\n    function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n        var res = {};\n        for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n            var r = routes_1[_i];\n            if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$2(r)]) {\n                var s = new UrlSegmentGroup([], {});\n                s._sourceSegment = segmentGroup;\n                s._segmentIndexShift = segmentGroup.segments.length;\n                res[getOutlet$2(r)] = s;\n            }\n        }\n        return merge(children, res);\n    }\n    function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n        var res = {};\n        res[PRIMARY_OUTLET] = primarySegment;\n        primarySegment._sourceSegment = segmentGroup;\n        primarySegment._segmentIndexShift = consumedSegments.length;\n        for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {\n            var r = routes_2[_i];\n            if (r.path === '' && getOutlet$2(r) !== PRIMARY_OUTLET) {\n                var s = new UrlSegmentGroup([], {});\n                s._sourceSegment = segmentGroup;\n                s._segmentIndexShift = consumedSegments.length;\n                res[getOutlet$2(r)] = s;\n            }\n        }\n        return res;\n    }\n    function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n        return routes\n            .filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) &&\n            getOutlet$2(r) !== PRIMARY_OUTLET; })\n            .length > 0;\n    }\n    function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n        return routes.filter(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); }).length > 0;\n    }\n    function emptyPathMatch(segmentGroup, slicedSegments, r) {\n        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full')\n            return false;\n        return r.path === '' && r.redirectTo === undefined;\n    }\n    function getOutlet$2(route) {\n        return route.outlet ? route.outlet : PRIMARY_OUTLET;\n    }\n    function getData(route) {\n        return route.data ? route.data : {};\n    }\n    function getResolve(route) {\n        return route.resolve ? route.resolve : {};\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @whatItDoes Contains all the router outlets created in a component.\n     *\n     * @stable\n     */\n    var RouterOutletMap = (function () {\n        function RouterOutletMap() {\n            /** @internal */\n            this._outlets = {};\n        }\n        /**\n         * Adds an outlet to this map.\n         */\n        RouterOutletMap.prototype.registerOutlet = function (name, outlet) { this._outlets[name] = outlet; };\n        /**\n         * Removes an outlet from this map.\n         */\n        RouterOutletMap.prototype.removeOutlet = function (name) { this._outlets[name] = undefined; };\n        return RouterOutletMap;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @whatItDoes Provides a way to migrate Angular 1 applications to Angular 2.\n     *\n     * @experimental\n     */\n    var UrlHandlingStrategy = (function () {\n        function UrlHandlingStrategy() {\n        }\n        return UrlHandlingStrategy;\n    }());\n    /**\n     * @experimental\n     */\n    var DefaultUrlHandlingStrategy = (function () {\n        function DefaultUrlHandlingStrategy() {\n        }\n        DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };\n        DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };\n        DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };\n        return DefaultUrlHandlingStrategy;\n    }());\n\n    /**\n     * @whatItDoes Represents an event triggered when a navigation starts.\n     *\n     * @stable\n     */\n    var NavigationStart = (function () {\n        // TODO: vsavkin: make internal\n        function NavigationStart(\n            /** @docsNotRequired */\n            id, \n            /** @docsNotRequired */\n            url) {\n            this.id = id;\n            this.url = url;\n        }\n        /** @docsNotRequired */\n        NavigationStart.prototype.toString = function () { return \"NavigationStart(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n        return NavigationStart;\n    }());\n    /**\n     * @whatItDoes Represents an event triggered when a navigation ends successfully.\n     *\n     * @stable\n     */\n    var NavigationEnd = (function () {\n        // TODO: vsavkin: make internal\n        function NavigationEnd(\n            /** @docsNotRequired */\n            id, \n            /** @docsNotRequired */\n            url, \n            /** @docsNotRequired */\n            urlAfterRedirects) {\n            this.id = id;\n            this.url = url;\n            this.urlAfterRedirects = urlAfterRedirects;\n        }\n        /** @docsNotRequired */\n        NavigationEnd.prototype.toString = function () {\n            return \"NavigationEnd(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"')\";\n        };\n        return NavigationEnd;\n    }());\n    /**\n     * @whatItDoes Represents an event triggered when a navigation is canceled.\n     *\n     * @stable\n     */\n    var NavigationCancel = (function () {\n        // TODO: vsavkin: make internal\n        function NavigationCancel(\n            /** @docsNotRequired */\n            id, \n            /** @docsNotRequired */\n            url, \n            /** @docsNotRequired */\n            reason) {\n            this.id = id;\n            this.url = url;\n            this.reason = reason;\n        }\n        /** @docsNotRequired */\n        NavigationCancel.prototype.toString = function () { return \"NavigationCancel(id: \" + this.id + \", url: '\" + this.url + \"')\"; };\n        return NavigationCancel;\n    }());\n    /**\n     * @whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.\n     *\n     * @stable\n     */\n    var NavigationError = (function () {\n        // TODO: vsavkin: make internal\n        function NavigationError(\n            /** @docsNotRequired */\n            id, \n            /** @docsNotRequired */\n            url, \n            /** @docsNotRequired */\n            error) {\n            this.id = id;\n            this.url = url;\n            this.error = error;\n        }\n        /** @docsNotRequired */\n        NavigationError.prototype.toString = function () {\n            return \"NavigationError(id: \" + this.id + \", url: '\" + this.url + \"', error: \" + this.error + \")\";\n        };\n        return NavigationError;\n    }());\n    /**\n     * @whatItDoes Represents an event triggered when routes are recognized.\n     *\n     * @stable\n     */\n    var RoutesRecognized = (function () {\n        // TODO: vsavkin: make internal\n        function RoutesRecognized(\n            /** @docsNotRequired */\n            id, \n            /** @docsNotRequired */\n            url, \n            /** @docsNotRequired */\n            urlAfterRedirects, \n            /** @docsNotRequired */\n            state) {\n            this.id = id;\n            this.url = url;\n            this.urlAfterRedirects = urlAfterRedirects;\n            this.state = state;\n        }\n        /** @docsNotRequired */\n        RoutesRecognized.prototype.toString = function () {\n            return \"RoutesRecognized(id: \" + this.id + \", url: '\" + this.url + \"', urlAfterRedirects: '\" + this.urlAfterRedirects + \"', state: \" + this.state + \")\";\n        };\n        return RoutesRecognized;\n    }());\n    function defaultErrorHandler(error) {\n        throw error;\n    }\n    /**\n     * @whatItDoes Provides the navigation and url manipulation capabilities.\n     *\n     * See {@link Routes} for more details and examples.\n     *\n     * @ngModule RouterModule\n     *\n     * @stable\n     */\n    var Router = (function () {\n        /**\n         * Creates the router service.\n         */\n        // TODO: vsavkin make internal after the final is out.\n        function Router(rootComponentType, urlSerializer, outletMap, location, injector, loader, compiler, config) {\n            this.rootComponentType = rootComponentType;\n            this.urlSerializer = urlSerializer;\n            this.outletMap = outletMap;\n            this.location = location;\n            this.injector = injector;\n            this.config = config;\n            this.navigations = new rxjs_BehaviorSubject.BehaviorSubject(null);\n            this.routerEvents = new rxjs_Subject.Subject();\n            this.navigationId = 0;\n            /**\n             * Error handler that is invoked when a navigation errors.\n             *\n             * See {@link ErrorHandler} for more information.\n             */\n            this.errorHandler = defaultErrorHandler;\n            /**\n             * Indicates if at least one navigation happened.\n             */\n            this.navigated = false;\n            /**\n             * Extracts and merges URLs. Used for Angular 1 to Angular 2 migrations.\n             */\n            this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n            this.resetConfig(config);\n            this.currentUrlTree = createEmptyUrlTree();\n            this.rawUrlTree = this.currentUrlTree;\n            this.configLoader = new RouterConfigLoader(loader, compiler);\n            this.currentRouterState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n            this.processNavigations();\n        }\n        /**\n         * @internal\n         * TODO: this should be removed once the constructor of the router made internal\n         */\n        Router.prototype.resetRootComponentType = function (rootComponentType) {\n            this.rootComponentType = rootComponentType;\n            // TODO: vsavkin router 4.0 should make the root component set to null\n            // this will simplify the lifecycle of the router.\n            this.currentRouterState.root.component = this.rootComponentType;\n        };\n        /**\n         * Sets up the location change listener and performs the initial navigation.\n         */\n        Router.prototype.initialNavigation = function () {\n            this.setUpLocationChangeListener();\n            this.navigateByUrl(this.location.path(true), { replaceUrl: true });\n        };\n        /**\n         * Sets up the location change listener.\n         */\n        Router.prototype.setUpLocationChangeListener = function () {\n            var _this = this;\n            // Zone.current.wrap is needed because of the issue with RxJS scheduler,\n            // which does not work properly with zone.js in IE and Safari\n            this.locationSubscription = this.location.subscribe(Zone.current.wrap(function (change) {\n                var rawUrlTree = _this.urlSerializer.parse(change['url']);\n                setTimeout(function () {\n                    _this.scheduleNavigation(rawUrlTree, { skipLocationChange: change['pop'], replaceUrl: true });\n                }, 0);\n            }));\n        };\n        Object.defineProperty(Router.prototype, \"routerState\", {\n            /**\n             * Returns the current route state.\n             */\n            get: function () { return this.currentRouterState; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Router.prototype, \"url\", {\n            /**\n             * Returns the current url.\n             */\n            get: function () { return this.serializeUrl(this.currentUrlTree); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Router.prototype, \"events\", {\n            /**\n             * Returns an observable of route events\n             */\n            get: function () { return this.routerEvents; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Resets the configuration used for navigation and generating links.\n         *\n         * ### Usage\n         *\n         * ```\n         * router.resetConfig([\n         *  { path: 'team/:id', component: TeamCmp, children: [\n         *    { path: 'simple', component: SimpleCmp },\n         *    { path: 'user/:name', component: UserCmp }\n         *  ] }\n         * ]);\n         * ```\n         */\n        Router.prototype.resetConfig = function (config) {\n            validateConfig(config);\n            this.config = config;\n        };\n        /**\n         * @docsNotRequired\n         */\n        Router.prototype.ngOnDestroy = function () { this.dispose(); };\n        /**\n         * Disposes of the router.\n         */\n        Router.prototype.dispose = function () { this.locationSubscription.unsubscribe(); };\n        /**\n         * Applies an array of commands to the current url tree and creates a new url tree.\n         *\n         * When given an activate route, applies the given commands starting from the route.\n         * When not given a route, applies the given command starting from the root.\n         *\n         * ### Usage\n         *\n         * ```\n         * // create /team/33/user/11\n         * router.createUrlTree(['/team', 33, 'user', 11]);\n         *\n         * // create /team/33;expand=true/user/11\n         * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n         *\n         * // you can collapse static segments like this (this works only with the first passed-in value):\n         * router.createUrlTree(['/team/33/user', userId]);\n         *\n         * // If the first segment can contain slashes, and you do not want the router to split it, you\n         * // can do the following:\n         *\n         * router.createUrlTree([{segmentPath: '/one/two'}]);\n         *\n         * // create /team/33/(user/11//right:chat)\n         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n         *\n         * // remove the right secondary node\n         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n         *\n         * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n         *\n         * // navigate to /team/33/user/11/details\n         * router.createUrlTree(['details'], {relativeTo: route});\n         *\n         * // navigate to /team/33/user/22\n         * router.createUrlTree(['../22'], {relativeTo: route});\n         *\n         * // navigate to /team/44/user/22\n         * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n         * ```\n         */\n        Router.prototype.createUrlTree = function (commands, _a) {\n            var _b = _a === void 0 ? {} : _a, relativeTo = _b.relativeTo, queryParams = _b.queryParams, fragment = _b.fragment, preserveQueryParams = _b.preserveQueryParams, preserveFragment = _b.preserveFragment;\n            var a = relativeTo ? relativeTo : this.routerState.root;\n            var q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams;\n            var f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n            return createUrlTree(a, this.currentUrlTree, commands, q, f);\n        };\n        /**\n         * Navigate based on the provided url. This navigation is always absolute.\n         *\n         * Returns a promise that:\n         * - is resolved with 'true' when navigation succeeds\n         * - is resolved with 'false' when navigation fails\n         * - is rejected when an error happens\n         *\n         * ### Usage\n         *\n         * ```\n         * router.navigateByUrl(\"/team/33/user/11\");\n         *\n         * // Navigate without updating the URL\n         * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n         * ```\n         *\n         * In opposite to `navigate`, `navigateByUrl` takes a whole URL\n         * and does not apply any delta to the current one.\n         */\n        Router.prototype.navigateByUrl = function (url, extras) {\n            if (extras === void 0) { extras = { skipLocationChange: false }; }\n            if (url instanceof UrlTree) {\n                return this.scheduleNavigation(this.urlHandlingStrategy.merge(url, this.rawUrlTree), extras);\n            }\n            else {\n                var urlTree = this.urlSerializer.parse(url);\n                return this.scheduleNavigation(this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree), extras);\n            }\n        };\n        /**\n         * Navigate based on the provided array of commands and a starting point.\n         * If no starting route is provided, the navigation is absolute.\n         *\n         * Returns a promise that:\n         * - is resolved with 'true' when navigation succeeds\n         * - is resolved with 'false' when navigation fails\n         * - is rejected when an error happens\n         *\n         * ### Usage\n         *\n         * ```\n         * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n         *\n         * // Navigate without updating the URL\n         * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true });\n         * ```\n         *\n         * In opposite to `navigateByUrl`, `navigate` always takes a delta\n         * that is applied to the current URL.\n         */\n        Router.prototype.navigate = function (commands, extras) {\n            if (extras === void 0) { extras = { skipLocationChange: false }; }\n            if (typeof extras.queryParams === 'object' && extras.queryParams !== null) {\n                extras.queryParams = this.removeEmptyProps(extras.queryParams);\n            }\n            return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n        };\n        /**\n         * Serializes a {@link UrlTree} into a string.\n         */\n        Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };\n        /**\n         * Parses a string into a {@link UrlTree}.\n         */\n        Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };\n        /**\n         * Returns if the url is activated or not.\n         */\n        Router.prototype.isActive = function (url, exact) {\n            if (url instanceof UrlTree) {\n                return containsTree(this.currentUrlTree, url, exact);\n            }\n            else {\n                var urlTree = this.urlSerializer.parse(url);\n                return containsTree(this.currentUrlTree, urlTree, exact);\n            }\n        };\n        Router.prototype.removeEmptyProps = function (params) {\n            return Object.keys(params).reduce(function (result, key) {\n                var value = params[key];\n                if (value !== null && value !== undefined) {\n                    result[key] = value;\n                }\n                return result;\n            }, {});\n        };\n        Router.prototype.processNavigations = function () {\n            var _this = this;\n            rxjs_operator_concatMap.concatMap\n                .call(this.navigations, function (nav) {\n                if (nav) {\n                    _this.executeScheduledNavigation(nav);\n                    // a failed navigation should not stop the router from processing\n                    // further navigations => the catch\n                    return nav.promise.catch(function () { });\n                }\n                else {\n                    return rxjs_observable_of.of(null);\n                }\n            })\n                .subscribe(function () { });\n        };\n        Router.prototype.scheduleNavigation = function (rawUrl, extras) {\n            var prevRawUrl = this.navigations.value ? this.navigations.value.rawUrl : null;\n            if (prevRawUrl && prevRawUrl.toString() === rawUrl.toString()) {\n                return this.navigations.value.promise;\n            }\n            var resolve = null;\n            var reject = null;\n            var promise = new Promise(function (res, rej) {\n                resolve = res;\n                reject = rej;\n            });\n            var id = ++this.navigationId;\n            this.navigations.next({ id: id, rawUrl: rawUrl, prevRawUrl: prevRawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });\n            // Make sure that the error is propagated even though `processNavigations` catch\n            // handler does not rethrow\n            return promise.catch(function (e) { return Promise.reject(e); });\n        };\n        Router.prototype.executeScheduledNavigation = function (_a) {\n            var _this = this;\n            var id = _a.id, rawUrl = _a.rawUrl, prevRawUrl = _a.prevRawUrl, extras = _a.extras, resolve = _a.resolve, reject = _a.reject;\n            var url = this.urlHandlingStrategy.extract(rawUrl);\n            var prevUrl = prevRawUrl ? this.urlHandlingStrategy.extract(prevRawUrl) : null;\n            var urlTransition = !prevUrl || url.toString() !== prevUrl.toString();\n            if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n                this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n                Promise.resolve()\n                    .then(function (_) { return _this.runNavigate(url, rawUrl, extras.skipLocationChange, extras.replaceUrl, id, null); })\n                    .then(resolve, reject);\n            }\n            else if (urlTransition && prevRawUrl && this.urlHandlingStrategy.shouldProcessUrl(prevRawUrl)) {\n                this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));\n                Promise.resolve()\n                    .then(function (_) { return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot); })\n                    .then(resolve, reject);\n            }\n            else {\n                this.rawUrlTree = rawUrl;\n                resolve(null);\n            }\n        };\n        Router.prototype.runNavigate = function (url, rawUrl, shouldPreventPushState, shouldReplaceUrl, id, precreatedState) {\n            var _this = this;\n            if (id !== this.navigationId) {\n                this.location.go(this.urlSerializer.serialize(this.currentUrlTree));\n                this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \" + id + \" is not equal to the current navigation id \" + this.navigationId));\n                return Promise.resolve(false);\n            }\n            return new Promise(function (resolvePromise, rejectPromise) {\n                // create an observable of the url and route state snapshot\n                // this operation do not result in any side effects\n                var urlAndSnapshot$;\n                if (!precreatedState) {\n                    var redirectsApplied$ = applyRedirects(_this.injector, _this.configLoader, _this.urlSerializer, url, _this.config);\n                    urlAndSnapshot$ = rxjs_operator_mergeMap.mergeMap.call(redirectsApplied$, function (appliedUrl) {\n                        return rxjs_operator_map.map.call(recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl)), function (snapshot) {\n                            _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));\n                            return { appliedUrl: appliedUrl, snapshot: snapshot };\n                        });\n                    });\n                }\n                else {\n                    urlAndSnapshot$ = rxjs_observable_of.of({ appliedUrl: url, snapshot: precreatedState });\n                }\n                // run preactivation: guards and data resolvers\n                var preActivation;\n                var preactivationTraverse$ = rxjs_operator_map.map.call(urlAndSnapshot$, function (_a) {\n                    var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n                    preActivation =\n                        new PreActivation(snapshot, _this.currentRouterState.snapshot, _this.injector);\n                    preActivation.traverse(_this.outletMap);\n                    return { appliedUrl: appliedUrl, snapshot: snapshot };\n                });\n                var preactivationCheckGuards = rxjs_operator_mergeMap.mergeMap.call(preactivationTraverse$, function (_a) {\n                    var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot;\n                    if (_this.navigationId !== id)\n                        return rxjs_observable_of.of(false);\n                    return rxjs_operator_map.map.call(preActivation.checkGuards(), function (shouldActivate) {\n                        return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };\n                    });\n                });\n                var preactivationResolveData$ = rxjs_operator_mergeMap.mergeMap.call(preactivationCheckGuards, function (p) {\n                    if (_this.navigationId !== id)\n                        return rxjs_observable_of.of(false);\n                    if (p.shouldActivate) {\n                        return rxjs_operator_map.map.call(preActivation.resolveData(), function () { return p; });\n                    }\n                    else {\n                        return rxjs_observable_of.of(p);\n                    }\n                });\n                // create router state\n                // this operation has side effects => route state is being affected\n                var routerState$ = rxjs_operator_map.map.call(preactivationResolveData$, function (_a) {\n                    var appliedUrl = _a.appliedUrl, snapshot = _a.snapshot, shouldActivate = _a.shouldActivate;\n                    if (shouldActivate) {\n                        var state = createRouterState(snapshot, _this.currentRouterState);\n                        return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };\n                    }\n                    else {\n                        return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };\n                    }\n                });\n                // applied the new router state\n                // this operation has side effects\n                var navigationIsSuccessful;\n                var storedState = _this.currentRouterState;\n                var storedUrl = _this.currentUrlTree;\n                routerState$\n                    .forEach(function (_a) {\n                    var appliedUrl = _a.appliedUrl, state = _a.state, shouldActivate = _a.shouldActivate;\n                    if (!shouldActivate || id !== _this.navigationId) {\n                        navigationIsSuccessful = false;\n                        return;\n                    }\n                    _this.currentUrlTree = appliedUrl;\n                    _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n                    _this.currentRouterState = state;\n                    if (!shouldPreventPushState) {\n                        var path = _this.urlSerializer.serialize(_this.rawUrlTree);\n                        if (_this.location.isCurrentPathEqualTo(path) || shouldReplaceUrl) {\n                            _this.location.replaceState(path);\n                        }\n                        else {\n                            _this.location.go(path);\n                        }\n                    }\n                    new ActivateRoutes(state, storedState).activate(_this.outletMap);\n                    navigationIsSuccessful = true;\n                })\n                    .then(function () {\n                    _this.navigated = true;\n                    if (navigationIsSuccessful) {\n                        _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));\n                        resolvePromise(true);\n                    }\n                    else {\n                        _this.resetUrlToCurrentUrlTree();\n                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), ''));\n                        resolvePromise(false);\n                    }\n                }, function (e) {\n                    if (e instanceof NavigationCancelingError) {\n                        _this.resetUrlToCurrentUrlTree();\n                        _this.navigated = true;\n                        _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));\n                        resolvePromise(false);\n                    }\n                    else {\n                        _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));\n                        try {\n                            resolvePromise(_this.errorHandler(e));\n                        }\n                        catch (ee) {\n                            rejectPromise(ee);\n                        }\n                    }\n                    _this.currentRouterState = storedState;\n                    _this.currentUrlTree = storedUrl;\n                    _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);\n                    _this.location.replaceState(_this.serializeUrl(_this.rawUrlTree));\n                });\n            });\n        };\n        Router.prototype.resetUrlToCurrentUrlTree = function () {\n            var path = this.urlSerializer.serialize(this.rawUrlTree);\n            this.location.replaceState(path);\n        };\n        return Router;\n    }());\n    var CanActivate = (function () {\n        function CanActivate(path) {\n            this.path = path;\n        }\n        Object.defineProperty(CanActivate.prototype, \"route\", {\n            get: function () { return this.path[this.path.length - 1]; },\n            enumerable: true,\n            configurable: true\n        });\n        return CanActivate;\n    }());\n    var CanDeactivate = (function () {\n        function CanDeactivate(component, route) {\n            this.component = component;\n            this.route = route;\n        }\n        return CanDeactivate;\n    }());\n    var PreActivation = (function () {\n        function PreActivation(future, curr, injector) {\n            this.future = future;\n            this.curr = curr;\n            this.injector = injector;\n            this.checks = [];\n        }\n        PreActivation.prototype.traverse = function (parentOutletMap) {\n            var futureRoot = this.future._root;\n            var currRoot = this.curr ? this.curr._root : null;\n            this.traverseChildRoutes(futureRoot, currRoot, parentOutletMap, [futureRoot.value]);\n        };\n        PreActivation.prototype.checkGuards = function () {\n            var _this = this;\n            if (this.checks.length === 0)\n                return rxjs_observable_of.of(true);\n            var checks$ = rxjs_observable_from.from(this.checks);\n            var runningChecks$ = rxjs_operator_mergeMap.mergeMap.call(checks$, function (s) {\n                if (s instanceof CanActivate) {\n                    return andObservables(rxjs_observable_from.from([_this.runCanActivateChild(s.path), _this.runCanActivate(s.route)]));\n                }\n                else if (s instanceof CanDeactivate) {\n                    // workaround https://github.com/Microsoft/TypeScript/issues/7271\n                    var s2 = s;\n                    return _this.runCanDeactivate(s2.component, s2.route);\n                }\n                else {\n                    throw new Error('Cannot be reached');\n                }\n            });\n            return rxjs_operator_every.every.call(runningChecks$, function (result) { return result === true; });\n        };\n        PreActivation.prototype.resolveData = function () {\n            var _this = this;\n            if (this.checks.length === 0)\n                return rxjs_observable_of.of(null);\n            var checks$ = rxjs_observable_from.from(this.checks);\n            var runningChecks$ = rxjs_operator_concatMap.concatMap.call(checks$, function (s) {\n                if (s instanceof CanActivate) {\n                    return _this.runResolve(s.route);\n                }\n                else {\n                    return rxjs_observable_of.of(null);\n                }\n            });\n            return rxjs_operator_reduce.reduce.call(runningChecks$, function (_, __) { return _; });\n        };\n        PreActivation.prototype.traverseChildRoutes = function (futureNode, currNode, outletMap, futurePath) {\n            var _this = this;\n            var prevChildren = nodeChildrenAsMap(currNode);\n            futureNode.children.forEach(function (c) {\n                _this.traverseRoutes(c, prevChildren[c.value.outlet], outletMap, futurePath.concat([c.value]));\n                delete prevChildren[c.value.outlet];\n            });\n            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap._outlets[k]); });\n        };\n        PreActivation.prototype.traverseRoutes = function (futureNode, currNode, parentOutletMap, futurePath) {\n            var future = futureNode.value;\n            var curr = currNode ? currNode.value : null;\n            var outlet = parentOutletMap ? parentOutletMap._outlets[futureNode.value.outlet] : null;\n            // reusing the node\n            if (curr && future._routeConfig === curr._routeConfig) {\n                if (!equalParamsAndUrlSegments(future, curr)) {\n                    this.checks.push(new CanDeactivate(outlet.component, curr), new CanActivate(futurePath));\n                }\n                else {\n                    // we need to set the data\n                    future.data = curr.data;\n                    future._resolvedData = curr._resolvedData;\n                }\n                // If we have a component, we need to go through an outlet.\n                if (future.component) {\n                    this.traverseChildRoutes(futureNode, currNode, outlet ? outlet.outletMap : null, futurePath);\n                }\n                else {\n                    this.traverseChildRoutes(futureNode, currNode, parentOutletMap, futurePath);\n                }\n            }\n            else {\n                if (curr) {\n                    this.deactiveRouteAndItsChildren(currNode, outlet);\n                }\n                this.checks.push(new CanActivate(futurePath));\n                // If we have a component, we need to go through an outlet.\n                if (future.component) {\n                    this.traverseChildRoutes(futureNode, null, outlet ? outlet.outletMap : null, futurePath);\n                }\n                else {\n                    this.traverseChildRoutes(futureNode, null, parentOutletMap, futurePath);\n                }\n            }\n        };\n        PreActivation.prototype.deactiveRouteAndItsChildren = function (route, outlet) {\n            var _this = this;\n            var prevChildren = nodeChildrenAsMap(route);\n            var r = route.value;\n            forEach(prevChildren, function (v, k) {\n                if (!r.component) {\n                    _this.deactiveRouteAndItsChildren(v, outlet);\n                }\n                else if (!!outlet) {\n                    _this.deactiveRouteAndItsChildren(v, outlet.outletMap._outlets[k]);\n                }\n                else {\n                    _this.deactiveRouteAndItsChildren(v, null);\n                }\n            });\n            if (!r.component) {\n                this.checks.push(new CanDeactivate(null, r));\n            }\n            else if (outlet && outlet.isActivated) {\n                this.checks.push(new CanDeactivate(outlet.component, r));\n            }\n            else {\n                this.checks.push(new CanDeactivate(null, r));\n            }\n        };\n        PreActivation.prototype.runCanActivate = function (future) {\n            var _this = this;\n            var canActivate = future._routeConfig ? future._routeConfig.canActivate : null;\n            if (!canActivate || canActivate.length === 0)\n                return rxjs_observable_of.of(true);\n            var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(canActivate), function (c) {\n                var guard = _this.getToken(c, future);\n                var observable;\n                if (guard.canActivate) {\n                    observable = wrapIntoObservable(guard.canActivate(future, _this.future));\n                }\n                else {\n                    observable = wrapIntoObservable(guard(future, _this.future));\n                }\n                return rxjs_operator_first.first.call(observable);\n            });\n            return andObservables(obs);\n        };\n        PreActivation.prototype.runCanActivateChild = function (path) {\n            var _this = this;\n            var future = path[path.length - 1];\n            var canActivateChildGuards = path.slice(0, path.length - 1)\n                .reverse()\n                .map(function (p) { return _this.extractCanActivateChild(p); })\n                .filter(function (_) { return _ !== null; });\n            return andObservables(rxjs_operator_map.map.call(rxjs_observable_from.from(canActivateChildGuards), function (d) {\n                var obs = rxjs_operator_map.map.call(rxjs_observable_from.from(d.guards), function (c) {\n                    var guard = _this.getToken(c, c.node);\n                    var observable;\n                    if (guard.canActivateChild) {\n                        observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));\n                    }\n                    else {\n                        observable = wrapIntoObservable(guard(future, _this.future));\n                    }\n                    return rxjs_operator_first.first.call(observable);\n                });\n                return andObservables(obs);\n            }));\n        };\n        PreActivation.prototype.extractCanActivateChild = function (p) {\n            var canActivateChild = p._routeConfig ? p._routeConfig.canActivateChild : null;\n            if (!canActivateChild || canActivateChild.length === 0)\n                return null;\n            return { node: p, guards: canActivateChild };\n        };\n        PreActivation.prototype.runCanDeactivate = function (component, curr) {\n            var _this = this;\n            var canDeactivate = curr && curr._routeConfig ? curr._routeConfig.canDeactivate : null;\n            if (!canDeactivate || canDeactivate.length === 0)\n                return rxjs_observable_of.of(true);\n            var canDeactivate$ = rxjs_operator_mergeMap.mergeMap.call(rxjs_observable_from.from(canDeactivate), function (c) {\n                var guard = _this.getToken(c, curr);\n                var observable;\n                if (guard.canDeactivate) {\n                    observable = wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr));\n                }\n                else {\n                    observable = wrapIntoObservable(guard(component, curr, _this.curr));\n                }\n                return rxjs_operator_first.first.call(observable);\n            });\n            return rxjs_operator_every.every.call(canDeactivate$, function (result) { return result === true; });\n        };\n        PreActivation.prototype.runResolve = function (future) {\n            var resolve = future._resolve;\n            return rxjs_operator_map.map.call(this.resolveNode(resolve, future), function (resolvedData) {\n                future._resolvedData = resolvedData;\n                future.data = merge(future.data, inheritedParamsDataResolve(future).resolve);\n                return null;\n            });\n        };\n        PreActivation.prototype.resolveNode = function (resolve, future) {\n            var _this = this;\n            return waitForMap(resolve, function (k, v) {\n                var resolver = _this.getToken(v, future);\n                return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, _this.future)) :\n                    wrapIntoObservable(resolver(future, _this.future));\n            });\n        };\n        PreActivation.prototype.getToken = function (token, snapshot) {\n            var config = closestLoadedConfig(snapshot);\n            var injector = config ? config.injector : this.injector;\n            return injector.get(token);\n        };\n        return PreActivation;\n    }());\n    var ActivateRoutes = (function () {\n        function ActivateRoutes(futureState, currState) {\n            this.futureState = futureState;\n            this.currState = currState;\n        }\n        ActivateRoutes.prototype.activate = function (parentOutletMap) {\n            var futureRoot = this.futureState._root;\n            var currRoot = this.currState ? this.currState._root : null;\n            this.deactivateChildRoutes(futureRoot, currRoot, parentOutletMap);\n            advanceActivatedRoute(this.futureState.root);\n            this.activateChildRoutes(futureRoot, currRoot, parentOutletMap);\n        };\n        ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, outletMap) {\n            var _this = this;\n            var prevChildren = nodeChildrenAsMap(currNode);\n            futureNode.children.forEach(function (c) {\n                _this.deactivateRoutes(c, prevChildren[c.value.outlet], outletMap);\n                delete prevChildren[c.value.outlet];\n            });\n            forEach(prevChildren, function (v, k) { return _this.deactiveRouteAndItsChildren(v, outletMap); });\n        };\n        ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, outletMap) {\n            var _this = this;\n            var prevChildren = nodeChildrenAsMap(currNode);\n            futureNode.children.forEach(function (c) { _this.activateRoutes(c, prevChildren[c.value.outlet], outletMap); });\n        };\n        ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentOutletMap) {\n            var future = futureNode.value;\n            var curr = currNode ? currNode.value : null;\n            // reusing the node\n            if (future === curr) {\n                // If we have a normal route, we need to go through an outlet.\n                if (future.component) {\n                    var outlet = getOutlet(parentOutletMap, future);\n                    this.deactivateChildRoutes(futureNode, currNode, outlet.outletMap);\n                }\n                else {\n                    this.deactivateChildRoutes(futureNode, currNode, parentOutletMap);\n                }\n            }\n            else {\n                if (curr) {\n                    this.deactiveRouteAndItsChildren(currNode, parentOutletMap);\n                }\n            }\n        };\n        ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentOutletMap) {\n            var future = futureNode.value;\n            var curr = currNode ? currNode.value : null;\n            // reusing the node\n            if (future === curr) {\n                // advance the route to push the parameters\n                advanceActivatedRoute(future);\n                // If we have a normal route, we need to go through an outlet.\n                if (future.component) {\n                    var outlet = getOutlet(parentOutletMap, future);\n                    this.activateChildRoutes(futureNode, currNode, outlet.outletMap);\n                }\n                else {\n                    this.activateChildRoutes(futureNode, currNode, parentOutletMap);\n                }\n            }\n            else {\n                // if we have a normal route, we need to advance the route\n                // and place the component into the outlet. After that recurse.\n                if (future.component) {\n                    advanceActivatedRoute(future);\n                    var outlet = getOutlet(parentOutletMap, futureNode.value);\n                    var outletMap = new RouterOutletMap();\n                    this.placeComponentIntoOutlet(outletMap, future, outlet);\n                    this.activateChildRoutes(futureNode, null, outletMap);\n                }\n                else {\n                    advanceActivatedRoute(future);\n                    this.activateChildRoutes(futureNode, null, parentOutletMap);\n                }\n            }\n        };\n        ActivateRoutes.prototype.placeComponentIntoOutlet = function (outletMap, future, outlet) {\n            var resolved = [{ provide: ActivatedRoute, useValue: future }, {\n                    provide: RouterOutletMap,\n                    useValue: outletMap\n                }];\n            var config = parentLoadedConfig(future.snapshot);\n            var resolver = null;\n            var injector = null;\n            if (config) {\n                injector = config.injectorFactory(outlet.locationInjector);\n                resolver = config.factoryResolver;\n                resolved.push({ provide: _angular_core.ComponentFactoryResolver, useValue: resolver });\n            }\n            else {\n                injector = outlet.locationInjector;\n                resolver = outlet.locationFactoryResolver;\n            }\n            outlet.activate(future, resolver, injector, _angular_core.ReflectiveInjector.resolve(resolved), outletMap);\n        };\n        ActivateRoutes.prototype.deactiveRouteAndItsChildren = function (route, parentOutletMap) {\n            var _this = this;\n            var prevChildren = nodeChildrenAsMap(route);\n            var outlet = null;\n            // getOutlet throws when cannot find the right outlet,\n            // which can happen if an outlet was in an NgIf and was removed\n            try {\n                outlet = getOutlet(parentOutletMap, route.value);\n            }\n            catch (e) {\n                return;\n            }\n            var childOutletMap = outlet.outletMap;\n            forEach(prevChildren, function (v, k) {\n                if (route.value.component) {\n                    _this.deactiveRouteAndItsChildren(v, childOutletMap);\n                }\n                else {\n                    _this.deactiveRouteAndItsChildren(v, parentOutletMap);\n                }\n            });\n            if (outlet && outlet.isActivated) {\n                outlet.deactivate();\n            }\n        };\n        return ActivateRoutes;\n    }());\n    function parentLoadedConfig(snapshot) {\n        var s = snapshot.parent;\n        while (s) {\n            var c = s._routeConfig;\n            if (c && c._loadedConfig)\n                return c._loadedConfig;\n            if (c && c.component)\n                return null;\n            s = s.parent;\n        }\n        return null;\n    }\n    function closestLoadedConfig(snapshot) {\n        if (!snapshot)\n            return null;\n        var s = snapshot.parent;\n        while (s) {\n            var c = s._routeConfig;\n            if (c && c._loadedConfig)\n                return c._loadedConfig;\n            s = s.parent;\n        }\n        return null;\n    }\n    function nodeChildrenAsMap(node) {\n        return node ? node.children.reduce(function (m, c) {\n            m[c.value.outlet] = c;\n            return m;\n        }, {}) : {};\n    }\n    function getOutlet(outletMap, route) {\n        var outlet = outletMap._outlets[route.outlet];\n        if (!outlet) {\n            var componentName = route.component.name;\n            if (route.outlet === PRIMARY_OUTLET) {\n                throw new Error(\"Cannot find primary outlet to load '\" + componentName + \"'\");\n            }\n            else {\n                throw new Error(\"Cannot find the outlet \" + route.outlet + \" to load '\" + componentName + \"'\");\n            }\n        }\n        return outlet;\n    }\n\n    /**\n     * @whatItDoes Lets you link to specific parts of your app.\n     *\n     * @howToUse\n     *\n     * Consider the following route configuration:\n\n     * ```\n     * [{ path: 'user/:name', component: UserCmp }]\n     * ```\n     *\n     * When linking to this `user/:name` route, you can write:\n     *\n     * ```\n     * <a routerLink='/user/bob'>link to user component</a>\n     * ```\n     *\n     * @description\n     *\n     * The RouterLink directives let you link to specific parts of your app.\n     *\n     * Whe the link is static, you can use the directive as follows:\n     *\n     * ```\n     * <a routerLink=\"/user/bob\">link to user component</a>\n     * ```\n     *\n     * If you use dynamic values to generate the link, you can pass an array of path\n     * segments, followed by the params for each segment.\n     *\n     * For instance `['/team', teamId, 'user', userName, {details: true}]`\n     * means that we want to generate a link to `/team/11/user/bob;details=true`.\n     *\n     * Multiple static segments can be merged into one (e.g., `['/team/11/user', userName, {details:\n     true}]`).\n     *\n     * The first segment name can be prepended with `/`, `./`, or `../`:\n     * * If the first segment begins with `/`, the router will look up the route from the root of the\n     app.\n     * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n     * instead look in the children of the current activated route.\n     * * And if the first segment begins with `../`, the router will go up one level.\n     *\n     * You can set query params and fragment as follows:\n     *\n     * ```\n     * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">link to user\n     component</a>\n     * ```\n     * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n     *\n     * You can also tell the directive to preserve the current query params and fragment:\n     *\n     * ```\n     * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>link to user\n     component</a>\n     * ```\n     *\n     * The router link directive always treats the provided input as a delta to the current url.\n     *\n     * For instance, if the current url is `/user/(box//aux:team)`.\n     *\n     * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n     * `/user/(jim//aux:team)`.\n     *\n     * @selector ':not(a)[routerLink]'\n     * @ngModule RouterModule\n     *\n     * See {@link Router.createUrlTree} for more information.\n     *\n     * @stable\n     */\n    var RouterLink = (function () {\n        function RouterLink(router, route, locationStrategy) {\n            this.router = router;\n            this.route = route;\n            this.locationStrategy = locationStrategy;\n            this.commands = [];\n        }\n        Object.defineProperty(RouterLink.prototype, \"routerLink\", {\n            set: function (data) {\n                if (Array.isArray(data)) {\n                    this.commands = data;\n                }\n                else {\n                    this.commands = [data];\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLink.prototype.onClick = function () {\n            this.router.navigateByUrl(this.urlTree);\n            return true;\n        };\n        Object.defineProperty(RouterLink.prototype, \"urlTree\", {\n            get: function () {\n                return this.router.createUrlTree(this.commands, {\n                    relativeTo: this.route,\n                    queryParams: this.queryParams,\n                    fragment: this.fragment,\n                    preserveQueryParams: toBool(this.preserveQueryParams),\n                    preserveFragment: toBool(this.preserveFragment)\n                });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLink.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: ':not(a)[routerLink]' },] },\n        ];\n        /** @nocollapse */\n        RouterLink.ctorParameters = [\n            { type: Router, },\n            { type: ActivatedRoute, },\n            { type: _angular_common.LocationStrategy, },\n        ];\n        RouterLink.propDecorators = {\n            'queryParams': [{ type: _angular_core.Input },],\n            'fragment': [{ type: _angular_core.Input },],\n            'preserveQueryParams': [{ type: _angular_core.Input },],\n            'preserveFragment': [{ type: _angular_core.Input },],\n            'routerLink': [{ type: _angular_core.Input },],\n            'onClick': [{ type: _angular_core.HostListener, args: ['click', [],] },],\n        };\n        return RouterLink;\n    }());\n    /**\n     * @whatItDoes Lets you link to specific parts of your app.\n     *\n     * See {@link RouterLink} for more information.\n     *\n     * @selector 'a[routerLink]'\n     * @ngModule RouterModule\n     *\n     * @stable\n     */\n    var RouterLinkWithHref = (function () {\n        function RouterLinkWithHref(router, route, locationStrategy) {\n            var _this = this;\n            this.router = router;\n            this.route = route;\n            this.locationStrategy = locationStrategy;\n            this.commands = [];\n            this.subscription = router.events.subscribe(function (s) {\n                if (s instanceof NavigationEnd) {\n                    _this.updateTargetUrlAndHref();\n                }\n            });\n        }\n        Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\n            set: function (data) {\n                if (Array.isArray(data)) {\n                    this.commands = data;\n                }\n                else {\n                    this.commands = [data];\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };\n        RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n        RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey) {\n            if (button !== 0 || ctrlKey || metaKey) {\n                return true;\n            }\n            if (typeof this.target === 'string' && this.target != '_self') {\n                return true;\n            }\n            this.router.navigateByUrl(this.urlTree);\n            return false;\n        };\n        RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {\n            this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n        };\n        Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\n            get: function () {\n                return this.router.createUrlTree(this.commands, {\n                    relativeTo: this.route,\n                    queryParams: this.queryParams,\n                    fragment: this.fragment,\n                    preserveQueryParams: toBool(this.preserveQueryParams),\n                    preserveFragment: toBool(this.preserveFragment)\n                });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLinkWithHref.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: 'a[routerLink]' },] },\n        ];\n        /** @nocollapse */\n        RouterLinkWithHref.ctorParameters = [\n            { type: Router, },\n            { type: ActivatedRoute, },\n            { type: _angular_common.LocationStrategy, },\n        ];\n        RouterLinkWithHref.propDecorators = {\n            'target': [{ type: _angular_core.Input },],\n            'queryParams': [{ type: _angular_core.Input },],\n            'fragment': [{ type: _angular_core.Input },],\n            'routerLinkOptions': [{ type: _angular_core.Input },],\n            'preserveQueryParams': [{ type: _angular_core.Input },],\n            'preserveFragment': [{ type: _angular_core.Input },],\n            'href': [{ type: _angular_core.HostBinding },],\n            'routerLink': [{ type: _angular_core.Input },],\n            'onClick': [{ type: _angular_core.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey'],] },],\n        };\n        return RouterLinkWithHref;\n    }());\n    function toBool(s) {\n        if (s === '')\n            return true;\n        return !!s;\n    }\n\n    /**\n     * @whatItDoes Lets you add a CSS class to an element when the link's route becomes active.\n     *\n     * @howToUse\n     *\n     * ```\n     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n     * ```\n     *\n     * @description\n     *\n     * The RouterLinkActive directive lets you add a CSS class to an element when the link's route\n     * becomes active.\n     *\n     * Consider the following example:\n     *\n     * ```\n     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n     * ```\n     *\n     * When the url is either '/user' or '/user/bob', the active-link class will\n     * be added to the `a` tag. If the url changes, the class will be removed.\n     *\n     * You can set more than one class, as follows:\n     *\n     * ```\n     * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n     * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n     * ```\n     *\n     * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n     * only when the url matches the link exactly.\n     *\n     * ```\n     * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n     * true}\">Bob</a>\n     * ```\n     *\n     * You can assign the RouterLinkActive instance to a template variable and directly check\n     * the `isActive` status.\n     * ```\n     * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n     *   Bob {{ rla.isActive ? '(already open)' : ''}}\n     * </a>\n     * ```\n     *\n     * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n     *\n     * ```\n     * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n     *   <a routerLink=\"/user/jim\">Jim</a>\n     *   <a routerLink=\"/user/bob\">Bob</a>\n     * </div>\n     * ```\n     *\n     * This will set the active-link class on the div tag if the url is either '/user/jim' or\n     * '/user/bob'.\n     *\n     * @selector ':not(a)[routerLink]'\n     * @ngModule RouterModule\n     *\n     * @stable\n     */\n    var RouterLinkActive = (function () {\n        function RouterLinkActive(router, element, renderer) {\n            var _this = this;\n            this.router = router;\n            this.element = element;\n            this.renderer = renderer;\n            this.classes = [];\n            this.routerLinkActiveOptions = { exact: false };\n            this.subscription = router.events.subscribe(function (s) {\n                if (s instanceof NavigationEnd) {\n                    _this.update();\n                }\n            });\n        }\n        Object.defineProperty(RouterLinkActive.prototype, \"isActive\", {\n            get: function () { return this.hasActiveLink(); },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLinkActive.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this.links.changes.subscribe(function (s) { return _this.update(); });\n            this.linksWithHrefs.changes.subscribe(function (s) { return _this.update(); });\n            this.update();\n        };\n        Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\n            set: function (data) {\n                if (Array.isArray(data)) {\n                    this.classes = data;\n                }\n                else {\n                    this.classes = data.split(' ');\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };\n        RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n        RouterLinkActive.prototype.update = function () {\n            var _this = this;\n            if (!this.links || !this.linksWithHrefs || !this.router.navigated)\n                return;\n            var isActive = this.hasActiveLink();\n            this.classes.forEach(function (c) {\n                if (c) {\n                    _this.renderer.setElementClass(_this.element.nativeElement, c, isActive);\n                }\n            });\n        };\n        RouterLinkActive.prototype.isLinkActive = function (router) {\n            var _this = this;\n            return function (link) {\n                return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\n            };\n        };\n        RouterLinkActive.prototype.hasActiveLink = function () {\n            return this.links.some(this.isLinkActive(this.router)) ||\n                this.linksWithHrefs.some(this.isLinkActive(this.router));\n        };\n        RouterLinkActive.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[routerLinkActive]',\n                        exportAs: 'routerLinkActive',\n                    },] },\n        ];\n        /** @nocollapse */\n        RouterLinkActive.ctorParameters = [\n            { type: Router, },\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n        ];\n        RouterLinkActive.propDecorators = {\n            'links': [{ type: _angular_core.ContentChildren, args: [RouterLink, { descendants: true },] },],\n            'linksWithHrefs': [{ type: _angular_core.ContentChildren, args: [RouterLinkWithHref, { descendants: true },] },],\n            'routerLinkActiveOptions': [{ type: _angular_core.Input },],\n            'routerLinkActive': [{ type: _angular_core.Input },],\n        };\n        return RouterLinkActive;\n    }());\n\n    /**\n     * @whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router\n     * state.\n     *\n     * @howToUse\n     *\n     * ```\n     * <router-outlet></router-outlet>\n     * <router-outlet name='left'></router-outlet>\n     * <router-outlet name='right'></router-outlet>\n     * ```\n     *\n     * A router outlet will emit an activate event any time a new component is being instantiated,\n     * and a deactivate event when it is being destroyed.\n     *\n     * ```\n     * <router-outlet\n     *   (activate)='onActivate($event)'\n     *   (deactivate)='onDeactivate($event)'></router-outlet>\n     * ```\n     * @selector 'a[routerLink]'\n     * @ngModule RouterModule\n     *\n     * @stable\n     */\n    var RouterOutlet = (function () {\n        function RouterOutlet(parentOutletMap, location, resolver, name) {\n            this.parentOutletMap = parentOutletMap;\n            this.location = location;\n            this.resolver = resolver;\n            this.name = name;\n            this.activateEvents = new _angular_core.EventEmitter();\n            this.deactivateEvents = new _angular_core.EventEmitter();\n            parentOutletMap.registerOutlet(name ? name : PRIMARY_OUTLET, this);\n        }\n        RouterOutlet.prototype.ngOnDestroy = function () { this.parentOutletMap.removeOutlet(this.name ? this.name : PRIMARY_OUTLET); };\n        Object.defineProperty(RouterOutlet.prototype, \"locationInjector\", {\n            get: function () { return this.location.injector; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RouterOutlet.prototype, \"locationFactoryResolver\", {\n            get: function () { return this.resolver; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\n            get: function () { return !!this.activated; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RouterOutlet.prototype, \"component\", {\n            get: function () {\n                if (!this.activated)\n                    throw new Error('Outlet is not activated');\n                return this.activated.instance;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\n            get: function () {\n                if (!this.activated)\n                    throw new Error('Outlet is not activated');\n                return this._activatedRoute;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RouterOutlet.prototype.deactivate = function () {\n            if (this.activated) {\n                var c = this.component;\n                this.activated.destroy();\n                this.activated = null;\n                this.deactivateEvents.emit(c);\n            }\n        };\n        RouterOutlet.prototype.activate = function (activatedRoute, resolver, injector, providers, outletMap) {\n            if (this.isActivated) {\n                throw new Error('Cannot activate an already activated outlet');\n            }\n            this.outletMap = outletMap;\n            this._activatedRoute = activatedRoute;\n            var snapshot = activatedRoute._futureSnapshot;\n            var component = snapshot._routeConfig.component;\n            var factory = resolver.resolveComponentFactory(component);\n            var inj = _angular_core.ReflectiveInjector.fromResolvedProviders(providers, injector);\n            this.activated = this.location.createComponent(factory, this.location.length, inj, []);\n            this.activated.changeDetectorRef.detectChanges();\n            this.activateEvents.emit(this.activated.instance);\n        };\n        RouterOutlet.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: 'router-outlet' },] },\n        ];\n        /** @nocollapse */\n        RouterOutlet.ctorParameters = [\n            { type: RouterOutletMap, },\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.ComponentFactoryResolver, },\n            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['name',] },] },\n        ];\n        RouterOutlet.propDecorators = {\n            'activateEvents': [{ type: _angular_core.Output, args: ['activate',] },],\n            'deactivateEvents': [{ type: _angular_core.Output, args: ['deactivate',] },],\n        };\n        return RouterOutlet;\n    }());\n\n    var getDOM = _angular_platformBrowser.__platform_browser_private__.getDOM;\n\n    /**\n     * @whatItDoes Provides a preloading strategy.\n     *\n     * @experimental\n     */\n    var PreloadingStrategy = (function () {\n        function PreloadingStrategy() {\n        }\n        return PreloadingStrategy;\n    }());\n    /**\n     * @whatItDoes Provides a preloading strategy that preloads all modules as quicky as possible.\n     *\n     * @howToUse\n     *\n     * ```\n     * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n     * ```\n     *\n     * @experimental\n     */\n    var PreloadAllModules = (function () {\n        function PreloadAllModules() {\n        }\n        PreloadAllModules.prototype.preload = function (route, fn) {\n            return rxjs_operator_catch._catch.call(fn(), function () { return rxjs_observable_of.of(null); });\n        };\n        return PreloadAllModules;\n    }());\n    /**\n     * @whatItDoes Provides a preloading strategy that does not preload any modules.\n     *\n     * @description\n     *\n     * This strategy is enabled by default.\n     *\n     * @experimental\n     */\n    var NoPreloading = (function () {\n        function NoPreloading() {\n        }\n        NoPreloading.prototype.preload = function (route, fn) { return rxjs_observable_of.of(null); };\n        return NoPreloading;\n    }());\n    /**\n     * The preloader optimistically loads all router configurations to\n     * make navigations into lazily-loaded sections of the application faster.\n     *\n     * The preloader runs in the background. When the router bootstraps, the preloader\n     * starts listening to all navigation events. After every such event, the preloader\n     * will check if any configurations can be loaded lazily.\n     *\n     * If a route is protected by `canLoad` guards, the preloaded will not load it.\n     *\n     * @stable\n     */\n    var RouterPreloader = (function () {\n        function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n            this.router = router;\n            this.injector = injector;\n            this.preloadingStrategy = preloadingStrategy;\n            this.loader = new RouterConfigLoader(moduleLoader, compiler);\n        }\n        ;\n        RouterPreloader.prototype.setUpPreloading = function () {\n            var _this = this;\n            var navigations = rxjs_operator_filter.filter.call(this.router.events, function (e) { return e instanceof NavigationEnd; });\n            this.subscription = rxjs_operator_concatMap.concatMap.call(navigations, function () { return _this.preload(); }).subscribe(function (v) { });\n        };\n        RouterPreloader.prototype.preload = function () { return this.processRoutes(this.injector, this.router.config); };\n        RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\n        RouterPreloader.prototype.processRoutes = function (injector, routes) {\n            var res = [];\n            for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n                var c = routes_1[_i];\n                // we already have the config loaded, just recurce\n                if (c.loadChildren && !c.canLoad && c._loadedConfig) {\n                    var childConfig = c._loadedConfig;\n                    res.push(this.processRoutes(childConfig.injector, childConfig.routes));\n                }\n                else if (c.loadChildren && !c.canLoad) {\n                    res.push(this.preloadConfig(injector, c));\n                }\n                else if (c.children) {\n                    res.push(this.processRoutes(injector, c.children));\n                }\n            }\n            return rxjs_operator_mergeAll.mergeAll.call(rxjs_observable_from.from(res));\n        };\n        RouterPreloader.prototype.preloadConfig = function (injector, route) {\n            var _this = this;\n            return this.preloadingStrategy.preload(route, function () {\n                var loaded = _this.loader.load(injector, route.loadChildren);\n                return rxjs_operator_mergeMap.mergeMap.call(loaded, function (config) {\n                    var c = route;\n                    c._loadedConfig = config;\n                    return _this.processRoutes(config.injector, config.routes);\n                });\n            });\n        };\n        RouterPreloader.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        RouterPreloader.ctorParameters = [\n            { type: Router, },\n            { type: _angular_core.NgModuleFactoryLoader, },\n            { type: _angular_core.Compiler, },\n            { type: _angular_core.Injector, },\n            { type: PreloadingStrategy, },\n        ];\n        return RouterPreloader;\n    }());\n\n    /**\n     * @whatItDoes Contains a list of directives\n     * @stable\n     */\n    var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive];\n    /**\n     * @whatItDoes Is used in DI to configure the router.\n     * @stable\n     */\n    var ROUTER_CONFIGURATION = new _angular_core.OpaqueToken('ROUTER_CONFIGURATION');\n    /**\n     * @docsNotRequired\n     */\n    var ROUTER_FORROOT_GUARD = new _angular_core.OpaqueToken('ROUTER_FORROOT_GUARD');\n    var ROUTER_PROVIDERS = [\n        _angular_common.Location, { provide: UrlSerializer, useClass: DefaultUrlSerializer }, {\n            provide: Router,\n            useFactory: setupRouter,\n            deps: [\n                _angular_core.ApplicationRef, UrlSerializer, RouterOutletMap, _angular_common.Location, _angular_core.Injector, _angular_core.NgModuleFactoryLoader,\n                _angular_core.Compiler, ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new _angular_core.Optional()]\n            ]\n        },\n        RouterOutletMap, { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n        { provide: _angular_core.NgModuleFactoryLoader, useClass: _angular_core.SystemJsNgModuleLoader }, RouterPreloader, NoPreloading,\n        PreloadAllModules, { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } }\n    ];\n    /**\n     * @whatItDoes Adds router directives and providers.\n     *\n     * @howToUse\n     *\n     * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n     * Since the router deals with a global shared resource--location, we cannot have\n     * more than one router service active.\n     *\n     * That is why there are two ways to create the module: `RouterModule.forRoot` and\n     * `RouterModule.forChild`.\n     *\n     * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n     * service itself.\n     * * `forChild` creates a module that contains all the directives and the given routes, but does not\n     * include\n     * the router service.\n     *\n     * When registered at the root, the module should be used as follows\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forRoot(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * For submodules and lazy loaded submodules the module should be used as follows:\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forChild(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @description\n     *\n     * Managing state transitions is one of the hardest parts of building applications. This is\n     * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n     * In addition, we often want to split applications into multiple bundles and load them on demand.\n     * Doing this transparently is not trivial.\n     *\n     * The Angular 2 router solves these problems. Using the router, you can declaratively specify\n     * application states, manage state transitions while taking care of the URL, and load bundles on\n     * demand.\n     *\n     * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n     * overview of how the router should be used.\n     *\n     * @stable\n     */\n    var RouterModule = (function () {\n        function RouterModule(guard) {\n        }\n        /**\n         * Creates a module with all the router providers and directives. It also optionally sets up an\n         * application listener to perform an initial navigation.\n         *\n         * Options:\n         * * `enableTracing` makes the router log all its internal events to the console.\n         * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n         * API.\n         * * `initialNavigation` disables the initial navigation.\n         * * `errorHandler` provides a custom error handler.\n         */\n        RouterModule.forRoot = function (routes, config) {\n            return {\n                ngModule: RouterModule,\n                providers: [\n                    ROUTER_PROVIDERS, provideRoutes(routes), {\n                        provide: ROUTER_FORROOT_GUARD,\n                        useFactory: provideForRootGuard,\n                        deps: [[Router, new _angular_core.Optional(), new _angular_core.SkipSelf()]]\n                    },\n                    { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} }, {\n                        provide: _angular_common.LocationStrategy,\n                        useFactory: provideLocationStrategy,\n                        deps: [\n                            _angular_common.PlatformLocation, [new _angular_core.Inject(_angular_common.APP_BASE_HREF), new _angular_core.Optional()], ROUTER_CONFIGURATION\n                        ]\n                    },\n                    {\n                        provide: PreloadingStrategy,\n                        useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n                            NoPreloading\n                    },\n                    provideRouterInitializer()\n                ]\n            };\n        };\n        /**\n         * Creates a module with all the router directives and a provider registering routes.\n         */\n        RouterModule.forChild = function (routes) {\n            return { ngModule: RouterModule, providers: [provideRoutes(routes)] };\n        };\n        RouterModule.decorators = [\n            { type: _angular_core.NgModule, args: [{ declarations: ROUTER_DIRECTIVES, exports: ROUTER_DIRECTIVES },] },\n        ];\n        /** @nocollapse */\n        RouterModule.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [ROUTER_FORROOT_GUARD,] },] },\n        ];\n        return RouterModule;\n    }());\n    function provideLocationStrategy(platformLocationStrategy, baseHref, options) {\n        if (options === void 0) { options = {}; }\n        return options.useHash ? new _angular_common.HashLocationStrategy(platformLocationStrategy, baseHref) :\n            new _angular_common.PathLocationStrategy(platformLocationStrategy, baseHref);\n    }\n    function provideForRootGuard(router) {\n        if (router) {\n            throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n        }\n        return 'guarded';\n    }\n    /**\n     * @whatItDoes Registers routes.\n     *\n     * @howToUse\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forChild(ROUTES)],\n     *   providers: [provideRoutes(EXTRA_ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @stable\n     */\n    function provideRoutes(routes) {\n        return [\n            { provide: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },\n            { provide: ROUTES, multi: true, useValue: routes }\n        ];\n    }\n    function setupRouter(ref, urlSerializer, outletMap, location, injector, loader, compiler, config, opts, urlHandlingStrategy) {\n        if (opts === void 0) { opts = {}; }\n        var router = new Router(null, urlSerializer, outletMap, location, injector, loader, compiler, flatten(config));\n        if (urlHandlingStrategy) {\n            router.urlHandlingStrategy = urlHandlingStrategy;\n        }\n        if (opts.errorHandler) {\n            router.errorHandler = opts.errorHandler;\n        }\n        if (opts.enableTracing) {\n            var dom_1 = getDOM();\n            router.events.subscribe(function (e) {\n                dom_1.logGroup(\"Router Event: \" + e.constructor.name);\n                dom_1.log(e.toString());\n                dom_1.log(e);\n                dom_1.logGroupEnd();\n            });\n        }\n        return router;\n    }\n    function rootRoute(router) {\n        return router.routerState.root;\n    }\n    function initialRouterNavigation(router, ref, preloader, opts) {\n        return function (bootstrappedComponentRef) {\n            if (bootstrappedComponentRef !== ref.components[0]) {\n                return;\n            }\n            router.resetRootComponentType(ref.componentTypes[0]);\n            preloader.setUpPreloading();\n            if (opts.initialNavigation === false) {\n                router.setUpLocationChangeListener();\n            }\n            else {\n                router.initialNavigation();\n            }\n        };\n    }\n    /**\n     * A token for the router initializer that will be called after the app is bootstrapped.\n     *\n     * @experimental\n     */\n    var ROUTER_INITIALIZER = new _angular_core.OpaqueToken('Router Initializer');\n    function provideRouterInitializer() {\n        return [\n            {\n                provide: ROUTER_INITIALIZER,\n                useFactory: initialRouterNavigation,\n                deps: [Router, _angular_core.ApplicationRef, RouterPreloader, ROUTER_CONFIGURATION]\n            },\n            { provide: _angular_core.APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER }\n        ];\n    }\n\n    var __router_private__ = {\n        ROUTER_PROVIDERS: ROUTER_PROVIDERS,\n        ROUTES: ROUTES,\n        flatten: flatten\n    };\n\n    exports.RouterLink = RouterLink;\n    exports.RouterLinkWithHref = RouterLinkWithHref;\n    exports.RouterLinkActive = RouterLinkActive;\n    exports.RouterOutlet = RouterOutlet;\n    exports.NavigationCancel = NavigationCancel;\n    exports.NavigationEnd = NavigationEnd;\n    exports.NavigationError = NavigationError;\n    exports.NavigationStart = NavigationStart;\n    exports.Router = Router;\n    exports.RoutesRecognized = RoutesRecognized;\n    exports.ROUTER_CONFIGURATION = ROUTER_CONFIGURATION;\n    exports.ROUTER_INITIALIZER = ROUTER_INITIALIZER;\n    exports.RouterModule = RouterModule;\n    exports.provideRoutes = provideRoutes;\n    exports.RouterOutletMap = RouterOutletMap;\n    exports.NoPreloading = NoPreloading;\n    exports.PreloadAllModules = PreloadAllModules;\n    exports.PreloadingStrategy = PreloadingStrategy;\n    exports.RouterPreloader = RouterPreloader;\n    exports.ActivatedRoute = ActivatedRoute;\n    exports.ActivatedRouteSnapshot = ActivatedRouteSnapshot;\n    exports.RouterState = RouterState;\n    exports.RouterStateSnapshot = RouterStateSnapshot;\n    exports.PRIMARY_OUTLET = PRIMARY_OUTLET;\n    exports.UrlHandlingStrategy = UrlHandlingStrategy;\n    exports.DefaultUrlSerializer = DefaultUrlSerializer;\n    exports.UrlSegment = UrlSegment;\n    exports.UrlSegmentGroup = UrlSegmentGroup;\n    exports.UrlSerializer = UrlSerializer;\n    exports.UrlTree = UrlTree;\n    exports.__router_private__ = __router_private__;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/@angular/router/bundles/router.umd.js\n ** module id = 137\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/BehaviorSubject.js\n ** module id = 144\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/InnerSubscriber.js\n ** module id = 145\n ** module chunks = 1\n **/","\"use strict\";\nvar Observable_1 = require('./Observable');\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = (function () {\n    function Notification(kind, value, exception) {\n        this.kind = kind;\n        this.value = value;\n        this.exception = exception;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.exception);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.exception);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return Observable_1.Observable.of(this.value);\n            case 'E':\n                return Observable_1.Observable.throw(this.exception);\n            case 'C':\n                return Observable_1.Observable.empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return this.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` exception.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     */\n    Notification.createComplete = function () {\n        return this.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexports.Notification = Notification;\n//# sourceMappingURL=Notification.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Notification.js\n ** module id = 146\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/OuterSubscriber.js\n ** module id = 57\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayLikeObservable = (function (_super) {\n    __extends(ArrayLikeObservable, _super);\n    function ArrayLikeObservable(arrayLike, scheduler) {\n        _super.call(this);\n        this.arrayLike = arrayLike;\n        this.scheduler = scheduler;\n        if (!scheduler && arrayLike.length === 1) {\n            this._isScalar = true;\n            this.value = arrayLike[0];\n        }\n    }\n    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n        var length = arrayLike.length;\n        if (length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (length === 1) {\n            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n        }\n        else {\n            return new ArrayLikeObservable(arrayLike, scheduler);\n        }\n    };\n    ArrayLikeObservable.dispatch = function (state) {\n        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n        if (subscriber.closed) {\n            return;\n        }\n        if (index >= length) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(arrayLike[index]);\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n        var length = arrayLike.length;\n        if (scheduler) {\n            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < length && !subscriber.closed; i++) {\n                subscriber.next(arrayLike[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayLikeObservable;\n}(Observable_1.Observable));\nexports.ArrayLikeObservable = ArrayLikeObservable;\n//# sourceMappingURL=ArrayLikeObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ArrayLikeObservable.js\n ** module id = 149\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isScheduler_1 = require('../util/isScheduler');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = (function (_super) {\n    __extends(ArrayObservable, _super);\n    function ArrayObservable(array, scheduler) {\n        _super.call(this);\n        this.array = array;\n        this.scheduler = scheduler;\n        if (!scheduler && array.length === 1) {\n            this._isScalar = true;\n            this.value = array[0];\n        }\n    }\n    ArrayObservable.create = function (array, scheduler) {\n        return new ArrayObservable(array, scheduler);\n    };\n    /**\n     * Creates an Observable that emits some values you specify as arguments,\n     * immediately one after the other, and then emits a complete notification.\n     *\n     * <span class=\"informal\">Emits the arguments you provide, then completes.\n     * </span>\n     *\n     * <img src=\"./img/of.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the arguments given, and the complete notification thereafter. It can\n     * be used for composing with other Observables, such as with {@link concat}.\n     * By default, it uses a `null` Scheduler, which means the `next`\n     * notifications are sent synchronously, although with a different Scheduler\n     * it is possible to determine when those notifications will be delivered.\n     *\n     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n     * var numbers = Rx.Observable.of(10, 20, 30);\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = numbers.concat(letters).concat(interval);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link throw}\n     *\n     * @param {...T} values Arguments that represent `next` values to be emitted.\n     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable<T>} An Observable that emits each given input value.\n     * @static true\n     * @name of\n     * @owner Observable\n     */\n    ArrayObservable.of = function () {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i - 0] = arguments[_i];\n        }\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len > 1) {\n            return new ArrayObservable(array, scheduler);\n        }\n        else if (len === 1) {\n            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n        }\n        else {\n            return new EmptyObservable_1.EmptyObservable(scheduler);\n        }\n    };\n    ArrayObservable.dispatch = function (state) {\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(array[index]);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var array = this.array;\n        var count = array.length;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                array: array, index: index, count: count, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < count && !subscriber.closed; i++) {\n                subscriber.next(array[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayObservable;\n}(Observable_1.Observable));\nexports.ArrayObservable = ArrayObservable;\n//# sourceMappingURL=ArrayObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ArrayObservable.js\n ** module id = 86\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar EmptyObservable = (function (_super) {\n    __extends(EmptyObservable, _super);\n    function EmptyObservable(scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits a complete notification.\n     *\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/empty.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the complete notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then complete.</caption>\n     * var result = Rx.Observable.empty().startWith(7);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n     * the emission of the complete notification.\n     * @return {Observable} An \"empty\" Observable: emits only the complete\n     * notification.\n     * @static true\n     * @name empty\n     * @owner Observable\n     */\n    EmptyObservable.create = function (scheduler) {\n        return new EmptyObservable(scheduler);\n    };\n    EmptyObservable.dispatch = function (arg) {\n        var subscriber = arg.subscriber;\n        subscriber.complete();\n    };\n    EmptyObservable.prototype._subscribe = function (subscriber) {\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n        }\n        else {\n            subscriber.complete();\n        }\n    };\n    return EmptyObservable;\n}(Observable_1.Observable));\nexports.EmptyObservable = EmptyObservable;\n//# sourceMappingURL=EmptyObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/EmptyObservable.js\n ** module id = 87\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = require('../util/isArray');\nvar isPromise_1 = require('../util/isPromise');\nvar PromiseObservable_1 = require('./PromiseObservable');\nvar IteratorObservable_1 = require('./IteratorObservable');\nvar ArrayObservable_1 = require('./ArrayObservable');\nvar ArrayLikeObservable_1 = require('./ArrayLikeObservable');\nvar iterator_1 = require('../symbol/iterator');\nvar Observable_1 = require('../Observable');\nvar observeOn_1 = require('../operator/observeOn');\nvar observable_1 = require('../symbol/observable');\nvar isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromObservable = (function (_super) {\n    __extends(FromObservable, _super);\n    function FromObservable(ish, scheduler) {\n        _super.call(this, null);\n        this.ish = ish;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable from an Array, an array-like object, a Promise, an\n     * iterable object, or an Observable-like object.\n     *\n     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n     *\n     * <img src=\"./img/from.png\" width=\"100%\">\n     *\n     * Convert various other objects and data types into Observables. `from`\n     * converts a Promise or an array-like or an\n     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n     * object into an Observable that emits the items in that promise or array or\n     * iterable. A String, in this context, is treated as an array of characters.\n     * Observable-like objects (contains a function named with the ES2015 Symbol\n     * for Observable) can also be converted through this operator.\n     *\n     * @example <caption>Converts an array to an Observable</caption>\n     * var array = [10, 20, 30];\n     * var result = Rx.Observable.from(array);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n     * function* generateDoubles(seed) {\n     *   var i = seed;\n     *   while (true) {\n     *     yield i;\n     *     i = 2 * i; // double it\n     *   }\n     * }\n     *\n     * var iterator = generateDoubles(3);\n     * var result = Rx.Observable.from(iterator).take(10);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link fromEvent}\n     * @see {@link fromEventPattern}\n     * @see {@link fromPromise}\n     *\n     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n     * Observable-like, an Array, an iterable or an array-like object to be\n     * converted.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * emissions of values.\n     * @return {Observable<T>} The Observable whose values are originally from the\n     * input object that was converted.\n     * @static true\n     * @name from\n     * @owner Observable\n     */\n    FromObservable.create = function (ish, scheduler) {\n        if (ish != null) {\n            if (typeof ish[observable_1.$$observable] === 'function') {\n                if (ish instanceof Observable_1.Observable && !scheduler) {\n                    return ish;\n                }\n                return new FromObservable(ish, scheduler);\n            }\n            else if (isArray_1.isArray(ish)) {\n                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n            }\n            else if (isPromise_1.isPromise(ish)) {\n                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n            }\n            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {\n                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n            }\n            else if (isArrayLike(ish)) {\n                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n            }\n        }\n        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n    };\n    FromObservable.prototype._subscribe = function (subscriber) {\n        var ish = this.ish;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            return ish[observable_1.$$observable]().subscribe(subscriber);\n        }\n        else {\n            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n        }\n    };\n    return FromObservable;\n}(Observable_1.Observable));\nexports.FromObservable = FromObservable;\n//# sourceMappingURL=FromObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/FromObservable.js\n ** module id = 150\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IteratorObservable = (function (_super) {\n    __extends(IteratorObservable, _super);\n    function IteratorObservable(iterator, scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n        if (iterator == null) {\n            throw new Error('iterator cannot be null.');\n        }\n        this.iterator = getIterator(iterator);\n    }\n    IteratorObservable.create = function (iterator, scheduler) {\n        return new IteratorObservable(iterator, scheduler);\n    };\n    IteratorObservable.dispatch = function (state) {\n        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n        if (hasError) {\n            subscriber.error(state.error);\n            return;\n        }\n        var result = iterator.next();\n        if (result.done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(result.value);\n        state.index = index + 1;\n        if (subscriber.closed) {\n            return;\n        }\n        this.schedule(state);\n    };\n    IteratorObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                index: index, iterator: iterator, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                var result = iterator.next();\n                if (result.done) {\n                    subscriber.complete();\n                    break;\n                }\n                else {\n                    subscriber.next(result.value);\n                }\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return IteratorObservable;\n}(Observable_1.Observable));\nexports.IteratorObservable = IteratorObservable;\nvar StringIterator = (function () {\n    function StringIterator(str, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = str.length; }\n        this.str = str;\n        this.idx = idx;\n        this.len = len;\n    }\n    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };\n    StringIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.str.charAt(this.idx++)\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return StringIterator;\n}());\nvar ArrayIterator = (function () {\n    function ArrayIterator(arr, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = toLength(arr); }\n        this.arr = arr;\n        this.idx = idx;\n        this.len = len;\n    }\n    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };\n    ArrayIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return ArrayIterator;\n}());\nfunction getIterator(obj) {\n    var i = obj[iterator_1.$$iterator];\n    if (!i && typeof obj === 'string') {\n        return new StringIterator(obj);\n    }\n    if (!i && obj.length !== undefined) {\n        return new ArrayIterator(obj);\n    }\n    if (!i) {\n        throw new TypeError('object is not iterable');\n    }\n    return obj[iterator_1.$$iterator]();\n}\nvar maxSafeInteger = Math.pow(2, 53) - 1;\nfunction toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) {\n        return 0;\n    }\n    if (len === 0 || !numberIsFinite(len)) {\n        return len;\n    }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) {\n        return 0;\n    }\n    if (len > maxSafeInteger) {\n        return maxSafeInteger;\n    }\n    return len;\n}\nfunction numberIsFinite(value) {\n    return typeof value === 'number' && root_1.root.isFinite(value);\n}\nfunction sign(value) {\n    var valueAsNumber = +value;\n    if (valueAsNumber === 0) {\n        return valueAsNumber;\n    }\n    if (isNaN(valueAsNumber)) {\n        return valueAsNumber;\n    }\n    return valueAsNumber < 0 ? -1 : 1;\n}\n//# sourceMappingURL=IteratorObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/IteratorObservable.js\n ** module id = 151\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ScalarObservable = (function (_super) {\n    __extends(ScalarObservable, _super);\n    function ScalarObservable(value, scheduler) {\n        _super.call(this);\n        this.value = value;\n        this.scheduler = scheduler;\n        this._isScalar = true;\n        if (scheduler) {\n            this._isScalar = false;\n        }\n    }\n    ScalarObservable.create = function (value, scheduler) {\n        return new ScalarObservable(value, scheduler);\n    };\n    ScalarObservable.dispatch = function (state) {\n        var done = state.done, value = state.value, subscriber = state.subscriber;\n        if (done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        state.done = true;\n        this.schedule(state);\n    };\n    ScalarObservable.prototype._subscribe = function (subscriber) {\n        var value = this.value;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                done: false, value: value, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.next(value);\n            if (!subscriber.closed) {\n                subscriber.complete();\n            }\n        }\n    };\n    return ScalarObservable;\n}(Observable_1.Observable));\nexports.ScalarObservable = ScalarObservable;\n//# sourceMappingURL=ScalarObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ScalarObservable.js\n ** module id = 89\n ** module chunks = 1\n **/","\"use strict\";\nvar FromObservable_1 = require('./FromObservable');\nexports.from = FromObservable_1.FromObservable.create;\n//# sourceMappingURL=from.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/from.js\n ** module id = 152\n ** module chunks = 1\n **/","\"use strict\";\nvar ArrayObservable_1 = require('./ArrayObservable');\nexports.of = ArrayObservable_1.ArrayObservable.of;\n//# sourceMappingURL=of.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/of.js\n ** module id = 153\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} an observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    var operator = new CatchOperator(selector);\n    var caught = this.lift(operator);\n    return (operator.caught = caught);\n}\nexports._catch = _catch;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.unsubscribe();\n            this.destination.remove(this);\n            subscribeToResult_1.subscribeToResult(this, result);\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catch.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/catch.js\n ** module id = 154\n ** module chunks = 1\n **/","\"use strict\";\nvar mergeAll_1 = require('./mergeAll');\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return this.lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/concatAll.js\n ** module id = 155\n ** module chunks = 1\n **/","\"use strict\";\nvar mergeMap_1 = require('./mergeMap');\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} an observable of values merged from the projected\n * Observables as they were subscribed to, one at a time. Optionally, these\n * values may have been projected from a passed `projectResult` argument.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/concatMap.js\n ** module id = 156\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n * @param {function} predicate a function for determining if an item meets a specified condition.\n * @param {any} [thisArg] optional object to use for `this` in the callback\n * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return this.lift(new EveryOperator(predicate, thisArg, this));\n}\nexports.every = every;\nvar EveryOperator = (function () {\n    function EveryOperator(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    EveryOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    };\n    return EveryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar EverySubscriber = (function (_super) {\n    __extends(EverySubscriber, _super);\n    function EverySubscriber(destination, predicate, thisArg, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n        this.index = 0;\n        this.thisArg = thisArg || this;\n    }\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    };\n    EverySubscriber.prototype._next = function (value) {\n        var result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    };\n    EverySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return EverySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=every.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/every.js\n ** module id = 157\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctKey}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return this.lift(new FilterOperator(predicate, thisArg));\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n        this.predicate = predicate;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/filter.js\n ** module id = 158\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} an Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.first = first;\nvar FirstOperator = (function () {\n    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    FirstOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return FirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FirstSubscriber = (function (_super) {\n    __extends(FirstSubscriber, _super);\n    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.index = 0;\n        this.hasCompleted = false;\n    }\n    FirstSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._emit = function (value, index) {\n        if (this.resultSelector) {\n            this._tryResultSelector(value, index);\n            return;\n        }\n        this._emitFinal(value);\n    };\n    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this._emitFinal(result);\n    };\n    FirstSubscriber.prototype._emitFinal = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n        this.hasCompleted = true;\n    };\n    FirstSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n            destination.next(this.defaultValue);\n            destination.complete();\n        }\n        else if (!this.hasCompleted) {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return FirstSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=first.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/first.js\n ** module id = 159\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - the condition any source emitted item has to satisfy.\n * @return {Observable} an Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.last = last;\nvar LastOperator = (function () {\n    function LastOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    LastOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return LastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar LastSubscriber = (function (_super) {\n    __extends(LastSubscriber, _super);\n    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.hasValue = false;\n        this.index = 0;\n        if (typeof defaultValue !== 'undefined') {\n            this.lastValue = defaultValue;\n            this.hasValue = true;\n        }\n    }\n    LastSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.lastValue = result;\n        this.hasValue = true;\n    };\n    LastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.hasValue) {\n            destination.next(this.lastValue);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return LastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=last.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/last.js\n ** module id = 160\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/map.js\n ** module id = 161\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return this.lift(new MergeAllOperator(concurrent));\n}\nexports.mergeAll = mergeAll;\nvar MergeAllOperator = (function () {\n    function MergeAllOperator(concurrent) {\n        this.concurrent = concurrent;\n    }\n    MergeAllOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new MergeAllSubscriber(observer, this.concurrent));\n    };\n    return MergeAllOperator;\n}());\nexports.MergeAllOperator = MergeAllOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeAllSubscriber = (function (_super) {\n    __extends(MergeAllSubscriber, _super);\n    function MergeAllSubscriber(destination, concurrent) {\n        _super.call(this, destination);\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n    }\n    MergeAllSubscriber.prototype._next = function (observable) {\n        if (this.active < this.concurrent) {\n            this.active++;\n            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n        }\n        else {\n            this.buffer.push(observable);\n        }\n    };\n    MergeAllSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeAllSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeAllSubscriber = MergeAllSubscriber;\n//# sourceMappingURL=mergeAll.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/mergeAll.js\n ** module id = 91\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n}\nexports.mergeMap = mergeMap;\nvar MergeMapOperator = (function () {\n    function MergeMapOperator(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source._subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = (function (_super) {\n    __extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapSubscriber = MergeMapSubscriber;\n//# sourceMappingURL=mergeMap.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/mergeMap.js\n ** module id = 92\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * @see {@link Notification}\n *\n * @param scheduler\n * @param delay\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return this.lift(new ObserveOnOperator(scheduler, delay));\n}\nexports.observeOn = observeOn;\nvar ObserveOnOperator = (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification_1.Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification_1.Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification_1.Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\nvar ObserveOnMessage = (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexports.ObserveOnMessage = ObserveOnMessage;\n//# sourceMappingURL=observeOn.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/observeOn.js\n ** module id = 162\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    return this.lift(new ReduceOperator(accumulator, seed));\n}\nexports.reduce = reduce;\nvar ReduceOperator = (function () {\n    function ReduceOperator(accumulator, seed) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n    }\n    ReduceOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed));\n    };\n    return ReduceOperator;\n}());\nexports.ReduceOperator = ReduceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ReduceSubscriber = (function (_super) {\n    __extends(ReduceSubscriber, _super);\n    function ReduceSubscriber(destination, accumulator, seed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.hasValue = false;\n        this.acc = seed;\n        this.accumulator = accumulator;\n        this.hasSeed = typeof seed !== 'undefined';\n    }\n    ReduceSubscriber.prototype._next = function (value) {\n        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n            this._tryReduce(value);\n        }\n        else {\n            this.acc = value;\n            this.hasValue = true;\n        }\n    };\n    ReduceSubscriber.prototype._tryReduce = function (value) {\n        var result;\n        try {\n            result = this.accumulator(this.acc, value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.acc = result;\n    };\n    ReduceSubscriber.prototype._complete = function () {\n        if (this.hasValue || this.hasSeed) {\n            this.destination.next(this.acc);\n        }\n        this.destination.complete();\n    };\n    return ReduceSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ReduceSubscriber = ReduceSubscriber;\n//# sourceMappingURL=reduce.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/reduce.js\n ** module id = 163\n ** module chunks = 1\n **/","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nif (typeof Symbol === 'function') {\n    if (Symbol.iterator) {\n        exports.$$iterator = Symbol.iterator;\n    }\n    else if (typeof Symbol.for === 'function') {\n        exports.$$iterator = Symbol.for('iterator');\n    }\n}\nelse {\n    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {\n        // Bug for mozilla version\n        exports.$$iterator = '@@iterator';\n    }\n    else if (root_1.root.Map) {\n        // es6-shim specific logic\n        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {\n                exports.$$iterator = key;\n                break;\n            }\n        }\n    }\n    else {\n        exports.$$iterator = '@@iterator';\n    }\n}\n//# sourceMappingURL=iterator.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/iterator.js\n ** module id = 59\n ** module chunks = 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nvar EmptyError = (function (_super) {\n    __extends(EmptyError, _super);\n    function EmptyError() {\n        var err = _super.call(this, 'no elements in sequence');\n        this.name = err.name = 'EmptyError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return EmptyError;\n}(Error));\nexports.EmptyError = EmptyError;\n//# sourceMappingURL=EmptyError.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/EmptyError.js\n ** module id = 62\n ** module chunks = 1\n **/","\"use strict\";\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isPromise.js\n ** module id = 96\n ** module chunks = 1\n **/","\"use strict\";\nfunction isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\nexports.isScheduler = isScheduler;\n//# sourceMappingURL=isScheduler.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isScheduler.js\n ** module id = 167\n ** module chunks = 1\n **/","\"use strict\";\nvar root_1 = require('./root');\nvar isArray_1 = require('./isArray');\nvar isPromise_1 = require('./isPromise');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\nvar InnerSubscriber_1 = require('../InnerSubscriber');\nvar observable_1 = require('../symbol/observable');\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            return result.subscribe(destination);\n        }\n    }\n    if (isArray_1.isArray(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (typeof result[iterator_1.$$iterator] === 'function') {\n        var iterator = result[iterator_1.$$iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (typeof result[observable_1.$$observable] === 'function') {\n        var obs = result[observable_1.$$observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new Error('invalid observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        destination.error(new TypeError('unknown type returned'));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/subscribeToResult.js\n ** module id = 64\n ** module chunks = 1\n **/"],"sourceRoot":""}